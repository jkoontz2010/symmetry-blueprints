[{"result":"{\n\n}"},{"name":"insertIntoTemplate","args":[{},{}],"result":"{\n'968b1d77af_firsty.tsx': ()=>`import React, { useEffect, useState } from \"react\";\nimport {\n  getDescendentsOfKey,\n  rs,\n  rsCompact,\n  tts,\n  sortTemplateByDeps,\n  genTemplateWithVars,\n  argsAndTemplateToFunction,\n  multiply,\n} from \"symmetric-parser\";\n\nimport { useTemplate, WordStep } from \"../hooks/useTemplate\";\nimport { Panel, PanelGroup, PanelResizeHandle } from \"react-resizable-panels\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { useRunner } from \"../hooks/useRunner\";\nimport { last } from \"lodash\";\n\nexport type WordDefinition = {\n  name: string;\n  wordSteps: WordStep[];\n  meta?: Record<string, any>;\n};\n\nconst FAVORITE_GENERATORS = [\"orderedParse\", \"nestedParse\"];\nconst COMMON_CHARS = [\n  { name: \"comma\", value: \",\" },\n  { name: \"newline\", value: \"\\n\" },\n];\nexport const TemplateEditors = ({\n  templateDefinitions,\n  postMessage,\n  configPath,\n  filledGeneratorsFileText,\n  templateModule,\n}: {\n  templateDefinitions: WordDefinition[];\n  postMessage: any;\n  configPath: string;\n  filledGeneratorsFileText: string;\n  templateModule: any;\n}) => {\n  const {\n    generatorModule,\n    wordModule,\n    addToTemplatePool,\n    addToFilledGeneratorPool,\n    filledGenerators,\n    handleSaveAllFiles,\n  } = useRunner(postMessage, configPath, filledGeneratorsFileText);\n\n  const [stepsForPanel, setStepsForPanel] = useState<\n    Record<string, WordStep[]>\n  >({});\n\n  return (\n    <div>\n      <PanelGroup direction=\"horizontal\">\n        {templateDefinitions.map((def, i) => {\n          const generatorsTemplate = def.meta?.generators ?? {};\n\n          return (\n            <>\n              <TemplateEditor\n                definition={def}\n                templateModule={templateModule}\n                generatorModule={generatorModule}\n                generatorsTemplate={generatorsTemplate}\n                wordModule={wordModule}\n                setStepsForPanel={setStepsForPanel}\n                runnableSteps={filledGenerators}\n                addToTemplatePool={addToTemplatePool}\n                postMessage={postMessage}\n                addToFilledGeneratorPool={addToFilledGeneratorPool}\n                isMainEditor={i === 0}\n                handleSaveAllFiles={handleSaveAllFiles}\n              />\n            </>\n          );\n        })}\n      </PanelGroup>\n      <div>\n        {Object.keys(stepsForPanel)?.map((k) => {\n          //console.log(\"steps for panel\", stepsForPanel, k, stepsForPanel?.[k]);\n          return (\n            <div>\n              Tree: {k}{\" \"}\n              {stepsForPanel?.[k]?.map((step) => {\n                return <div>{step.name}---[result]</div>;\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\n// THAT TEMPLATE BETTER BE SORTED or we could sort it idk\nconst filterTemplateToKey = (input: Template, rootKey: string) => {\n  const family = getDescendentsOfKey(rootKey, input, true);\n  const newTemplate = {};\n  family.forEach((key) => {\n    newTemplate[key] = input[key];\n  });\n  return sortTemplateByDeps(newTemplate);\n};\n\nfunction getGeneratorSignatureFromKey(\n  key: string,\n  generatorsTemplate: Template\n) {\n  for (const v of Object.values(generatorsTemplate)) {\n    const str = v();\n    if (str.indexOf(key + \"(\") === 0) {\n      return str;\n    }\n  }\n}\n\nexport const TemplateEditor = ({\n  definition,\n  templateModule,\n  generatorModule,\n  wordModule,\n  setStepsForPanel,\n  generatorsTemplate,\n  runnableSteps,\n  addToTemplatePool,\n  postMessage,\n  addToFilledGeneratorPool,\n  isMainEditor,\n  handleSaveAllFiles,\n}: {\n  definition: WordDefinition;\n  templateModule: any;\n  generatorModule: any;\n  wordModule: any;\n  setStepsForPanel: any;\n  generatorsTemplate: Template;\n  runnableSteps: Template;\n  addToTemplatePool: (name: string, template: string, args: string[]) => void;\n  postMessage: any;\n  addToFilledGeneratorPool: (filledGenerator: Template) => void;\n  isMainEditor: boolean;\n  handleSaveAllFiles: (template: Template) => void;\n}) => {\n  const {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n    handleInsertValueAtKey,\n  } = useTemplate(\n    definition,\n    templateModule,\n    generatorModule,\n    wordModule,\n    postMessage,\n    isMainEditor\n  );\n  const [insertMode, setInsertMode] = React.useState(false);\n  const [insertToKey, setInsertToKey] = React.useState(\"\");\n\n  useEffect(() => {\n    setStepsForPanel((prev) => ({ ...prev, [definition.name]: wordSteps }));\n  }, [wordSteps]);\n\n  const [filteredTemplates, setFilteredTemplates] = useState([]);\n  function handleOpenFilter(key: string) {\n    const newFilteredTemplates = [\n      ...filteredTemplates,\n      filterTemplateToKey(template, key),\n    ];\n    setFilteredTemplates(newFilteredTemplates);\n  }\n  function handleRemoveKey(key: string) {\n    removeKey(key);\n  }\n  function handleClosePanel(idx: number) {\n    const newFilteredTemplates = [...filteredTemplates];\n    newFilteredTemplates.splice(idx, 1);\n    setFilteredTemplates(newFilteredTemplates);\n  }\n  function handleRunStep(stepString: string) {\n    applyGeneratorString(stepString);\n  }\n  function handleTemplateClick(templateName: string) {\n    const newTemplate = templateModule[templateName];\n    if (!insertMode) {\n      insertTemplateIntoTemplate(newTemplate);\n    } else if (insertMode) {\n      insertTemplateIntoTemplateAtKey(newTemplate, insertToKey);\n    }\n  }\n  function handleGeneratorClick(generatorName: string) {\n    // create the insertion template based off name, finding it in generators string, etc\n    const genTempl = genTemplateWithVars(\n      {\n        step: () => \\`${generatorName}(template, genArgs)\\`,\n      },\n      [\"genArgs\"]\n    );\n    if (!insertMode) {\n      insertTemplateIntoTemplate(genTempl);\n    } else if (insertMode) {\n      insertTemplateIntoTemplateAtKey(genTempl, insertToKey);\n    }\n  }\n  function handleAddDefinition(key: string, value: string) {\n    const funcPart = argsAndTemplateToFunction([], value);\n    const newTemplate = { [key]: funcPart };\n    if (insertMode) {\n      insertTemplateIntoTemplateAtKey(newTemplate, insertToKey);\n    } else {\n      insertTemplateIntoTemplate(newTemplate);\n    }\n  }\n\n  function handleAddSkeleton(key: string, value: string, args: string[]) {\n    const funcPart = argsAndTemplateToFunction([], value);\n    const templ = { [key]: funcPart };\n    const newTemplate = genTemplateWithVars(templ, args);\n    addToTemplatePool(key, value, args);\n    insertTemplateIntoTemplate(newTemplate);\n  }\n\n  function handleInsertTemplateName(value: string) {\n    const funcPart = argsAndTemplateToFunction([], value);\n    insertTemplateIntoTemplateAtKey({ templateName: funcPart }, insertToKey);\n  }\n  const templates = [template, ...filteredTemplates];\n  return (\n    <>\n      {templates.map((template, i) => {\n        return (\n          <>\n            <SkeletonPanel\n              handleTemplateClick={handleTemplateClick}\n              templateModule={templateModule}\n              generatorModule={generatorModule}\n              handleGeneratorClick={handleGeneratorClick}\n              handleAddDefinition={handleAddDefinition}\n              handleAddSkeleton={handleAddSkeleton}\n              generatorsTemplate={generatorsTemplate}\n              runnableSteps={runnableSteps}\n              handleRunStep={handleRunStep}\n              handleTemplateNameClick={handleInsertTemplateName}\n            />\n            <Panel\n              defaultSize={30}\n              minSize={20}\n              style={{ overflowX: \"scroll\" }}\n            >\n              <h3 style={{ color: \"black\" }}>{definition.name}</h3>\n              {i > 0 && (\n                <button onClick={() => handleClosePanel(i - 1)}>Close</button>\n              )}\n              <TemplateTree\n                template={template}\n                addKeyToNumerator={addKeyToNumerator}\n                addKey={addKey}\n                handleOpenFilter={handleOpenFilter}\n                insertMode={insertMode}\n                setInsertMode={setInsertMode}\n                insertToKey={insertToKey}\n                setInsertToKey={setInsertToKey}\n                handleRemoveKey={handleRemoveKey}\n                handleSaveAllFiles={handleSaveAllFiles}\n              />\n              <button\n                onClick={() =>\n                  addToFilledGeneratorPool(\n                    multiply(sortTemplateByDeps(template), {})\n                  )\n                }\n              >\n                SAVE step1\n              </button>\n            </Panel>\n            <PanelResizeHandle\n              style={{ border: \"1px solid black\", marginRight: \"6px\" }}\n            />\n          </>\n        );\n      })}\n    </>\n  );\n};\nexport const SkeletonPanel = ({\n  templateModule,\n  generatorModule,\n  handleTemplateClick,\n  handleAddDefinition,\n  handleAddSkeleton,\n  handleGeneratorClick,\n  generatorsTemplate,\n  runnableSteps,\n  handleRunStep,\n  handleTemplateNameClick,\n}: {\n  templateModule: any;\n  generatorModule: any;\n  handleTemplateClick: (templateName: string) => void;\n  handleAddDefinition: (key: string, value: string) => void;\n  handleAddSkeleton: (key: string, value: string, args: string[]) => void;\n  handleGeneratorClick: (generatorName: string) => void;\n  generatorsTemplate: Template;\n  runnableSteps: Template;\n  handleRunStep: any;\n  handleTemplateNameClick: (key: string) => void;\n}) => {\n  if (templateModule == null) return <div>loading templates...</div>;\n  const [defKeyName, setDefKeyName] = useState(\"\");\n  const [defValue, setDefValue] = useState(\"\");\n  const [lastClickedGenerator, setLastClickedGenerator] = useState(\"\");\n  console.log(\"WHAT IS TEMPLATE MODULE HERE\", templateModule);\n  console.log(\"is it null?\", generatorModule);\n  return (\n    <Panel defaultSize={20} minSize={20} style={{ overflowX: \"scroll\" }}>\n      <div>\n        <input\n          value={defKeyName}\n          onChange={(e) => setDefKeyName(e.target.value)}\n          placeholder=\"key\"\n        />\n        <input\n          value={defValue}\n          onChange={(e) => setDefValue(e.target.value)}\n          placeholder=\"value\"\n        />\n        <button\n          onClick={() => {\n            handleAddDefinition(defKeyName, defValue);\n            setDefKeyName(\"\");\n            setDefValue(\"\");\n          }}\n        >\n          Add Definition\n        </button>\n      </div>\n\n      {Object.keys(runnableSteps)?.map((rs) => {\n        //console.log(\"HERE WE ARE WITH RUNNABLE STEPS\", rs.toString(), rs);\n        const full = runnableSteps[rs]();\n        return (\n          <div\n            style={{\n              cursor: \"pointer\",\n              color: \"blue\",\n              textDecoration: \"underline\",\n            }}\n            onClick={() => handleRunStep(full)}\n          >\n            {full}\n          </div>\n        );\n      })}\n      <div style={{ color: \"black\" }}>Common:</div>\n      {COMMON_CHARS.map((k) => {\n        return (\n          <div\n            style={{\n              cursor: \"pointer\",\n              color: \"blue\",\n              textDecoration: \"underline\",\n            }}\n            onClick={() => {\n              handleAddDefinition(k.name, k.value);\n            }}\n          >\n            {k.name}\n          </div>\n        );\n      })}\n\n      <div style={{ color: \"black\" }}>Templates:</div>\n      {Object.keys(templateModule)?.map((k) => {\n        return (\n          <div>\n            <span\n              style={{\n                cursor: \"pointer\",\n                color: \"blue\",\n                textDecoration: \"underline\",\n              }}\n              onClick={() => handleTemplateClick(k)}\n            >\n              {k}\n            </span>\n            <span\n              onClick={() => handleTemplateNameClick(k)}\n              style={{\n                width: \"8px\",\n                height: \"8px\",\n                padding: \"0px\",\n                border: \"1px solid black\",\n                backgroundColor: \"#eee\",\n                color: \"black\",\n                cursor: \"pointer\",\n              }}\n            >\n              N\n            </span>\n          </div>\n        );\n      })}\n      <div style={{ color: \"black\" }}>Generators</div>\n      {lastClickedGenerator != null && (\n        <div style={{ color: \"red\", textDecoration: \"none\" }}>\n          {getGeneratorSignatureFromKey(\n            lastClickedGenerator,\n            generatorsTemplate\n          )}\n        </div>\n      )}\n      {FAVORITE_GENERATORS.map((k) => {\n        return (\n          <div\n            style={{\n              cursor: \"pointer\",\n              color: \"blue\",\n              textDecoration: \"underline\",\n            }}\n            onClick={() => {\n              handleGeneratorClick(k);\n              setLastClickedGenerator(k);\n            }}\n          >\n            {k}\n          </div>\n        );\n      })}\n\n      {Object.keys(generatorModule)\n        ?.sort()\n        ?.map((k) => {\n          return (\n            <div\n              style={{\n                cursor: \"pointer\",\n                color: \"blue\",\n                textDecoration: \"underline\",\n              }}\n              onClick={() => {\n                handleGeneratorClick(k);\n                setLastClickedGenerator(k);\n              }}\n            >\n              {k}{\" \"}\n            </div>\n          );\n        })}\n    </Panel>\n  );\n};\n// EXPECTS A SORTED input TEMPLATE\nexport const TemplateTree = ({\n  template,\n  addKeyToNumerator,\n  addKey,\n  handleOpenFilter,\n  handleRemoveKey,\n  insertMode,\n  setInsertMode,\n  insertToKey,\n  setInsertToKey,\n  handleSaveAllFiles,\n}: {\n  addKey: any;\n  addKeyToNumerator: any;\n  template: Template;\n  handleOpenFilter: any;\n  handleRemoveKey: any;\n  insertMode: boolean;\n  setInsertMode: any;\n  insertToKey: string;\n  setInsertToKey: any;\n  handleSaveAllFiles: (template: Template) => void;\n}) => {\n  const [compiledTemplate, setCompiledTemplate] = React.useState(\"\");\n  const [collapsedSet, setCollapsedSet] = React.useState(new Set<string>());\n  const [hiddenSet, setHiddenSet] = React.useState(new Set<string>());\n  const indentHash = new Map<string, number>();\n\n  function handleRsClick(arg: string) {\n    addKey(arg);\n  }\n  const handleNumeratorClick = (numerator: string) => {\n    if (insertMode) {\n      if (numerator !== insertToKey) {\n        addKeyToNumerator(numerator, insertToKey);\n      } else {\n        setInsertMode(false);\n        setInsertToKey(\"\");\n      }\n    } else {\n      setInsertMode(true);\n      setInsertToKey(numerator);\n    }\n  };\n  //console.log(\"TEMPLATE\", template);\n  const handleCompile = () => {\n    setCompiledTemplate(tts(template));\n  };\n\n  const handleCollapse = (key: string) => {\n    const allChildren = getDescendentsOfKey(key, template, false);\n    const newCollapsedSet = new Set(collapsedSet);\n    const newHiddenSet = new Set(hiddenSet);\n    if (collapsedSet.has(key)) {\n      newCollapsedSet.delete(key);\n      allChildren.forEach((child) => {\n        newHiddenSet.delete(child);\n      });\n    } else {\n      newCollapsedSet.add(key);\n      allChildren.forEach((child) => {\n        newHiddenSet.add(child);\n      });\n    }\n\n    setHiddenSet(newHiddenSet);\n    setCollapsedSet(newCollapsedSet);\n  };\n  return (\n    <div>\n      <button onClick={() => handleSaveAllFiles(template)}>\n        Save All Files\n      </button>\n      {Object.keys(template).map((k, i) => {\n        const denoms = k.split(\"/\")[1]?.split(\",\");\n\n        const numerator = k.split(\"/\")[0];\n        const indentionMultiplier = indentHash.get(numerator) ?? 0;\n        denoms?.forEach((d) => {\n          indentHash.set(d, indentionMultiplier + 1);\n        });\n\n        const peekTreeNodes = denoms?.map((d) => {\n          if (template[d] != null) {\n            // we have a non-denom key, need to display and extra TreeNode while giving it the proper indentation\n            return (\n              <TreeNode\n                tKey={d}\n                indentionMultiplier={indentionMultiplier + 1}\n                insertMode={insertMode}\n                insertToKey={insertToKey}\n                hiddenSet={hiddenSet}\n                handleCollapse={handleCollapse}\n                handleNumeratorClick={handleNumeratorClick}\n                collapsedSet={collapsedSet}\n                template={template}\n                handleRsClick={handleRsClick}\n                denoms={denoms}\n                handleOpenFilter={handleOpenFilter}\n                handleRemoveKey={handleRemoveKey}\n              />\n            );\n          } else {\n            return null;\n          }\n        });\n\n        return (\n          <>\n            <TreeNode\n              tKey={k}\n              indentionMultiplier={indentionMultiplier}\n              insertMode={insertMode}\n              insertToKey={insertToKey}\n              hiddenSet={hiddenSet}\n              handleCollapse={handleCollapse}\n              handleNumeratorClick={handleNumeratorClick}\n              collapsedSet={collapsedSet}\n              template={template}\n              handleRsClick={handleRsClick}\n              denoms={denoms}\n              handleOpenFilter={handleOpenFilter}\n              handleRemoveKey={handleRemoveKey}\n            />\n            {peekTreeNodes?.map((node) => node)}\n          </>\n        );\n      })}\n\n      <button onClick={handleCompile}>Compile</button>\n      {compiledTemplate !== \"\" && (\n        <pre style={{ color: \"black\", fontSize: \"12px\" }}>\n          {compiledTemplate}\n        </pre>\n      )}\n    </div>\n  );\n};\n\nconst TreeNode = ({\n  tKey,\n  insertMode,\n  hiddenSet,\n  handleCollapse,\n  insertToKey,\n  handleNumeratorClick,\n  collapsedSet,\n  template,\n  handleRsClick,\n  denoms,\n  indentionMultiplier,\n  handleOpenFilter,\n  handleRemoveKey,\n}) => {\n  const numerator = tKey.split(\"/\")[0];\n\n  const clickableNumeratorColor = insertMode ? \"blue\" : \"green\";\n  return (\n    <div\n      style={{\n        marginLeft: \\`${denoms != null ? indentionMultiplier * 15 : 0}px\\`,\n        display: hiddenSet.has(tKey) ? \"none\" : \"block\",\n      }}\n    >\n      <button onClick={() => handleCollapse(tKey)}>C</button>\n      <span\n        style={{\n          color: insertToKey === numerator ? \"black\" : clickableNumeratorColor,\n          textDecoration: insertToKey === numerator ? \"\" : \"underline\",\n          cursor: \"pointer\",\n        }}\n        onClick={() => handleNumeratorClick(numerator)}\n      >\n        {numerator}\n      </span>\n      <button onClick={() => handleOpenFilter(tKey)}>I</button>\n      <button\n        style={{ marginLeft: \"14px\" }}\n        onClick={() => handleRemoveKey(tKey)}\n      >\n        R\n      </button>\n\n      {collapsedSet.has(tKey) ? (\n        <span\n          onClick={() => handleCollapse(tKey)}\n          style={{\n            cursor: \"pointer\",\n            color: \"blue\",\n            textDecoration: \"underline\",\n            marginLeft: \"3px\",\n          }}\n        >\n          . . .\n        </span>\n      ) : (\n        renderPart(template[tKey].toString(), handleRsClick)\n      )}\n    </div>\n  );\n};\n\nfunction nakedPartToString(part: string) {\n  if (part.includes(\"\\`\")) {\n    return part.substring(part.indexOf(\"\\`\") + 1, part.lastIndexOf(\"\\`\"));\n  } else {\n    return part.substring(part.indexOf('\"') + 1, part.lastIndexOf('\"'));\n  }\n}\n\nfunction rsToArg(rs: string) {\n  //    return \\`\\${run(${v},'${v}')}\\`;\n  return rs.substring(rs.indexOf(\"(\") + 1, rs.indexOf(\",\"));\n}\nfunction renderPart(part: string, handleRsClick: (arg: string) => void) {\n  const args = part\n    .substring(part.indexOf(\"{\") + 1, part.indexOf(\"}\"))\n    .split(\",\")\n    .map((arg) => arg.trim());\n  const compactRs = args.map((arg) => rsCompact(arg));\n  const nonCompactRs = args.map((arg) => rs(arg));\n\n  let funcPart = part.substring(part.indexOf(\"\\`\") + 1, part.lastIndexOf(\"\\`\"));\n  const parts = funcPart.split(/(\\${[^}]+})/g);\n  if (parts.length === 1) {\n    return (\n      <div style={{ color: \"red\", padding: \"0px 5px\" }}>\n        {nakedPartToString(part)}\n      </div>\n    );\n  }\n  let finalParts = [];\n  parts.forEach((part, index) => {\n    if (compactRs.includes(part) || nonCompactRs.includes(part)) {\n      const arg = rsToArg(part);\n      finalParts.push(\n        <span\n          style={{\n            color: \"purple\",\n            cursor: \"pointer\",\n            margin: \"0px 2px\",\n            border: \"1px solid black\",\n            backgroundColor: \"#eee\",\n            padding: \"0px 2px\",\n          }}\n          onClick={() => handleRsClick(arg)}\n        >\n          {arg}\n        </span>\n      );\n    } else {\n      finalParts.push(part);\n    }\n  });\n  return <div style={{ color: \"red\", padding: \"0px 5px\" }}>{finalParts}</div>;\n}\n`\n}","files":{}}]