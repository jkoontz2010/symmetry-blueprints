[{"result":"{\n\n}"},{"name":"insertIntoTemplate","args":[{},{}],"full":"insertIntoTemplate([object Object],[object Object])","result":"{\n'excludePath1': () => \"pools\",\n'excludePath2': () => \"hardToParse\",\n'filePath1': () => \"src\"\n}","files":{}},{"name":"performOnLinkedBySections","args":["template"," [   { from: \"commandSend\""," to: \"panelCommand\""," by: \"commandName\" }","   {     from: \"panelCommand\"","     to: \"hookCmdHandleSection\"","     by: \"webviewCommandName\"","   }"," ]"," buildQueue"],"full":"performOnLinkedBySections(template, [   { from: \"commandSend\", to: \"panelCommand\", by: \"commandName\" },   {     from: \"panelCommand\",     to: \"hookCmdHandleSection\",     by: \"webviewCommandName\",   }, ], buildQueue)","result":"{\n'hookCmdHandleSection04/hookHandlerName02,hookHandlerBody02': ({hookHandlerName02, hookHandlerBody02})=>`case \"${run(hookHandlerName02, \"hookHandlerName02\")}\":${run(hookHandlerBody02, \"hookHandlerBody02\")}break;`,\n'commandSend10/commandBody02': ({commandBody02})=>` postMessage({${run(commandBody02, \"commandBody02\")}});`,\n'panelCommand018/panelCommandName011,panelCommandBody011': ({panelCommandName011, panelCommandBody011})=>`case \"${run(panelCommandName011, \"panelCommandName011\")}\":${run(panelCommandBody011, \"panelCommandBody011\")}break;`,\n'commandBody02/nameProperty12': ({ nameProperty12 }) => `\n      ${run(nameProperty12, \"nameProperty12\")}\n      generatorString,\n      template: tts(template,false),\n      msgId,\n    `,\n'nameProperty12/commandName12': ({ commandName12 }) => `command: \"${run(commandName12, \"commandName12\")}\",`,\n'panelCommandBody011/webviewPostMessageName17': ({ webviewPostMessageName17 }) => ` {\n            const pathToConfig = this.runner.currentStep.config;\n            const { generatorString, template, msgId } = msg;\n            console.log(\n              \"RUNNING\",\n              \"msgId\",\n              msgId,\n              \"AND\",\n\n              generatorString,\n              pathToConfig\n            );\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filePrefix = Date.now();\n            const generatorRunFile = await createRunnableGeneratorFileContents(\n              pathToConfig,\n              generatorString,\n              template\n            );\n            const generatorFile = filePrefix + \"_generator.ts\";\n            const resultFile = filePrefix + \"_result\";\n            const genFilePath = projectDir + \"/\" + generatorFile;\n            const resultFilePath = projectDir + \"/\" + resultFile;\n            await saveFile(genFilePath, generatorRunFile);\n            const result = await runTs(genFilePath);\n            console.log(\"RESULTv,\", result);\n            await saveFile(resultFilePath, result);\n\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName17, \"webviewPostMessageName17\")}\n              data: {\n                msgId,\n                generatorFilePath: genFilePath,\n                resultFilePath: resultFilePath,\n                result,\n                generatorString,\n              },\n            });\n            `,\n'webviewPostMessageName17/webviewCommandName17': ({ webviewCommandName17 }) => `command: \"${run(webviewCommandName17, \"webviewCommandName17\")}\",`,\n'panel.ts3f5913a659/fileContents1': ({ fileContents1 }) => `${run(fileContents1, \"fileContents1\")}`,\n'fileContents1/webviewCommandHandler01': ({ webviewCommandHandler01 }) => `\nimport * as vscode from \"vscode\";\nimport { getNonce } from \"./getNonce\";\nimport * as fs from \"fs\";\nimport { readFile, runTs, saveFile, saveWord } from \"./compiler\";\nimport {\n  argsAndTemplateToFunction,\n  insertIntoTemplate,\n  tts,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport {\n  getAllWordPathsByLastModified,\n  getWordContents,\n  getWordNamesFromWordPaths,\n  sortFilesByLastModified,\n  readFromConfig,\n  getWordPath,\n  storeFileHash,\n  getFilePathHashes,\n  overwriteFile,\n  getAllFileTemplates,\n  saveRunnableWord,\n  getAllRunnableWords,\n  createRunnableGeneratorFileContents,\n} from \"./services/commandService\";\nimport { sha1 } from \"js-sha1\";\nimport { runWord } from \"./services/wordRunService\";\nimport Runner, { DequeueConfig } from \"./runner/runner\";\nimport { fetchFromConfig } from \"./services/configService\";\n\nexport function formFilePathHash(filePath: string) {\n  const fileName = filePath.split(\"/\").pop();\n  const fileHash = sha1(filePath);\n  return \\u30A7\\xA7{fileHash.substring(0, 10)}_\\xA7{fileName}\\u30A7;\n}\n\nexport function readFromFile(file) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(file, \"utf8\", function (err, data) {\n      if (err) {\n        console.log(err);\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nconst TEST_DEQUEUE: DequeueConfig = {\n  name: \"test\",\n  description: \"runs fs, grabs the useTemplate file, and takes off parsing it!\",\n  steps: [\n    {\n      type: \"fs\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.fsconfig\",\n      name: \"testGrab\",\n      description: \"test fs!!\",\n      waitForTransitionCommand: false,\n      transitionAction: \"get\",\n      runWithEmptyTemplate: false,\n      word: \"getUseTemplate\",\n    },\n    {\n      type: \"template\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig\",\n      name: \"blank\",\n      description:\n        \"starts with blank template. fill with fifth.tsx to ready for next step!\",\n      waitForTransitionCommand: false,\n      transitionAction: \"identity\",\n      runWithEmptyTemplate: false,\n    },\n    {\n      type: \"template\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig\",\n      name: \"parseFifth\",\n      description: \"runs the word that parses fifth.tsx\",\n      word: \"ponTesterQueue\",\n      waitForTransitionCommand: true,\n      transitionAction: \"identity\", // nothing\n      runWithEmptyTemplate: false,\n    },\n  ],\n};\nconst BLANK_TEMPL_DEQUEUE: DequeueConfig = {\n  name: \"blank template\",\n  description: \"starts out with an empty word\",\n  steps: [\n    {\n      type: \"template\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig\",\n      name: \"blankTempl\",\n      description:\n        \"starts with blank template. fill with fifth.tsx to ready for next step!\",\n      waitForTransitionCommand: true,\n      transitionAction: \"identity\",\n      runWithEmptyTemplate: false,\n    },\n  ],\n};\nconst POL_DEUQUE: DequeueConfig = {\n  name: \"polTest\",\n  description: \"grabs anything postMessage-related and queues the links\",\n  steps: [\n    {\n      type: \"fs\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.fsconfig\",\n      name: \"polFs\",\n      description:\n      \"grabs anything postMessage-related\",\n      waitForTransitionCommand: true,\n      transitionAction: \"get\",\n      runWithEmptyTemplate: false,\n    },{\n      type: \"template\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig\",\n      name: \"blankTempl\",\n      description:\n        \"starts with blank template. fill with files found from polTest step!\",\n      waitForTransitionCommand: true,\n      word: \"fromParserTest\",\n      transitionAction: \"identity\",\n      runWithEmptyTemplate: false,\n    },\n  ]\n}\nconst BLANK_FS_DEQUEUE: DequeueConfig = {\n  name: \"blank fs\",\n  description: \"starts out with an empty word\",\n  steps: [\n    {\n      type: \"fs\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.fsconfig\",\n      name: \"blankFs\",\n      description:\n        \"starts with blank template. fill with fifth.tsx to ready for next step!\",\n      waitForTransitionCommand: true,\n      transitionAction: \"identity\",\n      runWithEmptyTemplate: false,\n    },\n  ],\n};\nconst ALL_SERVICES_DEQUEUE: DequeueConfig = {\n  name: \"show all service files\",\n  description: \"testing out how a multi-grab works\",\n  steps: [\n    {\n      type: \"fs\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.fsconfig\",\n      name: \"blankFs\",\n      description:\n        \"starts with blank template. fill with fifth.tsx to ready for next step!\",\n      waitForTransitionCommand: false,\n      transitionAction: \"get\",\n      runWithEmptyTemplate: false,\n      word: \"getServices\",\n    },\n    {\n      type: \"template\",\n      config:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig\",\n      name: \"allServicesTempl\",\n      description: \"all the service files!\",\n      waitForTransitionCommand: true,\n      transitionAction: \"identity\",\n      runWithEmptyTemplate: false,\n    },\n  ],\n};\nconst ALL_QUEUES = [\n  TEST_DEQUEUE,\n  BLANK_FS_DEQUEUE,\n  BLANK_TEMPL_DEQUEUE,\n  ALL_SERVICES_DEQUEUE,\n  POL_DEUQUE\n];\n\nexport default class PanelClass {\n  public static currentPanel: PanelClass | undefined;\n\n  private static readonly viewType = \"PanelName\";\n\n  private readonly _panel: vscode.WebviewPanel;\n  private readonly _extensionUri: vscode.Uri;\n  private readonly _extContext: vscode.ExtensionContext;\n  private _disposables: vscode.Disposable[] = [];\n  private pathToConfig: string;\n  private runner: Runner;\n\n  public static createOrShow(extContext: vscode.ExtensionContext) {\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    // If we already have a panel, show it.\n    // Otherwise, create a new panel.\n    if (PanelClass.currentPanel) {\n      PanelClass.currentPanel._panel.reveal(column);\n    } else {\n      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);\n      PanelClass.currentPanel = new PanelClass(\n        extContext,\n        vscode.ViewColumn.Two\n      );\n    }\n  }\n\n  public static async insertFileIntoTemplate(\n    extContext: vscode.ExtensionContext\n  ) {\n    console.log(\"this is both broken and not going to be used anymore\");\n    const activeTextEditor = vscode.window.activeTextEditor;\n    if (activeTextEditor == null) {\n      return;\n    }\n    const activeEditorText = activeTextEditor.document.getText();\n    const activeEditorFilePath = activeTextEditor.document.fileName;\n    // we want to deterministically hash the filepath\n\n    const filePathHash = formFilePathHash(activeEditorFilePath);\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    // If we already have a panel, show it.\n    // Otherwise, create a new panel.\n    if (PanelClass.currentPanel) {\n      PanelClass.currentPanel._panel.reveal(column);\n    } else {\n      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);\n      PanelClass.currentPanel = new PanelClass(\n        extContext,\n        vscode.ViewColumn.Two\n      );\n    }\n\n    // we also need to store this hash somewhere!\n    console.log(\"DO WE HAVE PATH \", PanelClass.currentPanel.pathToConfig);\n    storeFileHash(\n      PanelClass.currentPanel.pathToConfig,\n      filePathHash,\n      activeEditorFilePath\n    );\n\n    /*PanelClass.currentPanel._panel.webview.postMessage({\n      command: \"file_insert\",\n      data: {\n        contents: activeEditorText,\n        filePath: filePathHash,\n      },\n    });*/\n    const fileTemplates = await getAllFileTemplates(\n      PanelClass.currentPanel.pathToConfig\n    );\n    PanelClass.currentPanel._panel.webview.postMessage({\n      command: \"all_file_templates\",\n      data: {\n        fileTemplates: tts(fileTemplates, false),\n      },\n    });\n  }\n  //temporarily setting extcontext to any type\n  private constructor(\n    _extContext: vscode.ExtensionContext,\n    column: vscode.ViewColumn\n  ) {\n    this._extContext = _extContext;\n    this._extensionUri = _extContext.extensionUri;\n\n    // Create and show a new webview panel\n    function handleQueueUpdate() {\n      \n      const currentQueue = this.runner.steps?.map((step) => ({\n        type: step.type,\n        name: step.name,\n        description: step.description,\n        word: step.word ?? \"-\",\n        isWaitingForCommand: step.waitForTransitionCommand,\n        transitionAction: step.transitionAction,\n      }))??[];\n      console.log(\"queue update\", currentQueue);\n      this._panel!.webview.postMessage({\n        command: \"queue_update\",\n        data: {\n          currentQueue: JSON.stringify(currentQueue),\n        },\n      });\n    }\n    this._panel = vscode.window.createWebviewPanel(\n      PanelClass.viewType,\n      \"Blueprints\",\n      column,\n      {\n        // Enable javascript in the webview\n        enableScripts: true,\n        localResourceRoots: [this._extensionUri],\n      }\n    );\n\n    // Set the webview's initial html content\n    this._panel.webview.html = this._getHtmlForWebview(this._panel.webview);\n\n    // Listen for when the panel is disposed\n    // This happens when the user closes the panel or when the panel is closed programatically\n    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n\n    //Listen to messages\n    this._panel.${run(webviewCommandHandler01, \"webviewCommandHandler01\")}\n    );\n  }\n\n  public dispose() {\n    PanelClass.currentPanel = undefined;\n    this._panel.dispose();\n    while (this._disposables.length) {\n      const x = this._disposables.pop();\n      if (x) {\n        x.dispose();\n      }\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"out\", \"main.wv.js\")\n    );\n\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"media\", \"styles.css\")\n    );\n\n    const nonce = getNonce();\n\n    return \\u30A7<!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Symmetric Blueprints</title>\n        <link rel=\"stylesheet\" href=\"\\xA7{styleUri}\">\n      </head>\n      <body>\n        <div id=\"root\"></div>\n        <script>\n          global = window\n          \n          const vscode = acquireVsCodeApi();\n          window.onload = function() {\n            vscode.postMessage({ command: 'startup' });\n            console.log('HTML started up.');\n          };\n        </script>\n        <script nonce=\"\\xA7{nonce}\" src=\"\\xA7{scriptUri}\"></script>\n      </body>\n      </html>\n    \\u30A7;\n  }\n}\n`,\n'webviewCommandHandler01/webviewHandler01': ({ webviewHandler01 }) => `webview.onDidReceiveMessage(${run(webviewHandler01, \"webviewHandler01\")}this._disposables`,\n'webviewHandler01/panelCommand01,panelCommand02,panelCommand03,panelCommand04,panelCommand05,panelCommand06,panelCommand07,panelCommand08,panelCommand09,panelCommand010,panelCommand011,panelCommand012,panelCommand013,panelCommand014,panelCommand015,panelCommand016,panelCommand017': ({ panelCommand01, panelCommand02, panelCommand03, panelCommand04, panelCommand05, panelCommand06, panelCommand07, panelCommand08, panelCommand09, panelCommand010, panelCommand011, panelCommand012, panelCommand013, panelCommand014, panelCommand015, panelCommand016, panelCommand017 }) => `\n      async (msg: any) => {\n;\n        switch (msg.command) {\n          ${run(panelCommand01, \"panelCommand01\")}\n          }\n          ${run(panelCommand02, \"panelCommand02\")}\n          ${run(panelCommand03, \"panelCommand03\")}\n          ${run(panelCommand04, \"panelCommand04\")}\n          ${run(panelCommand05, \"panelCommand05\")}\n          }\n          ${run(panelCommand06, \"panelCommand06\")}\n          }\n          ${run(panelCommand07, \"panelCommand07\")}\n          }\n          ${run(panelCommand08, \"panelCommand08\")}\n          }\n          ${run(panelCommand09, \"panelCommand09\")}\n          }\n          ${run(panelCommand010, \"panelCommand010\")}\n          }\n          ${run(panelCommand011, \"panelCommand011\")}\n          }\n          ${run(panelCommand012, \"panelCommand012\")}\n          }\n          ${run(panelCommand013, \"panelCommand013\")}\n          }\n          ${run(panelCommand014, \"panelCommand014\")}\n          }\n          ${run(panelCommand015, \"panelCommand015\")}\n          }\n          ${run(panelCommand016, \"panelCommand016\")}\n          }\n          ${run(panelCommand017, \"panelCommand017\")}\n        }\n      },\n      null,\n      `,\n'panelCommand017/panelCommandName017,panelCommandBody017': ({ panelCommandName017, panelCommandBody017 }) => `case \"${run(panelCommandName017, \"panelCommandName017\")}\":${run(panelCommandBody017, \"panelCommandBody017\")}break;`,\n'panelCommandBody017/webviewPostMessageName11': ({ webviewPostMessageName11 }) => `\n            try {\n              const {queueName} = msg;\n              if(queueName == null) {\n                throw new Error(\"Queue name is null\");\n              }\n              const queue = ALL_QUEUES.find((q) => q.name === queueName);\n              this.runner = new Runner(queue.steps);\n              await this.runner.initNextStep();\n              this.runner.unsubscribe(\"queueUpdate\");\n              this.runner.subscribe(\"queueUpdate\", handleQueueUpdate.bind(this));\n              handleQueueUpdate.call(this);\n              // data will equal:\n              // GENERATOR_FILE=src/generators/wordBuilder.ts\n              // TEMPLATE_FILE=src/templates/wordBuilder.ts\n              // WORDS_FILE=src/words/wordBuilder.ts\n              // we want to parse each file path and send it back to the webview\n              const data = await fetchFromConfig(\n                this.runner.currentStep.config,\n                this.runner\n              );\n              this._panel!.webview.postMessage({\n                ${run(webviewPostMessageName11, \"webviewPostMessageName11\")}\n                data: {\n                  ...data,\n                  queueNames: JSON.stringify(ALL_QUEUES.map((q) => q.name)),\n                },\n              });\n\n              //this._panel!.webview.postMessage({ command: 'config_data', data });\n            } catch (e) {\n              console.error(e);\n            }\n            `,\n'webviewPostMessageName11/webviewCommandName11': ({ webviewCommandName11 }) => `command: \"${run(webviewCommandName11, \"webviewCommandName11\")}\",`,\n'panelCommand016/panelCommandName016,panelCommandBody016': ({ panelCommandName016, panelCommandBody016 }) => `case \"${run(panelCommandName016, \"panelCommandName016\")}\":${run(panelCommandBody016, \"panelCommandBody016\")}break;`,\n'panelCommandBody016/webviewPostMessageName12': ({ webviewPostMessageName12 }) => ` {\n            if (!ALL_QUEUES.some((q) => q.name === msg.queueName)) {\n              console.log(\n                \"queue name vs ALL_QUEUES\",\n                msg.queueName,\n                ALL_QUEUES\n              );\n              throw new Error(\"Queue not found, how did this happen?\");\n            }\n            this.runner = new Runner(\n              ALL_QUEUES.find((q) => q.name === msg.queueName).steps\n            );\n            this.runner.initNextStep();\n            const pathToConfig = this.runner.currentStep.config;\n            const data = await fetchFromConfig(pathToConfig, this.runner);\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName12, \"webviewPostMessageName12\")}\n              data: {\n                ...data,\n                queueNames: JSON.stringify(ALL_QUEUES.map((q) => q.name)),\n              },\n            });\n            `,\n'webviewPostMessageName12/webviewCommandName12': ({ webviewCommandName12 }) => `command: \"${run(webviewCommandName12, \"webviewCommandName12\")}\",`,\n'panelCommand015/panelCommandName015,panelCommandBody015': ({ panelCommandName015, panelCommandBody015 }) => `case \"${run(panelCommandName015, \"panelCommandName015\")}\":${run(panelCommandBody015, \"panelCommandBody015\")}break;`,\n'panelCommandBody015/webviewPostMessageName13': ({ webviewPostMessageName13 }) => ` {\n            const { template } = msg;\n            await this.runner.transition(template);\n            const pathToConfig = this.runner.currentStep.config;\n            console.time(\"fetchFromConfig\");\n            const data = await fetchFromConfig(pathToConfig, this.runner);\n            console.timeEnd(\"fetchFromConfig\");\n            // so on transition:\n            // get the config from the step\n            // fetch it all (make a service for it)\n            // send it to the frontend like we do on startup\n            // also send the current template as a new word result\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName13, \"webviewPostMessageName13\")}\n              data: {\n                ...data,\n                queueNames: JSON.stringify(ALL_QUEUES.map((q) => q.name)),\n                subTemplate: this.runner.currentStep.subTemplate,\n              },\n            });\n            `,\n'webviewPostMessageName13/webviewCommandName13': ({ webviewCommandName13 }) => `command: \"${run(webviewCommandName13, \"webviewCommandName13\")}\",`,\n'panelCommand014/panelCommandName014,panelCommandBody014': ({ panelCommandName014, panelCommandBody014 }) => `case \"${run(panelCommandName014, \"panelCommandName014\")}\":${run(panelCommandBody014, \"panelCommandBody014\")}break;`,\n'panelCommandBody014/webviewPostMessageName14': ({ webviewPostMessageName14 }) => ` {\n            const { wordSteps, wordName, msgId } = msg;\n            if (\n              wordSteps.length === 0 ||\n              wordSteps === \"\" ||\n              wordSteps == null\n            ) {\n              throw new Error(\"No steps to save\");\n            }\n            const pathToConfig = this.runner.currentStep.config;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const wordFile = projectDir + \"/word_\" + wordName + \".json\";\n            await saveFile(wordFile, wordSteps);\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName14, \"webviewPostMessageName14\")}\n              data: {\n                msgId,\n              },\n            });\n            `,\n'webviewPostMessageName14/webviewCommandName14': ({ webviewCommandName14 }) => `command: \"${run(webviewCommandName14, \"webviewCommandName14\")}\",`,\n'panelCommand013/panelCommandName013,panelCommandBody013': ({ panelCommandName013, panelCommandBody013 }) => `case \"${run(panelCommandName013, \"panelCommandName013\")}\":${run(panelCommandBody013, \"panelCommandBody013\")}break;`,\n'panelCommandBody013/webviewPostMessageName15': ({ webviewPostMessageName15 }) => ` {\n            const { msgId, filledGenerator } = msg;\n            const pathToConfig = this.runner.currentStep.config;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filledGeneratorsPath = projectDir + \"/filledGenerators.json\";\n\n            let currentFilledGenerators;\n            try {\n              currentFilledGenerators = await readFile(filledGeneratorsPath);\n            } catch {\n              currentFilledGenerators = \"{}\";\n            }\n            const cfgTemplate: Template = new Function(\n              \"return \" + currentFilledGenerators\n            )();\n            const filledGeneratorTemplate: Template = new Function(\n              \"return \" + filledGenerator\n            )();\n            const newFilledGenerators = insertIntoTemplate(\n              cfgTemplate,\n              filledGeneratorTemplate\n            );\n            await saveFile(\n              filledGeneratorsPath,\n              tts(newFilledGenerators, false)\n            );\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName15, \"webviewPostMessageName15\")}\n              data: {\n                msgId,\n                allFilledGenerators: tts(newFilledGenerators, false),\n              },\n            });\n            `,\n'webviewPostMessageName15/webviewCommandName15': ({ webviewCommandName15 }) => `command: \"${run(webviewCommandName15, \"webviewCommandName15\")}\",`,\n'panelCommand012/panelCommandName012,panelCommandBody012': ({ panelCommandName012, panelCommandBody012 }) => `case \"${run(panelCommandName012, \"panelCommandName012\")}\":${run(panelCommandBody012, \"panelCommandBody012\")}break;`,\n'panelCommandBody012/webviewPostMessageName16': ({ webviewPostMessageName16 }) => ` {\n            const { wordName, template, msgId } = msg;\n            const pathToConfig = this.runner.currentStep.config;\n            const {\n              template: result,\n              wordRunFilePath,\n              resultFilePath,\n              queuedTemplates,\n            } = await runWord(pathToConfig, wordName, template);\n            // ADD queuedTemplates TO RUNNER\n            this.runner.addSubTemplatesToQueue(queuedTemplates);\n            // the queued items will change in the queue header\n            // so the user will know buildQueue affected the queue\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName16, \"webviewPostMessageName16\")}\n              data: {\n                msgId,\n                wordRunFilePath: wordRunFilePath,\n                resultFilePath: resultFilePath,\n                result,\n                wordString: \\u30A7\\xA7{wordName}(template)\\u30A7,\n              },\n            });\n            `,\n'webviewPostMessageName16/webviewCommandName16': ({ webviewCommandName16 }) => `command: \"${run(webviewCommandName16, \"webviewCommandName16\")}\",`,\n'panelCommand010/panelCommandName010,panelCommandBody010': ({ panelCommandName010, panelCommandBody010 }) => `case \"${run(panelCommandName010, \"panelCommandName010\")}\":${run(panelCommandBody010, \"panelCommandBody010\")}break;`,\n'panelCommandBody010/webviewPostMessageName18': ({ webviewPostMessageName18 }) => ` {\n            const { key, args, value } = msg;\n            const funcPart = argsAndTemplateToFunction([], value);\n            const templ = { [key]: funcPart };\n            const templateString = \\u30A7genTemplateWithVars(\\xA7{tts(\n              templ,\n              false\n            )}, \\xA7{args});\\u30A7;\n            const pathToConfig = this.runner.currentStep.config;\n            const templatesFilePath = await readFromConfig(\n              \"TEMPLATE_FILE\",\n              pathToConfig\n            );\n            const templatesFile = await readFromFile(templatesFilePath);\n            console.log(\"CURR TEMPLATES FILE\", templatesFile);\n            // write template to templates file\n            const newTemplatesFile =\n              templatesFile + \"\\xD8n\" + \\u30A7export const \\xA7{key} = \\xA7{templateString}\\u30A7;\n            console.log(\"NEW TEMPLATES FILE\", newTemplatesFile);\n            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {\n              if (err) {\n                console.error(err);\n              }\n              console.log(\"success\");\n            });\n\n            // bun run the file and send the result to the frontend\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const templateModule = await runTs(\n              projectDir + \"/template-getter.ts\"\n            );\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName18, \"webviewPostMessageName18\")}\n              data: {\n                templateModule,\n              },\n            });\n\n            `,\n'webviewPostMessageName18/webviewCommandName18': ({ webviewCommandName18 }) => `command: \"${run(webviewCommandName18, \"webviewCommandName18\")}\",`,\n'panelCommand09/panelCommandName09,panelCommandBody09': ({ panelCommandName09, panelCommandBody09 }) => `case \"${run(panelCommandName09, \"panelCommandName09\")}\":${run(panelCommandBody09, \"panelCommandBody09\")}break;`,\n'panelCommandBody09/webviewPostMessageName19': ({ webviewPostMessageName19 }) => ` {\n            // a full template doesn't need to be generated\n            // it's the actual object that is a template\n            // we just need to add it to the template pool\n            const { template, name } = msg;\n            const pathToConfig = this.runner.currentStep.config;\n            const templatesFilePath = await readFromConfig(\n              \"TEMPLATE_FILE\",\n              pathToConfig\n            );\n            const templatesFile = await readFromFile(templatesFilePath);\n            console.log(\"CURR TEMPLATES FILE\", templatesFile);\n            // write template to templates file\n            const newTemplatesFile =\n              templatesFile + \"\\xD8n\" + \\u30A7export const \\xA7{name} = \\xA7{template}\\u30A7;\n            console.log(\"NEW TEMPLATES FILE\", newTemplatesFile);\n            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {\n              if (err) {\n                console.error(err);\n              }\n              console.log(\"success\");\n            });\n\n            // bun run the file and send the result to the frontend\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const templateModule = await runTs(\n              projectDir + \"/template-getter.ts\"\n            );\n            console.log(\"ALL OF TEMPLATE MODULE\", templateModule);\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName19, \"webviewPostMessageName19\")}\n              data: {\n                templateModule,\n              },\n            });\n            `,\n'webviewPostMessageName19/webviewCommandName19': ({ webviewCommandName19 }) => `command: \"${run(webviewCommandName19, \"webviewCommandName19\")}\",`,\n'panelCommand08/panelCommandName08,panelCommandBody08': ({ panelCommandName08, panelCommandBody08 }) => `case \"${run(panelCommandName08, \"panelCommandName08\")}\":${run(panelCommandBody08, \"panelCommandBody08\")}break;`,\n'panelCommandBody08/webviewPostMessageName110': ({ webviewPostMessageName110 }) => ` {\n            const { wordName, template } = msg;\n            const pathToConfig = this.runner.currentStep.config;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const wordFile = projectDir + \"/word_\" + wordName + \".json\";\n            // eventually, result might be something more, like a file insertion\n            let wordTemplate = \"{}\";\n            if (template != null) {\n              wordTemplate = template;\n            }\n            let wordContents = JSON.stringify([{ result: wordTemplate }]);\n            await saveFile(wordFile, wordContents);\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName110, \"webviewPostMessageName110\")}\n              data: {\n                wordName,\n                wordContents,\n              },\n            });\n            `,\n'webviewPostMessageName110/webviewCommandName110': ({ webviewCommandName110 }) => `command: \"${run(webviewCommandName110, \"webviewCommandName110\")}\",`,\n'panelCommand07/panelCommandName07,panelCommandBody07': ({ panelCommandName07, panelCommandBody07 }) => `case \"${run(panelCommandName07, \"panelCommandName07\")}\":${run(panelCommandBody07, \"panelCommandBody07\")}break;`,\n'panelCommandBody07/webviewPostMessageName111': ({ webviewPostMessageName111 }) => ` {\n            const { wordName } = msg;\n            const pathToConfig = this.runner.currentStep.config;\n            const wordPath = await getWordPath(pathToConfig, wordName);\n            const wordContents = await getWordContents(wordPath);\n            this._panel!.webview.postMessage({\n              ${run(webviewPostMessageName111, \"webviewPostMessageName111\")}\n              data: {\n                wordName,\n                wordContents,\n              },\n            });\n            `,\n'webviewPostMessageName111/webviewCommandName111': ({ webviewCommandName111 }) => `command: \"${run(webviewCommandName111, \"webviewCommandName111\")}\",`,\n'panelCommand06/panelCommandName06,panelCommandBody06': ({ panelCommandName06, panelCommandBody06 }) => `case \"${run(panelCommandName06, \"panelCommandName06\")}\":${run(panelCommandBody06, \"panelCommandBody06\")}break;`,\n'panelCommandBody06/webviewPostMessageName112': ({ webviewPostMessageName112 }) => ` {\n            const { word } = msg;\n            const pathToConfig = this.runner.currentStep.config;\n            console.log(\"STORING RUNNABLE WORD\", word, pathToConfig);\n            try {\n              await saveRunnableWord(pathToConfig, word);\n              const runnableWords = await getAllRunnableWords(pathToConfig);\n              this._panel!.webview.postMessage({\n                ${run(webviewPostMessageName112, \"webviewPostMessageName112\")}\n                data: {\n                  runnableWords: JSON.stringify(runnableWords),\n                },\n              });\n            } catch (e) {\n              console.error(e);\n            }\n            `,\n'webviewPostMessageName112/webviewCommandName112': ({ webviewCommandName112 }) => `command: \"${run(webviewCommandName112, \"webviewCommandName112\")}\",`,\n'panelCommand05/panelCommandName05,panelCommandBody05': ({ panelCommandName05, panelCommandBody05 }) => `case \"${run(panelCommandName05, \"panelCommandName05\")}\":${run(panelCommandBody05, \"panelCommandBody05\")}break;`,\n'panelCommand04/panelCommandName04,panelCommandBody04': ({ panelCommandName04, panelCommandBody04 }) => `case \"${run(panelCommandName04, \"panelCommandName04\")}\":${run(panelCommandBody04, \"panelCommandBody04\")}break;`,\n'panelCommand03/panelCommandName03,panelCommandBody03': ({ panelCommandName03, panelCommandBody03 }) => `case \"${run(panelCommandName03, \"panelCommandName03\")}\":${run(panelCommandBody03, \"panelCommandBody03\")}break;`,\n'panelCommand02/panelCommandName02,panelCommandBody02': ({ panelCommandName02, panelCommandBody02 }) => `case \"${run(panelCommandName02, \"panelCommandName02\")}\":${run(panelCommandBody02, \"panelCommandBody02\")}break;`,\n'panelCommand01/panelCommandName01,panelCommandBody01': ({ panelCommandName01, panelCommandBody01 }) => `case \"${run(panelCommandName01, \"panelCommandName01\")}\":${run(panelCommandBody01, \"panelCommandBody01\")}break;`,\n'useTemplate.ts60c890fb5b/fileContents2': ({ fileContents2 }) => `${run(fileContents2, \"fileContents2\")}`,\n'fileContents2/commandSend01,hookCmdHandler01,hookCmdHandler02,commandSend02': ({ commandSend01, hookCmdHandler01, hookCmdHandler02, commandSend02 }) => `\nimport { cloneDeep, compact, difference, last, uniqueId } from \"lodash\";\nimport { useEffect, useState } from \"react\";\nimport {\n  appendKeyToKey,\n  dumbCombine,\n  insertIntoTemplate,\n  sortTemplateByDeps,\n  tts,\n  argsAndTemplateToFunction,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { formGeneratorFile } from \"./hgcgUtil\";\nimport { CONFIG_PATH } from \"../components/App\";\nimport { customAlphabet } from \"nanoid\";\nimport { WordDefinition } from \"../components/TemplateTree\";\nimport { pathToFileURL } from \"url\";\n\nexport type WordStep = {\n  name?: string;\n  args?: any[];\n  result: Template;\n  full?: string;\n  files?: { generatorFilePath?: string; resultFilePath?: string };\n};\n\nexport function useTemplate(\n  definition: WordDefinition,\n  templateModule: any,\n  generatorModule: any,\n  wordModule: any,\n  postMessage: any,\n  isMainTemplate: boolean\n) {\n  const alphabet =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const nanoid = customAlphabet(alphabet, 4);\n\n  const [msgId, setMsgId] = useState(nanoid());\n  let [template, setTemplate] = useState<Template>(\n    last(definition.wordSteps).result\n  );\n\n  useEffect(() => {\n    setTemplate(last(definition.wordSteps).result);\n  },[definition])\n\n  const [wordSteps, setWordSteps] = useState<WordStep[]>(definition.wordSteps);\n  function logStep(name, args, result, files = {}) {\n    const wordStep = {\n      name: name,\n      args: args,\n      full: \\u30A7\\xA7{name}(\\xA7{args.join(\",\")})\\u30A7,\n      result: cloneDeep(result),\n      files,\n    };\n\n    const newWordSteps = [...wordSteps, wordStep];\n    setWordSteps(newWordSteps);\n    const stringifiedSteps = newWordSteps.map((ws) => {\n      return {\n        name: ws.name,\n        args: ws.args,\n        full: ws.full,\n        result:\n          typeof ws.result === \"string\" ? ws.result : tts(ws.result, false),\n        files: ws.files,\n      };\n    });\n    const wordName = definition.name;\n\n   ${run(commandSend01, \"commandSend01\")}\n  }\n\n  function removeKey(key: string) {\n    const newTemplate = cloneDeep(template);\n    delete newTemplate[key];\n    logStep(\"deleteKey\", [key], newTemplate);\n    setTemplate(newTemplate);\n  }\n  function addKey(key: string) {\n    const templateHasNumerator = Object.keys(template).some((k) => {\n      return k.split(\"/\")[0] === key;\n    });\n    if (templateHasNumerator) return;\n    let combineWith = { [key]: () => \\u30A7\\u30A7 };\n    let newTemplate = dumbCombine(template, combineWith);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"dumbCombine\", [template, combineWith], result);\n    setTemplate(result);\n  }\n\n  function addKeyToNumerator(appendKey: string, toKey: string) {\n    const fullToKey = Object.keys(template).find(\n      (k) => k.split(\"/\")[0] === toKey\n    );\n    if (fullToKey != null) {\n      // check that the appendKey isn't already in there\n      const denoms = fullToKey.split(\"/\")[1]?.split(\",\");\n      if (denoms?.includes(appendKey)) {\n        return;\n      }\n    }\n    let newTemplate = appendKeyToKey(template, appendKey, toKey);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"appendKeyToKey\", [template, appendKey, toKey], result);\n\n    setTemplate(result);\n  }\n\n  function insertTemplateIntoTemplate(templateToInsert: Template) {\n    console.log(\"inserting template into template\", templateToInsert);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], result);\n\n    setTemplate(result);\n  }\n  function insertTemplateIntoTemplateAtKey(\n    templateToInsert: Template,\n    toKey: string\n  ) {\n    console.log(\n      \"insertTemplateIntoTemplateAtKey\",\n      templateToInsert,\n      toKey,\n      template\n    );\n    const oldKeys = Object.keys(template);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], newTemplate);\n\n    const newKeys = Object.keys(newTemplate);\n    const newestKey = newKeys\n      .filter((k) => !oldKeys.includes(k))[0]\n      ?.split(\"/\")[0];\n    //console.log(\"NEWEST KEY\", newestKey);\n    let appendedTemplate = appendKeyToKey(newTemplate, newestKey, toKey);\n    const result = sortTemplateByDeps(sortTemplateByDeps(appendedTemplate));\n    logStep(\"appendKeyToKey\", [newTemplate, newestKey, toKey], result);\n    setTemplate(result);\n  }\n\n  const handleGeneratorResult = (message: any) => {\n    //console.log(\"WORD STEPS ON MESSAGE\", wordSteps);\n\n    //console.log(\"MESSAGE DATA\", message.data);\n    const { generatorFilePath, resultFilePath, result, generatorString } =\n      message.data;\n    //console.log(\"generator_result\", result);\n    const name = generatorString.substring(0, generatorString.indexOf(\"(\"));\n\n    const args = generatorString\n      .substring(generatorString.indexOf(\"(\") + 1, generatorString.indexOf(\")\"))\n      .split(\",\");\n\n    logStep(name, args, result, {\n      generatorFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  };\n\n  const handleWordRunResult = (message:any) => {\n    const { wordRunFilePath, resultFilePath, result, wordString } =\n      message.data;\n    console.log(\"word_run_result\", result);\n    const name = wordString.substring(0, wordString.indexOf(\"(\"));\n\n    const args = [\"template\"]\n\n    logStep(name, args, result, {\n      wordRunFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  }\n\n  function handleGenericMessage(event: MessageEvent) {\n    const message = event.data; // The json data that the extension sent\n    ${run(hookCmdHandler01, \"hookCmdHandler01\")}\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleGenericMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleGenericMessage);\n    };\n  }, [isMainTemplate]);\n  function handleMessage(event: MessageEvent) {\n    if (event.data.data.msgId !== msgId) return;\n    const message = event.data; // The json data that the extension sent\n    ${run(hookCmdHandler02, \"hookCmdHandler02\")} {\n        // defaults give a good end-of-switch-statement parse hack\n        break;\n      }\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleMessage);\n    };\n  }, [wordSteps]);\n  function applyGeneratorString(generatorString: string) {\n    // form it and send it over\n\n    // send it over via postMessage\n   ${run(commandSend02, \"commandSend02\")}\n  }\n  const handleConvertWordSteps = () => {\n    const parsedWord=parseWordStepsIntoWord(definition.name, wordSteps)\n    console.log(\"parsedWord\", parsedWord, wordSteps);\n    postMessage({\n      command: \"store_runnable_word\",\n      word: parsedWord,\n    })\n  }\n  const handleRunnableWordClick = (rWordName:string) => {\n    // postMessage\n    // run word\n    // get result back\n\n    postMessage({\n      command: \"run_word\",\n      wordName:rWordName,\n      template: tts(template,false),\n      msgId,\n    })\n  }\n  const handleTransition = () => {\n    postMessage({\n      command: \"transition\",\n      template: tts(template,false),\n    })\n  }\n  //console.log(\"Word steps\", wordSteps);\n  return {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n    handleConvertWordSteps,\n    handleRunnableWordClick,\n    handleTransition\n  };\n}\n\nfunction parseWordStepsIntoWord(wordName:string, wordSteps: WordStep[]): string {\n\tconst callbacks = compact(wordSteps.map(step=> {\n\t\tif(step.name===\"insertIntoTemplate\") {\n\t\t\treturn null\n\t\t}\n    if(step.full==null) {return null}\n\t\treturn \\u30A7(template)=>\\xA7{step.full}\\u30A7\n\t}))\n\n\tconst word = \\u30A7export const \\xA7{wordName} = flow(\\xA7{callbacks.join(\",\")})\\u30A7\n  return word;\n}`,\n'hookCmdHandler02/hookCommandHandlerBody02': ({ hookCommandHandlerBody02 }) => `switch (message.command)${run(hookCommandHandlerBody02, \"hookCommandHandlerBody02\")}default:`,\n'hookCommandHandlerBody02/hookCmdHandleSection02,hookCmdHandleSection02': ({ hookCmdHandleSection02 }) => ` {\n      ${run(hookCmdHandleSection02, \"hookCmdHandleSection02\")}\n      ${run(hookCmdHandleSection02, \"hookCmdHandleSection02\")}\n      }\n      `,\n'hookCmdHandler01/hookCommandHandlerBody01': ({ hookCommandHandlerBody01 }) => `switch (message.command)${run(hookCommandHandlerBody01, \"hookCommandHandlerBody01\")}default:`,\n'hookCommandHandlerBody01/hookCmdHandleSection03': ({ hookCmdHandleSection03 }) => ` {\n      ${run(hookCmdHandleSection03, \"hookCmdHandleSection03\")}\n      } \n      `,\n'hookCmdHandleSection03/hookHandlerName03,hookHandlerBody03': ({ hookHandlerName03, hookHandlerBody03 }) => `case \"${run(hookHandlerName03, \"hookHandlerName03\")}\":${run(hookHandlerBody03, \"hookHandlerBody03\")}break;`,\n'commandSend01/commandBody01': ({ commandBody01 }) => ` postMessage({${run(commandBody01, \"commandBody01\")}});`,\n'commandBody01/nameProperty13': ({ nameProperty13 }) => `\n      ${run(nameProperty13, \"nameProperty13\")}\n      wordSteps: JSON.stringify(stringifiedSteps),\n      wordName,\n      msgId,\n    `,\n'nameProperty13/commandName13': ({ commandName13 }) => `command: \"${run(commandName13, \"commandName13\")}\",`,\n'wordRunService.tsaa3e96021c/fileContents3': ({ fileContents3 }) => `${run(fileContents3, \"fileContents3\")}`,\n'fsService.tse294b67673/fileContents4': ({ fileContents4 }) => `${run(fileContents4, \"fileContents4\")}`,\n'configService.ts0198e0307e/fileContents5': ({ fileContents5 }) => `${run(fileContents5, \"fileContents5\")}`,\n'commandService.ts69cdb52686/fileContents6': ({ fileContents6 }) => `${run(fileContents6, \"fileContents6\")}`,\n'parseWords.ts0da51f25b2/fileContents7': ({ fileContents7 }) => `${run(fileContents7, \"fileContents7\")}`,\n'hotKeyBuilder.ts6daa92dc78/fileContents8': ({ fileContents8 }) => `${run(fileContents8, \"fileContents8\")}`,\n'parseTemplates.tsbf975773bc/fileContents9': ({ fileContents9 }) => `${run(fileContents9, \"fileContents9\")}`,\n'util.ts2d61ca9574/fileContents10': ({ fileContents10 }) => `${run(fileContents10, \"fileContents10\")}`,\n'useWordBuilder.ts50447cadc3/fileContents11': ({ fileContents11 }) => `${run(fileContents11, \"fileContents11\")}`,\n'fileContents11/commandSend03': ({ commandSend03 }) => `\nimport { customAlphabet } from \"nanoid\";\nimport { useState } from \"react\";\nimport { genTemplateWithVars } from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\nimport { cloneDeep } from \"lodash\";\nimport { setKeyValue } from \"./util\";\nimport {\n  buildWordBodyFromSteps,\n  buildWordFromNameAndBody,\n} from \"../util/parsers/createWordFromJson\";\n\nexport type BuilderWord = {\n  name: string;\n  steps: BuilderGenerator[];\n};\nexport type BuilderTemplate = {\n  name: string;\n  templateBody: string; // the body of the template\n  vars: string[]; // the variables in the template\n};\n\nexport type Schema = Record<string, any>;\n\nexport type BuilderGenerator = {\n  name: string;\n  inputs?: Record<string, any>;\n  inputSchema: Schema;\n  outputName?: string;\n};\n\nexport type BuilderNewWord = {\n  wordName: string;\n  steps: BuilderGenerator[];\n};\n\nexport enum Types {\n  Template = \"Template\",\n  TemplateArray = \"TemplateArray\",\n  String = \"String\",\n  StringArray = \"StringArray\",\n  Number = \"Number\",\n  Object = \"Object\", // recurse on this\n  Function = \"Function\",\n  ArrayOfObjects = \"ArrayOfObjects\", // recurse on this*/\n}\nconst firsty: Template = {\n  firsty: () => \\u30A7this is where we do it\\u30A7,\n};\nconst secondy: Template = {\n  secondy: () => \\u30A7that is the second time\\u30A7,\n};\n\nconst thirdy: Template = {\n  thirdy: () => \\u30A7this is the third time\\u30A7,\n};\nconst fourthy: Template = {\n  fourthy: () => \\u30A7this is the fourth time\\u30A7,\n};\nconst fifthy: Template = {\n  fifthy: () => \\u30A7this is the fifth time\\u30A7,\n};\nconst sixthy: Template = genTemplateWithVars(\n  { sixthy: () => \"I hope this works\" },\n  [\"hope\"]\n);\n\nfunction buildInputsFromSchema(schema: Schema) {\n  const inputs: Record<string, any> = {};\n  Object.entries(schema).forEach(([key, type]) => {\n    if (type === Types.Template) {\n      inputs[key] = null;\n    } else if (type === Types.TemplateArray) {\n      inputs[key] = [];\n    } else if (type === Types.String) {\n      inputs[key] = \"\";\n    }\n  });\n  return inputs;\n}\n\nconst identityGenerator: BuilderGenerator = {\n  name: \"identity\",\n  inputSchema: { template: Types.Template },\n  inputs: { template: null },\n};\n\nconst combineAllGenerator: BuilderGenerator = {\n  name: \"combineAll\",\n  inputSchema: { templates: Types.TemplateArray },\n};\n\nconst combineGenerator = {\n  name: \"combine\",\n  generator: (template1: Template, template2: Template) => ({\n    ...template1,\n    ...template2,\n  }),\n  inputSchema: {\n    template1: Types.Template,\n    template2: Types.Template,\n  },\n  inputs: { template1: null, template2: null },\n};\nexport function useWordBuilder({\n  wordsMeta,\n  templatesMeta,\n  generatorsMeta,\n  postMessage,\n}: {\n  wordsMeta: BuilderWord[];\n  templatesMeta: BuilderTemplate[];\n  generatorsMeta: BuilderGenerator[];\n  postMessage: any;\n}) {\n  const [newWord, setNewWord] = useState<BuilderNewWord>({\n    wordName: \"new\", // handled by form now, sorry for the tech debt!\n    steps: [],\n  });\n  const [runtimeError, setRuntimeError] = useState<string | null>(null);\n\n  function addStepToWord(step: any, position: number) {\n    // if step doesn't have an output, we create one.\n    // this should be specified by the generator...\n\n    const alphabet =\n      \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    const nanoid = customAlphabet(alphabet, 4);\n    const stepOutputId = nanoid();\n\n    const newStep = {\n      ...step,\n      outputName: step.name + \"_\" + stepOutputId,\n      ...buildInputsFromSchema(step.inputSchema),\n    };\n\n    setNewWord((prev) => {\n      const newSteps = [...prev.steps];\n      newSteps.splice(position, 0, newStep);\n      const stepsWithInput = setAllStepInputsToPriorStepOutput(newSteps);\n      console.log(\"NEW STEPS\", stepsWithInput);\n      return { ...prev, steps: stepsWithInput };\n    });\n  }\n\n  function submitWord(formSubmission: any) {\n    console.log(\"SUBMITTING\", formSubmission);\n    // grab steps\n    // update the values at each step\n    const newSteps = newWord.steps.map((step) => {\n      const stepOutputName = step.outputName;\n      const formStep = formSubmission[stepOutputName];\n      // put step values from formStep into step\n      return { ...step, inputValues: formStep };\n    });\n\n    console.log(\"NEW WORD\", JSON.stringify(newSteps, null, 2));\n\n    const parsedSteps = buildWordBodyFromSteps(\n      JSON.stringify(newSteps, null, 2)\n    );\n    const fullWord = buildWordFromNameAndBody(\n      formSubmission.wordName,\n      parsedSteps\n    );\n    // TODO: MAKE CONFIGURABLE\n\n    console.log(\"PARSED STEPS\", fullWord);\n   ${run(commandSend03, \"commandSend03\")}\n    console.log(\"POSTED MESSAGE\");\n  }\n\n  function setAllStepInputsToPriorStepOutput(steps) {\n    return steps.map((step, idx) => {\n      const priorStepOutput = steps[idx - 1]?.outputName ?? \"wordInput\";\n      const inputSchema = cloneDeep(step.inputSchema);\n      delete step.inputSchema;\n      const newStep = setKeyValue(\"input\", priorStepOutput, step);\n      newStep.inputSchema = inputSchema;\n      return newStep;\n    });\n  }\n\n  function removeStepFromWord(position: number) {\n    // go thru all steps. if any step uses output from\n    // the deleted step, remove that output!\n    const { steps } = newWord;\n    const removedStep = steps[position];\n    const removedOutput = removedStep.outputName;\n    const newSteps = steps.filter((step) => {\n      console.log(\"FULL STEP\", step);\n      if (step.inputs == null) return true;\n      const inputs = Object.values(step?.inputs);\n      console.log(\n        \"LOOKING AT\",\n        inputs,\n        removedOutput,\n        \"FROM STEP\",\n        step.inputs\n      );\n      return !inputs.includes(removedOutput);\n    });\n    setNewWord((prev) => {\n      newSteps.splice(position, 1);\n      return { ...prev, steps: newSteps };\n    });\n  }\n\n  function updateStepPosition(from: number, to: number) {\n    setNewWord((prev) => {\n      const newSteps = [...prev.steps];\n      const [removed] = newSteps.splice(from, 1);\n      newSteps.splice(to, 0, removed);\n      return { ...prev, steps: newSteps };\n    });\n  }\n\n  function runWord(name: string, input: Template = {}) {\n    const outputs: Template[] = [];\n    function registerOutput(output: Template) {\n      outputs.push(output);\n    }\n    /*\n    const word = words.find((w: BuilderWord) => w.name === name);\n    // run the word raw. if any errors occur, let TypeScript return them, and we'll display.\n    // we'll need to load it into typescript dynamically, which is very V2.\n    try {\n      word(input, registerOutput);\n    } catch (e) {\n      console.error(e);\n      setRuntimeError(e.message);\n    }\n      */\n  }\n\n  return {\n    newWord,\n    runtimeError,\n    addStepToWord,\n    updateStepPosition,\n    runWord,\n    removeStepFromWord,\n    submitWord,\n  };\n}\n`,\n'commandSend03/commandBody03': ({ commandBody03 }) => ` postMessage({${run(commandBody03, \"commandBody03\")}});`,\n'commandBody03/nameProperty11': ({ nameProperty11 }) => `\n      ${run(nameProperty11, \"nameProperty11\")}\n      word: fullWord.fullWord(),\n      pathToConfig:\n        \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig\",\n    `,\n'nameProperty11/commandName11': ({ commandName11 }) => `command: \"${run(commandName11, \"commandName11\")}\",`,\n'useRunner.ts2d1ba9b42e/fileContents12': ({ fileContents12 }) => `${run(fileContents12, \"fileContents12\")}`,\n'fileContents12/commandSend04,commandSend05,commandSend06,commandSend07': ({ commandSend04, commandSend05, commandSend06, commandSend07 }) => `\nimport { customAlphabet } from \"nanoid\";\nimport React, { useEffect, useState } from \"react\";\nimport {\n  genTemplateWithVars,\n  tts,\n  argsAndTemplateToFunction,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\nexport function useRunner(\n  postMessage: any,\n  configPath: string,\n  filledGeneratorsFileText: string\n) {\n  const alphabet =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const nanoid = customAlphabet(alphabet, 4);\n  //console.log(\"TEST??\",filledGeneratorsFileText)\n  const [msgId, setMsgId] = useState(nanoid());\n  const [generatorModule, setGeneratorModule] = React.useState<any>({});\n  const [templateModule, setTemplateModule] = React.useState<any>(null);\n  const [wordModule, setWordModule] = React.useState<any>(null);\n  const [filledGenerators, setFilledGenerators] = React.useState<Template>(\n    new Function(\"return \" + filledGeneratorsFileText)()\n  );\n  //console.log(\"FILLED GENERATORs\", filledGenerators)\n  useEffect(() => {\n    setFilledGenerators(new Function(\"return \" + filledGeneratorsFileText)());\n  }, [filledGeneratorsFileText]);\n  const fetchGenerators = async () => {\n    const data = await import(\"../../pools/utility-templates\");\n    setGeneratorModule(data);\n  };\n  const fetchTemplates = async () => {\n    const data = await import(\"../../pools/template-pool\");\n    //console.log(\"AFTER IMPORT\", data);\n    // @ts-ignore\n    //console.log(\"GOOD LUCK\", data);\n    setTemplateModule(data);\n  };\n\n  useEffect(() => {\n    fetchGenerators();\n    fetchTemplates();\n  }, []);\n\n  useEffect(() => {\n    window.addEventListener(\"message\", (event) => {\n      if (event.data.data.msgId !== msgId) return;\n      const message = event.data; // The json data that the extension sent\n      switch (message.command) {\n        case \"all_filled_generators\": {\n          //console.log(\"all_filled_generators\", message.data);\n          const { allFilledGenerators } = message.data;\n          setFilledGenerators(new Function(\"return \" + allFilledGenerators)());\n          //console.log(\"NEW ALL FILELD\",new Function(\"return \" + allFilledGenerators)())\n          break;\n        }\n      }\n    });\n  }, []);\n\n  const addFullTemplateToPool = (name: string, template: Template) => {\n    if (templateModule[name] != null) {\n      throw new Error(\"Template with this name already exists\");\n    }\n  ${run(commandSend04, \"commandSend04\")}\n   ${run(commandSend05, \"commandSend05\")}\n  };\n\n  const addToFilledGeneratorPool = (filledGenerator: Template) => {\n    if (Object.keys(filledGenerator).length !== 1) {\n      throw new Error(\"Filled generator must have exactly one key\");\n    } else {\n     ${run(commandSend06, \"commandSend06\")}\n    }\n  };\n\n  const handleSaveAllFiles = (template: Template) => {\n   ${run(commandSend07, \"commandSend07\")}\n  };\n\n  //console.log(\"here we are\", generatorModule, templateModule, wordModule);\n\n  return {\n    templateModule,\n    handleSaveAllFiles,\n    generatorModule,\n    wordModule,\n    filledGenerators,\n    addToTemplatePool,\n    addToFilledGeneratorPool,\n    addFullTemplateToPool\n  };\n}\n`,\n'commandSend07/commandBody07': ({ commandBody07 }) => ` postMessage({${run(commandBody07, \"commandBody07\")}});`,\n'commandBody07/nameProperty07': ({ nameProperty07 }) => `\n      ${run(nameProperty07, \"nameProperty07\")}\n      pathToConfig: configPath,\n      template: tts(template),\n    `,\n'nameProperty07/commandName07': ({ commandName07 }) => `command: \"${run(commandName07, \"commandName07\")}\",`,\n'commandSend06/commandBody06': ({ commandBody06 }) => ` postMessage({${run(commandBody06, \"commandBody06\")}});`,\n'commandBody06/nameProperty08': ({ nameProperty08 }) => `\n        ${run(nameProperty08, \"nameProperty08\")}\n        pathToConfig: configPath,\n        filledGenerator: tts(filledGenerator, false),\n        msgId,\n      `,\n'nameProperty08/commandName08': ({ commandName08 }) => `command: \"${run(commandName08, \"commandName08\")}\",`,\n'commandSend05/commandBody05': ({ commandBody05 }) => ` postMessage({${run(commandBody05, \"commandBody05\")}});`,\n'commandBody05/nameProperty09': ({ nameProperty09 }) => `\n      ${run(nameProperty09, \"nameProperty09\")}\n      key,\n      args: JSON.stringify(args),\n      value,\n      pathToConfig: configPath,\n    `,\n'nameProperty09/commandName09': ({ commandName09 }) => `command: \"${run(commandName09, \"commandName09\")}\",`,\n'commandSend04/commandBody04': ({ commandBody04 }) => ` postMessage({${run(commandBody04, \"commandBody04\")}});`,\n'commandBody04/nameProperty10': ({ nameProperty10 }) => `\n    ${run(nameProperty10, \"nameProperty10\")}\n    name,\n    template: tts(template, false),\n    pathToConfig: configPath,\n   })\n  }\n\n  const addToTemplatePool = (key: string, value: string, args: string[]) => {\n    const funcPart = argsAndTemplateToFunction([], value);\n    const templ = { [key]: funcPart };\n    const template = genTemplateWithVars(templ, args);\n    //console.log(\"addToTemplatePool\", template);\n    if (templateModule[key] != null) {\n      throw new Error(\"Template with this name already exists\");\n    }\n    setTemplateModule((prev) => {\n      return {\n        ...prev,\n        ...{ [key]: template },\n      };\n    `,\n'nameProperty10/commandName10': ({ commandName10 }) => `command: \"${run(commandName10, \"commandName10\")}\",`,\n'useQueueListener.ts0a03de5ffe/fileContents13': ({ fileContents13 }) => `${run(fileContents13, \"fileContents13\")}`,\n'fileContents13/hookCmdHandler03': ({ hookCmdHandler03 }) => `\nimport { useEffect, useState } from \"react\";\nimport { DequeueStep } from \"../../runner/runner\";\ntype QueueStepData = {\n  type: string;\n  name: string;\n  description: string;\n  word: string;\n  isWaitingForCommand: boolean;\n  transitionAction: string;\n}\n\nexport function useQueueListener() {\n  const [queueSteps, setQueueSteps] = useState<QueueStepData[]>([]);\n  function handleQueueUpdate(message) {\n    const data = message.data;\n    const currentQueue = JSON.parse(data.currentQueue);\n    setQueueSteps(currentQueue);\n  }\n  function handleMessage(event: MessageEvent) {\n    const message = event.data; // The json data that the extension sent\n    ${run(hookCmdHandler03, \"hookCmdHandler03\")} {\n        // defaults give a good end-of-switch-statement parse hack\n        break;\n      }\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleMessage);\n    };\n  }, []);\n\n  return {\n    queueSteps,\n  }\n}\n`,\n'hookCmdHandler03/hookCommandHandlerBody03': ({ hookCommandHandlerBody03 }) => `switch (message.command)${run(hookCommandHandlerBody03, \"hookCommandHandlerBody03\")}default:`,\n'hookCommandHandlerBody03/hookCmdHandleSection01': ({ hookCmdHandleSection01 }) => ` {\n      ${run(hookCmdHandleSection01, \"hookCmdHandleSection01\")}\n      `,\n'hookCmdHandleSection01/hookHandlerName01,hookHandlerBody01': ({ hookHandlerName01, hookHandlerBody01 }) => `case \"${run(hookHandlerName01, \"hookHandlerName01\")}\":${run(hookHandlerBody01, \"hookHandlerBody01\")}break;`,\n'useMeta.tsaa5e4c5ba3/fileContents14': ({ fileContents14 }) => `${run(fileContents14, \"fileContents14\")}`,\n'useHotkeys.ts3ae905fc81/fileContents15': ({ fileContents15 }) => `${run(fileContents15, \"fileContents15\")}`,\n'useFileSystem.ts4f87732c11/fileContents16': ({ fileContents16 }) => `${run(fileContents16, \"fileContents16\")}`,\n'fileContents16/commandSend08,commandSend09,commandSend010,commandSend011,commandSend012,commandSend013': ({ commandSend08, commandSend09, commandSend010, commandSend011, commandSend012, commandSend013 }) => `\nimport React from \"react\";\nimport { WordStep } from \"./useTemplate\";\nimport { tts } from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\nfunction parseStringifiedTemplateModule(templateModule: string) {\n  const templModuleFirstParse = new Function(\"return \" + templateModule)();\n  const templModule = Object.keys(templModuleFirstParse).reduce((acc, key) => {\n    const templified = new Function(\"return \" + templModuleFirstParse[key])();\n    acc[key] = templified;\n    return acc;\n  }, {});\n  return templModule;\n}\n\nexport function useFileSystem(postMessage) {\n  const [all, setAll] = React.useState<any>({\n    generatorsFileText: null,\n    templatesFileText: null,\n    filledGeneratorsFileText: null,\n    currentWord: null,\n    wordNames: [],\n    currentWordName: null,\n    templateModule: null,\n    allFileTemplates: null,\n    runnableWords: null,\n    queueNames: [],\n    subTemplate: null\n  });\n  const [loading, setLoading] = React.useState(true);\n  React.useEffect(() => {\n    window.addEventListener(\"message\", (event) => {\n      const message = event.data; // The json data that the extension sent\n      switch (message.command) {\n        case \"config_data\": {\n          const {\n            generators,\n            templates,\n            filledGenerators,\n            currentWord,\n            wordNames,\n            currentWordName,\n            templateModule,\n            fileTemplates,\n            runnableWords,\n            queueNames,\n            subTemplate,\n          }: {\n            generators: string;\n            templates: string;\n            filledGenerators: string;\n            currentWord: string;\n            wordNames: string;\n            currentWordName: string;\n            templateModule: string;\n            fileTemplates: string;\n            runnableWords: string;\n            queueNames: string;\n            subTemplate: string;\n          } = message.data;\n          const rw = JSON.parse(runnableWords);\n          const parsedCurrentWord = JSON.parse(currentWord).map((cw) => ({\n            ...cw,\n            result: new Function(\"return \" + cw.result)(),\n          }));\n          const parsedAllFileTemplate = new Function(\n            \"return \" + fileTemplates\n          )();\n          const parsedSubTemplate =\n            subTemplate == null\n              ? null\n              : new Function(\"return \" + subTemplate)();\n          const templModule = parseStringifiedTemplateModule(templateModule);\n          const parsedWordNames = JSON.parse(wordNames);\n          const parsedQueueNames = JSON.parse(queueNames);\n\n          const all ={\n            generatorsFileText: generators,\n            templatesFileText: templates,\n            filledGeneratorsFileText: filledGenerators,\n            currentWord: parsedCurrentWord,\n            wordNames: parsedWordNames,\n            currentWordName: currentWordName,\n            templateModule: templModule,\n            allFileTemplates: parsedAllFileTemplate,\n            runnableWords: rw,\n            queueNames: parsedQueueNames,\n            subTemplate: parsedSubTemplate,\n          };\n          setAll(all);\n          setLoading(false);\n          break;\n        }\n        case \"word_contents\": {\n          const { wordName, wordContents } = message.data;\n          console.log(\"WORD CONTENTS\", message);\n          //setCurrentWordName(wordName);\n          let parsedCurrentWord;\n          if (wordContents === \"[]\") {\n            parsedCurrentWord = [{ result: {} }];\n          } else {\n            parsedCurrentWord = JSON.parse(wordContents).map((cw) => ({\n              ...cw,\n              result: new Function(\"return \" + cw.result)(),\n            }));\n          }\n          //setCurrentWord(parsedCurrentWord);\n          let newWordNames = all.wordNames;\n          if (!all.wordNames.includes(wordName)) {\n            newWordNames=[...all.wordNames, wordName];\n          }\n          setAll((prev) => ({ ...prev, wordNames: newWordNames, currentWord:parsedCurrentWord, currentWordName:wordName }));\n          setLoading(false);\n          break;\n        }\n        case \"all_templates\": {\n          const { templateModule } = message.data;\n          const templModule = parseStringifiedTemplateModule(templateModule);\n          setAll((prev) => ({ ...prev, templateModule: templModule }));\n          break;\n        }\n        case \"all_file_templates\": {\n          const { fileTemplates } = message.data;\n\n          setAll((prev) => ({ ...prev, allFileTemplates: new Function(\"return \" + fileTemplates)() }));\n          break;\n        }\n        case \"all_runnable_words\": {\n          const { runnableWords } = message.data;\n          const rw = JSON.parse(runnableWords);\n          setAll((prev) => ({ ...prev, runnableWords: rw }));\n        }\n      }\n    });\n  }, []);\n  const readAllFiles = (queueName: string) => {\n   ${run(commandSend08, \"commandSend08\")}\n  };\n  const writeFile = (path, data) => {\n   ${run(commandSend09, \"commandSend09\")}\n  };\n  const setWord = (name) => {\n   ${run(commandSend010, \"commandSend010\")}\n\n    setLoading(true);\n  };\n  const createNewWord = (name) => {\n    // word_contents received in response\n   ${run(commandSend011, \"commandSend011\")}\n    setLoading(true);\n  };\n  const addToTemplatePool = (key: string, value: string, args: string[]) => {\n    console.log(\"SENDING TO ADD TO TEMPLATE POOL\", key, value, args);\n   ${run(commandSend012, \"commandSend012\")}\n  };\n  const selectQueue = (queueName) => {\n   ${run(commandSend013, \"commandSend013\")}\n  };\n\n  return {\n    readAllFiles,\n    createNewWord,\n    writeFile,\n    setWord,\n    addToTemplatePool,\n    selectQueue,\n    loading,\n    ...all,\n  };\n}\n`,\n'commandSend013/commandBody013': ({ commandBody013 }) => ` postMessage({${run(commandBody013, \"commandBody013\")}});`,\n'commandBody013/nameProperty01': ({ nameProperty01 }) => `\n      ${run(nameProperty01, \"nameProperty01\")}\n      queueName,\n    `,\n'nameProperty01/commandName01': ({ commandName01 }) => `command: \"${run(commandName01, \"commandName01\")}\",`,\n'commandSend012/commandBody012': ({ commandBody012 }) => ` postMessage({${run(commandBody012, \"commandBody012\")}});`,\n'commandBody012/nameProperty02': ({ nameProperty02 }) => `\n      ${run(nameProperty02, \"nameProperty02\")}\n      key,\n      args: JSON.stringify(args),\n      value,\n    `,\n'nameProperty02/commandName02': ({ commandName02 }) => `command: \"${run(commandName02, \"commandName02\")}\",`,\n'commandSend011/commandBody011': ({ commandBody011 }) => ` postMessage({${run(commandBody011, \"commandBody011\")}});`,\n'commandBody011/nameProperty03': ({ nameProperty03 }) => `\n      ${run(nameProperty03, \"nameProperty03\")}\n      wordName: name,\n    `,\n'nameProperty03/commandName03': ({ commandName03 }) => `command: \"${run(commandName03, \"commandName03\")}\",`,\n'commandSend010/commandBody010': ({ commandBody010 }) => ` postMessage({${run(commandBody010, \"commandBody010\")}});`,\n'commandBody010/nameProperty04': ({ nameProperty04 }) => `\n      ${run(nameProperty04, \"nameProperty04\")}\n      wordName: name,\n    `,\n'nameProperty04/commandName04': ({ commandName04 }) => `command: \"${run(commandName04, \"commandName04\")}\",`,\n'commandSend09/commandBody09': ({ commandBody09 }) => ` postMessage({${run(commandBody09, \"commandBody09\")}});`,\n'commandBody09/nameProperty05': ({ nameProperty05 }) => ` ${run(nameProperty05, \"nameProperty05\")} path, data `,\n'nameProperty05/commandName05': ({ commandName05 }) => `command: \"${run(commandName05, \"commandName05\")}\",`,\n'commandSend08/commandBody08': ({ commandBody08 }) => ` postMessage({${run(commandBody08, \"commandBody08\")}});`,\n'commandBody08/nameProperty06': ({ nameProperty06 }) => ` ${run(nameProperty06, \"nameProperty06\")} queueName `,\n'nameProperty06/commandName06': ({ commandName06 }) => `command: \"${run(commandName06, \"commandName06\")}\",`,\n'hgcgUtil.ts791df9ac7f/fileContents17': ({ fileContents17 }) => `${run(fileContents17, \"fileContents17\")}`,\n'v2.tsx715fc7afef/fileContents18': ({ fileContents18 }) => `${run(fileContents18, \"fileContents18\")}`,\n'WordCreator.tsx4102c005c8/fileContents19': ({ fileContents19 }) => `${run(fileContents19, \"fileContents19\")}`,\n'WordBuilderForm.tsxec964c89ec/fileContents20': ({ fileContents20 }) => `${run(fileContents20, \"fileContents20\")}`,\n'TemplateTree.tsx0524a0d899/fileContents21': ({ fileContents21 }) => `${run(fileContents21, \"fileContents21\")}`,\n'SortableItem.tsx3cad9f1f40/fileContents22': ({ fileContents22 }) => `${run(fileContents22, \"fileContents22\")}`,\n'QueueHeader.tsx6dd24430ee/fileContents23': ({ fileContents23 }) => `${run(fileContents23, \"fileContents23\")}`,\n'Item.tsxc641ad44fb/fileContents24': ({ fileContents24 }) => `${run(fileContents24, \"fileContents24\")}`,\n'GTWVEditor.tsxf2771a3915/fileContents25': ({ fileContents25 }) => `${run(fileContents25, \"fileContents25\")}`,\n'DynamicFormOld3.tsx0cf8ec536f/fileContents26': ({ fileContents26 }) => `${run(fileContents26, \"fileContents26\")}`,\n'DynamicForm.tsxdf152500d9/fileContents27': ({ fileContents27 }) => `${run(fileContents27, \"fileContents27\")}`,\n'Dropdown.tsx30dab73e04/fileContents28': ({ fileContents28 }) => `${run(fileContents28, \"fileContents28\")}`,\n'BuilderAccordion.tsxf6c47abb17/fileContents29': ({ fileContents29 }) => `${run(fileContents29, \"fileContents29\")}`,\n'App.tsxe233888b2d/fileContents30': ({ fileContents30 }) => `${run(fileContents30, \"fileContents30\")}`,\n'.DSfa3f423110/fileContents31': ({ fileContents31 }) => `${run(fileContents31, \"fileContents31\")}`,\n'runner.ts09798de81d/fileContents32': ({ fileContents32 }) => `${run(fileContents32, \"fileContents32\")}`,\n'parseGenerators.tsa908b43054/fileContents33': ({ fileContents33 }) => `${run(fileContents33, \"fileContents33\")}`,\n'createWordFromJson.ts895f3edd7a/fileContents34': ({ fileContents34 }) => `${run(fileContents34, \"fileContents34\")}`,\n'index.tsxec7ce083ed/fileContents35': ({ fileContents35 }) => `${run(fileContents35, \"fileContents35\")}`,\n'getNonce.ts47b72c4626/fileContents36': ({ fileContents36 }) => `${run(fileContents36, \"fileContents36\")}`,\n'extension.tsec46bfbfac/fileContents37': ({ fileContents37 }) => `${run(fileContents37, \"fileContents37\")}`,\n'compiler.tsc3618913d2/fileContents38': ({ fileContents38 }) => `${run(fileContents38, \"fileContents38\")}`,\n'.DSe7e2950e98/fileContents39': ({ fileContents39 }) => `${run(fileContents39, \"fileContents39\")}`,\n'commandName01': () => \"select_queue\",\n'commandName02': () => \"add_template\",\n'commandName03': () => \"create_word\",\n'commandName04': () => \"get_word\",\n'commandName05': () => \"writeFile\",\n'commandName06': () => \"fetch_from_config\",\n'commandName07': () => \"save_all_files\",\n'commandName08': () => \"add_filled_generator\",\n'commandName09': () => \"add_template\",\n'commandName10': () => \"add_full_template\",\n'commandName11': () => \"save_word\",\n'commandName12': () => \"run_generator\",\n'commandName13': () => \"save_word_steps\",\n'fileContents3': () => `\nimport { readFromConfig } from \"./commandService\";\nimport { runTs, saveFile } from \"../compiler\";\nimport { formWordRunFile, QUEUE_SPLITTER, RESULT_SPLITTER } from \"./hardToParse/util\";\n\nexport type TemplateAsString = string;\n\nexport type WordRunResult = {\n  template: string;\n  wordRunFilePath: string;\n  resultFilePath: string;\n  queuedTemplates: string[];\n};\n\ntype WordRunParse = {\n  template: string;\n  queue: string[];\n}\nfunction parseWordRunResult(result: string): WordRunParse {\n  const split = result.split(RESULT_SPLITTER);\n  const template = split[0];\n  const queue = split[1];\n  if(queue!=null) {\n    const queueTemplates = queue.split(QUEUE_SPLITTER).filter(q=>q.length>0).map(q=>q.trim());\n\n    return {\n      template,\n      queue: queueTemplates\n    }\n  \n  } else {\n    return {template, queue: []}\n  }\n\n}\n// !!: the template is passed in as a string\n// and the return is also a string\n// this is bc it's from the command line.\nexport async function runWord(\n  pathToConfig: string,\n  wordName: string,\n  templateAsString: TemplateAsString\n): Promise<WordRunResult> {\n  const projectDir = await readFromConfig(\"PROJECT_DIR\", pathToConfig);\n  const filePrefix = Date.now();\n  const wordRunFile = formWordRunFile(wordName, templateAsString);\n  const wordRunFileName = filePrefix + \"_wordRun.ts\";\n  const resultFile = filePrefix + \"_result\";\n  const wordRunFilePath = projectDir + \"/\" + wordRunFileName;\n  const resultFilePath = projectDir + \"/\" + resultFile;\n  // saveFile doesn't belong here\n  await saveFile(wordRunFilePath, wordRunFile);\n  const result = await runTs(wordRunFilePath);\n  console.log(\"ran word\")\n  const { template, queue } = parseWordRunResult(result);\n  console.log(\"word run RESULTv,\", template);\n  await saveFile(resultFilePath, template+\"\\xD8n\"+queue.join(\"\\xD8n\"));\n  return {\n    template,\n    queuedTemplates: queue,\n    wordRunFilePath,\n    resultFilePath,\n  };\n}\n`,\n'fileContents4': () => `\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { TemplateAsString } from \"./wordRunService\";\nimport {\n  getAllFileTemplates,\n  readFromConfig,\n  storeFileHashes,\n} from \"./commandService\";\n\nimport { promises as fs } from \"fs\";\nimport * as path from \"path\";\nimport { insertIntoTemplate, orderedParse, tts } from \"symmetric-parser\";\nimport { formFilePathHash } from \"../panel\";\n\nexport const identity = async (\n  pathToConfig: string,\n  input: TemplateAsString\n) => {\n  return input;\n};\n\nexport const get = async (pathToConfig: string, input: TemplateAsString) => {\n  const baseDir = await readFromConfig(\"BASE_DIR\", pathToConfig);\n  const ignore = await readFromConfig(\"IGNORE\", pathToConfig);\n  const parseTemplate = new Function(\"return \" + input)();\n  const excludeTempl = {};\n  Object.keys(parseTemplate).filter((key) => key.includes(\"excludePath\")).forEach((key) => {\n    excludeTempl[key] = parseTemplate[key]\n  })\n  const excludeValues = Object.keys(excludeTempl).map((key) => excludeTempl[key]());\n  const allFilePaths = await getAllFilePaths(baseDir, [ignore,...excludeValues]);\n\n  const allFilePathsTemplate: Template = allFilePaths.reduce(\n    (t: Template, path: string) => {\n      const rt = insertIntoTemplate(t, { localFilePath: () => path });\n      return rt;\n    },\n    {}\n  );\n\nconsole.log(\"THE PARSE TEMPLAT\", tts(parseTemplate, false))\n\n  const includeTempl = {};\n  Object.keys(parseTemplate).filter((key) => key.includes(\"filePath\")).forEach((key) => {\n    includeTempl[key] = parseTemplate[key]\n  })\n\n\n  const division = orderedParse(allFilePathsTemplate, [includeTempl]);\n\n  // find all keys with filePath in the denominator\n  const filePaths = Object.keys(division)\n    .filter((key) => key.includes(\"/filePath\"))\n    .map((test) => {\n      console.log(\"TEST\", test);\n      return test;\n    })\n    .map((key) => key.split(\"/\")[0])\n    .map((numerator) => allFilePathsTemplate[numerator]());\n\n\n\n\n  const filePathHashesMap = {};\n\n  filePaths.forEach(\n    (filePath) => (filePathHashesMap[filePath] = formFilePathHash(filePath))\n  );\n\n  await storeFileHashes(pathToConfig, filePathHashesMap);\n\n  const fileTemplates = await getAllFileTemplates(pathToConfig, filePaths);\n\n  return tts(fileTemplates, false);\n};\n\nexport const getOrCreate = async (\n  pathToConfig: string,\n  input: TemplateAsString\n) => {\n  return input;\n};\n\nasync function getAllFilePaths(dir: string, ignoreAll: string[]): Promise<string[]> {\n  let results: string[] = [];\n\n  // Read directory entries (files & folders)\n  const entries = await fs.readdir(dir, { withFileTypes: true });\n\n  for (const entry of entries) {\n    // Construct the full path\n    const fullPath = path.join(dir, entry.name);\n\n    // Skip if the path includes the ignore string\n    if (ignoreAll && ignoreAll.some(i=>fullPath.includes(i))) {\n      continue;\n    }\n\n    // Check if the entry is a directory or a file\n    if (entry.isDirectory()) {\n      // Recursively gather paths from the subdirectory\n      const subPaths = await getAllFilePaths(fullPath, ignoreAll);\n      results.push(...subPaths);\n    } else {\n      // It's a file; add to results\n      results.push(fullPath);\n    }\n  }\n\n  return results;\n}\n`,\n'fileContents5': () => `\nimport { tts } from \"symmetric-parser\";\nimport { runTs } from \"../compiler\";\nimport { readFromFile } from \"../panel\";\nimport {\n  getAllFileTemplates,\n  getAllRunnableWords,\n  getAllWordPathsByLastModified,\n  getWordNamesFromWordPaths,\n  readFromConfig,\n  readMultipleFromConfig,\n  sortFilesByLastModified,\n} from \"./commandService\";\nimport Runner from \"../runner/runner\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\ntype DataFromConfigSO = {\n  generators: string;\n  templates: string;\n  filledGenerators: string;\n  currentWord: string;\n  currentWordName: string;\n  wordNames: string;\n  templateModule: string;\n  fileTemplates: string;\n  runnableWords: string;\n};\n\n// the coupling with Runner is unfortunate, but I don't care.\n// we need it for the current template and name, and doing that\n// outside this function is just a weird layer of indirection.\n// though maybe we'll eat our words. til then\nexport async function fetchFromConfig(\n  pathToConfig: string,\n  runner: Runner\n): Promise<DataFromConfigSO> {\n  try {\n    const [projectDir, generatorPath, templatePath] =\n      await readMultipleFromConfig(\n        [\"PROJECT_DIR\", \"GENERATOR_FILE\", \"TEMPLATE_FILE\"],\n        pathToConfig\n      );\n    const filledGeneratorsPath = projectDir + \"/filledGenerators.json\";\n\n    const promises = [\n      readFromFile(generatorPath),\n      readFromFile(templatePath),\n      readFromFile(filledGeneratorsPath),\n      getAllRunnableWords(pathToConfig),\n      getAllWordPathsByLastModified(pathToConfig),\n      runTs(projectDir + \"/template-getter.ts\"),\n      getAllFileTemplates(pathToConfig),\n      // once upon a time, we initialized the UI\n      // with word = last edited word.\n      // it had downsides, like what if you just\n      // edited generators?\n      // but mostly it didn't fit with our new\n      // Runner/dequeue paradigm.\n      // getWordContents(sortedWordPaths[0]),\n    ];\n\n    //console.log(\"FROM STARTUP TEMPLATE MODEUL\", templateModule);\n    /* part of old Word-based regime, replaced with new Runner/dequeue paradigm\n      const currentWordName = sortedWordPaths[0]\n        .split(\"_\")[1]\n        .replace(\".json\", \"\");\n        */\n\n    const currentWord = [{ result: runner.currentTemplate }];\n    const currentWordName =\n      runner.currentStep.name + Date.now().toString().substring(7);\n    return Promise.all(promises).then((data) => {\n      const [\n        generators,\n        templates,\n        filledGenerators,\n        runnableWords,\n        allWordPaths,\n        templateModule,\n        fileTemplates,\n      ] = data;\n      const wordNames = getWordNamesFromWordPaths(allWordPaths as string[]);\n\n      return {\n        generators: generators as string,\n        templates: templates as string,\n        filledGenerators: filledGenerators as string,\n        currentWord: JSON.stringify(currentWord),\n        currentWordName: currentWordName as string,\n        wordNames: JSON.stringify(wordNames),\n        templateModule: templateModule as string,\n        fileTemplates: tts(fileTemplates as Template, false),\n        runnableWords: JSON.stringify(runnableWords),\n      };\n    });\n  } catch (e) {\n    console.error(e);\n    throw new Error(e);\n  }\n}\n`,\n'fileContents6': () => `\nimport { promises as fs } from \"fs\";\nimport { compact, uniq } from \"lodash\";\nimport path from \"path\";\nimport {\n  argsAndTemplateToFunction,\n  genTemplateWithVars,\n  insertIntoTemplate,\n  orderedParse,\n  stringCleaning,\n  stringUnCleaning,\n  tts,\n} from \"symmetric-parser\";\n\nexport async function appendToFile(filePath: string, data: string) {\n  try {\n    await fs.appendFile(filePath, data);\n  } catch (error) {\n    console.error(\\u30A7Error appending to file: \\xA7{error.message}\\u30A7);\n    throw error;\n  }\n}\n\nexport async function readFromConfig(configVar: string, pathToConfig: string) {\n  try {\n    const data = await fs.readFile(pathToConfig, { encoding: \"utf8\" });\n\n    const lines = data.split(\"\\xD8n\");\n    const result = lines.find((line) => line.includes(configVar)).split(\"=\")[1];\n    return result;\n  } catch (error) {\n    console.error(\"WRONG CONFIG VAR NAME PROVIDED\");\n\n    throw error;\n  }\n}\n\nexport async function readMultipleFromConfig(configVars: string[], pathToConfig: string) {\n  try {\n    let results = [];\n    const data = await fs.readFile(pathToConfig, { encoding: \"utf8\" });\n\n    const lines = data.split(\"\\xD8n\");\n    configVars.forEach((configVar) => {\n      const result = lines.find((line) => line.includes(configVar)).split(\"=\")[1];\n      results.push(result);\n    });\n    \n    return results;\n  } catch (error) {\n    console.error(\"WRONG CONFIG VAR NAME PROVIDED\");\n\n    throw error;\n  }\n}\nexport const getWordPath = async (pathToConfig: string, wordName: string) => {\n  const projectDir = await readFromConfig(\"PROJECT_DIR\", pathToConfig);\n  const wordPaths = await getWordJsonFiles(projectDir);\n  const wordNames = getWordNamesFromWordPaths(wordPaths);\n  const wordIndex = wordNames.indexOf(wordName);\n  return wordPaths[wordIndex];\n};\n\nconst getHashFilePath = async (pathToConfig) => {\n  const projectDir = await readFromConfig(\"PROJECT_DIR\", pathToConfig);\n  const hashFilePath = path.join(projectDir, \"filePathHashes.txt\");\n  return hashFilePath;\n};\nexport const storeFileHashes = async (\n  pathToConfig: string,\n  filePathHashesMap: Record<string, string>\n) => {\n  const allStores = Object.entries(filePathHashesMap).map(\n    async ([filePath, fileHash]) => {\n      return storeFileHash(pathToConfig, fileHash, filePath);\n    }\n  );\n  return await Promise.all(allStores);\n};\nexport const storeFileHash = async (\n  pathToConfig: string,\n  fileHash: string,\n  filePath: string\n) => {\n  const hashFilePath = await getHashFilePath(pathToConfig);\n  const currentHashes = await getFilePathHashes(pathToConfig);\n  if (currentHashes[fileHash] !== undefined) {\n    return;\n  }\n  await fs.appendFile(hashFilePath, \\u30A7\\xA7{fileHash}=\\xA7{filePath}\\xD8n\\u30A7);\n};\n\nexport const getAllFileTemplates = async (\n  pathToConfig: string,\n  onlyIncludePaths?: string[]\n) => {\n  if (pathToConfig == null) {\n    throw new Error(\"pathToConfig is null in getAllFileTemplates\");\n  }\n  const currentHashes = await getFilePathHashes(pathToConfig);\n  const filePaths = new Set<string>();\n  for (const filePath of Object.values(currentHashes)) {\n    if (onlyIncludePaths?.length > 0) {\n      if (onlyIncludePaths?.includes(filePath)) {\n        filePaths.add(filePath);\n      }\n    } else {\n      filePaths.add(filePath);\n    }\n  }\n  //console.log(\"getAllFileTemplates\");\n  //console.log(\"FILE PATHS\", Array.from(filePaths));\n  const readPromises = Array.from(filePaths).map(async (filePath) => {\n    const data = await fs.readFile(filePath, { encoding: \"utf8\" });\n    return { filePath, data };\n  });\n  const allFiles = await Promise.all(readPromises);\n  //console.log(\"ALL FILES\", allFiles);\n  let allFileTemplates = {};\n  let idx = 1;\n  for (const file of allFiles) {\n    const { filePath, data } = file;\n    const cleanedData = stringCleaning(data);\n    const fileHash = Object.keys(currentHashes).find(\n      (key) => currentHashes[key] === filePath\n    );\n    if (fileHash == null) {\n      throw new Error(\n        \"file hash not found in getAllFileTemplates, it should exist!!\"\n      );\n    }\n    // try with string cleaning\n    const funcPart = argsAndTemplateToFunction([], cleanedData);\n    if (funcPart == null || !(funcPart instanceof Function)) {\n      throw new Error(\n        \"funcPart is null or not a Function type in getAllFileTemplates, it should exist!!\"\n      );\n    }\n    const readableFileHash = fileHash.split(\"_\")[1] + fileHash.split(\"_\")[0];\n    const fileTempl = {};\n    const newKey = \"fileContents\" + idx;\n    fileTempl[newKey] = funcPart;\n    const newTempl = genTemplateWithVars(\n      {\n        [readableFileHash]: () => \\u30A7\\xA7{newKey}\\u30A7,\n      },\n      [newKey]\n    );\n    allFileTemplates = { ...allFileTemplates, ...newTempl, ...fileTempl };\n    idx++;\n  }\n  //console.log(\"ALL FILE TEMPLATES\", allFileTemplates)\n  return allFileTemplates;\n};\nexport const getRawFilePathHashes = async (pathToConfig: string) => {\n  const hashFilePath = await getHashFilePath(pathToConfig);\n  const data = await fs.readFile(hashFilePath, { encoding: \"utf8\" });\n  const lines = data.split(\"\\xD8n\");\n  return lines;\n};\nexport const getFilePathHashes = async (\n  pathToConfig: string\n): Promise<Record<string, string>> => {\n  const lines = await getRawFilePathHashes(pathToConfig);\n  // go from \"hash=file/path/thing.ts\" to {[hash]: \"file/path/thing.ts\"} in one object\n  const cleanLines = uniq(compact(lines));\n  const result = cleanLines.reduce((acc, line) => {\n    const [hash, filePath] = line.split(\"=\");\n    acc[hash] = filePath;\n    return acc;\n  }, {});\n  return result;\n};\nexport const getFilePathFromHash = async (\n  pathToConfig: string,\n  fileHash: string\n) => {\n  const projectDir = await readFromConfig(\"PROJECT_DIR\", pathToConfig);\n  const hashFilePath = path.join(projectDir, \"filePathHashes.txt\");\n  const data = await fs.readFile(hashFilePath, { encoding: \"utf8\" });\n  const lines = data.split(\"\\xD8n\");\n  const result = lines.find((line) => line.includes(fileHash)).split(\"=\")[1];\n  return result;\n};\nexport const getFilePathFromHashes = (\n  hashes: Record<string, string>,\n  fileHash: string\n) => {\n  const result = hashes[fileHash];\n  return result;\n};\nexport const getWordNamesFromWordPaths = (wordPaths: string[]) => {\n  const wordNames = wordPaths.map(\n    (wordPath) => path.basename(wordPath, \".json\").split(\"_\")[1]\n  );\n  return wordNames;\n};\n\nexport const getWordContents = async (wordPath: string) => {\n  const wordContents = await fs.readFile(wordPath, { encoding: \"utf8\" });\n  return wordContents;\n};\n\nexport const sortFilesByLastModified = async (filePaths: string[]) => {\n  const filesWithStats = await Promise.all(\n    filePaths.map(async (file) => {\n      const stats = await fs.stat(file); // Get file stats\n      return { file, mtime: stats.mtime }; // Return file path and modified time\n    })\n  );\n\n  // Sort by last modified date (mtime)\n  filesWithStats.sort((a: any, b: any) => b.mtime - a.mtime); // Most recent first\n\n  // Return sorted file paths\n  return filesWithStats.map((item) => item.file);\n};\n\nexport const getAllWordPathsByLastModified = async (pathToConfig: string) => {\n  const projectDir = await readFromConfig(\"PROJECT_DIR\", pathToConfig);\n  const wordPaths = await getWordJsonFiles(projectDir);\n  return wordPaths;\n};\nasync function getWordJsonFiles(directory) {\n  try {\n    // Read all files from the directory\n    const files = await fs.readdir(directory);\n\n    // Filter files that start with 'word_' and have '.json' extension\n    const wordJsonFiles = files\n      .filter((file) => file.startsWith(\"word_\") && file.endsWith(\".json\"))\n      .map((file) => path.join(directory, file)); // Create full file paths\n\n    return wordJsonFiles;\n  } catch (error) {\n    console.error(\\u30A7Error reading directory: \\xA7{error.message}\\u30A7);\n    throw error; // Re-throw the error to be handled by the caller\n  }\n}\n\nexport const overwriteFile = async (filePath: string, data: string) => {\n  try {\n    await fs\n      .writeFile(filePath, data)\n      .then(() => console.log(\\u30A7File \\xA7{filePath} has been overwritten\\u30A7));\n  } catch (error) {\n    console.error(\\u30A7Error overwriting file: \\xA7{error.message}\\u30A7);\n    throw error;\n  }\n};\n\nexport const getAllGeneratorsExports = async (pathToConfig: string) => {\n  const generatorFilePath = await readFromConfig(\n    \"GENERATOR_FILE\",\n    pathToConfig\n  );\n  const generatorFileContents = await fs.readFile(generatorFilePath, {\n    encoding: \"utf8\",\n  });\n  // this will happen a lot. we'll need a good way to do it. IMO, find the exports via parsing\n  const exportTempl = genTemplateWithVars(\n    {\n      exportDef: () => \\u30A7\\xD8nexport function exportName(\\u30A7,\n    },\n    [\"exportName\"]\n  );\n  const fileTempl = {\n    file: argsAndTemplateToFunction([], stringCleaning(generatorFileContents)),\n  };\n  const parsed = orderedParse(fileTempl, [exportTempl]);\n  //console.log(\"THIS IS PARSED\", parsed);\n  const nameKeys = Object.keys(parsed).filter((k) =>\n    k.startsWith(\"exportName\")\n  );\n  const nameValues = nameKeys.map((k) => parsed[k]());\n  //console.log(\"FOLUND ALL EXPORTS\", nameValues);\n  return nameValues;\n};\n\nexport const getAllTemplateExports = async (pathToConfig: string) => {\n  //console.log(\"get all template exports\");\n  const templateFilePath = await readFromConfig(\"TEMPLATE_FILE\", pathToConfig);\n  const templateFileContents = await fs.readFile(templateFilePath, {\n    encoding: \"utf8\",\n  });\n\n  const exportTempl = genTemplateWithVars(\n    {\n      exportDef: () => \\u30A7\\xD8nexport const exportName = \\u30A7,\n    },\n    [\"exportName\"]\n  );\n  //console.log(\"file contents\", templateFileContents);\n  const fileTempl = {\n    file: argsAndTemplateToFunction([], stringCleaning(templateFileContents)),\n  };\n  //console.log(\"templTHIS IS FILE\", tts(fileTempl, false));\n  const parsed = orderedParse(fileTempl, [exportTempl]);\n  //console.log(\"templTHIS IS PARSED\", parsed);\n  const nameKeys = Object.keys(parsed).filter((k) =>\n    k.startsWith(\"exportName\")\n  );\n  const nameValues = nameKeys.map((k) => stringUnCleaning(parsed[k]()));\n // console.log(\"templFOLUND ALL EXPORTS\", nameValues);\n  return nameValues;\n};\n\nexport const saveRunnableWord = async (pathToConfig: string, word: string) => {\n  const wordPath = await readFromConfig(\"WORDS_FILE\", pathToConfig);\n  const wordContents = await getWordContents(wordPath);\n  const templates = await getAllTemplateExports(pathToConfig);\n  const generators = await getAllGeneratorsExports(pathToConfig);\n  const fullWordContents = \\u30A7\\xA7{wordContents}\\xD8n\\xA7{word}\\u30A7;\n  const importedTemplates = templates.filter((t) =>\n    fullWordContents.includes(t)\n  );\n  const importedGenerators = generators.filter((g) =>\n    fullWordContents.includes(g)\n  );\n  const templatesImport =\n    importedTemplates.length > 0\n      ? \\u30A7import { \\xA7{importedTemplates.join(\",\\xD8n\")} } from \"./template-pool\";\\u30A7\n      : \"\";\n  const generatorsImport =\n    importedGenerators.length > 0\n      ? \\u30A7import { \\xA7{importedGenerators.join(\",\\xD8n\")} } from \"symmetric-parser\";\\u30A7\n      : \"\";\n\n  const otherImports = \\u30A7import flow from 'lodash/flow'\\u30A7;\n\n  const splitOldWord = wordContents.split(otherImports)[1];\n  const wordContentsWithImports = \\u30A7\\xA7{templatesImport}\\xD8n\\xA7{generatorsImport}\\xD8n\\xA7{otherImports}\\xD8n\\xA7{splitOldWord}\\xD8n\\xA7{word}\\u30A7;\n\n  await overwriteFile(wordPath, wordContentsWithImports);\n};\n\nexport const createRunnableGeneratorFileContents = async (\n  pathToConfig: string,\n  generatorString: string,\n  template: string\n): Promise<string> => {\n  const words = await getAllRunnableWords(pathToConfig);\n  const templates = await getAllTemplateExports(pathToConfig);\n  const generators = await getAllGeneratorsExports(pathToConfig);\n\n  const importedTemplates = templates.filter((t) =>\n    generatorString.includes(t)\n  );\n  const importedGenerators = generators.filter((g) =>\n    generatorString.includes(g)\n  );\n  const importedWords = words.filter((w) => generatorString.includes(w));\n  const generalImports = \\u30A7import { buildQueue } from \"./word-pool\";\\u30A7;\n  const templatesImport =\n    importedTemplates.length > 0\n      ? \\u30A7import { \\xA7{importedTemplates.join(\",\\xD8n\")} } from \"./template-pool\";\\xD8n\\u30A7\n      : \"\";\n  const generatorsImport = \\u30A7import {  tts,\\xD8nrun,\\xD8n\\xA7{importedGenerators.join(\n    \",\\xD8n\"\n  )} } from \"symmetric-parser\";\\xD8n\\u30A7;\n  const wordsImport =\n    importedWords.length > 0\n      ? \\u30A7import { \\xA7{importedWords.join(\",\\xD8n\")} } from \"./word-pool\";\\xD8n\\u30A7\n      : \"\";\n\n  const allImports = \\u30A7\\xA7{generalImports}\\xD8n\\xA7{templatesImport}\\xD8n\\xA7{generatorsImport}\\xD8n\\xA7{wordsImport}\\u30A7;\n\n  const templateString = \\u30A7const template = \\xA7{template};\\u30A7;\n  const generatorRun = \\u30A7// @ts-ignore\\xD8nconst result = \\xA7{generatorString};\\xD8nconsole.log(tts(result,false));\\u30A7;\n  return \\u30A7\\xA7{allImports}\\xD8n\\xA7{templateString}\\xD8n\\xA7{generatorRun}\\u30A7;\n};\n\nexport const getAllRunnableWords = async (pathToConfig: string) => {\n  const wordFilePath = await readFromConfig(\"WORDS_FILE\", pathToConfig);\n  const wordFileContents = await fs.readFile(wordFilePath, {\n    encoding: \"utf8\",\n  });\n  const wordTempl = genTemplateWithVars(\n    {\n      wordDef: () => \\u30A7\\xD8nexport const wordName = flow(\\u30A7,\n    },\n    [\"wordName\"]\n  );\n  const fileTempl = {\n    file: argsAndTemplateToFunction([], stringCleaning(wordFileContents)),\n  };\n  let parsed;\n  try {\n    parsed = orderedParse(fileTempl, [wordTempl]);\n  } catch {\n    return [];\n  }\n  //console.log(\"THIS IS PARSED\", parsed);\n  const nameKeys = Object.keys(parsed).filter((k) => k.startsWith(\"wordName\"));\n  const nameValues = nameKeys.map((k) => parsed[k]());\n  //console.log(\"FOLUND ALL WORDS\", nameValues);\n  return nameValues;\n};\n`,\n'fileContents7': () => `\nimport {\n    genTemplateWithVars, recursiveFold\n} from \"symmetric-parser\";\n\n\nexport function parseWords(wordFile: string) {\n  const file = { file: () => wordFile };\n\n  const words = genTemplateWithVars(\n    {\n      wordDef: () =>\n        \\u30A7function word(input: Template): Template {body\\xD8n  return outputName;\\xD8n}\\u30A7,\n    },\n    [\"word\", \"body\", \"outputName\"]\n  );\n\n  const elements = genTemplateWithVars(\n    {\n      element: () => \\u30A7const genOutput = elementName(genInputs);\\xD8n\\u30A7, // very catch-able, be careful\n    },\n    [\"elementName\", \"genInputs\", \"genOutput\"]\n  );\n\n  const of = recursiveFold(\n    file,\n    [words, elements],\n    [],\n    { scope: () => \\u30A7\\xD8n\\u30A7 },\n    \"  \",\n    1\n  );\n  return { ...of.result, ...of.divisors };\n}\n\n\n`,\n'fileContents8': () => `\n// pattern is:\n// if items.length < 26, we use a-z\n\nimport { BuilderGenerator } from \"../hooks/useWordBuilder\";\n\n// if items.length > 26, we use aa, ab, ac, ... az, ba, bb, bc, ... zz\nexport function getHotKeyMapForItems<T>(items: T[]): Map<string, T> {\n  // if doubled, we get 26^2 = 676 options\n  const isDoubled = items.length > 26;\n  let result = new Map<string, T>();\n\n  if (isDoubled) {\n    let master = \"asdfghjklqwertyuiopzxcvbnm\".split(\"\");\n    for (let i = 0; i < items.length; i++) {\n      const first = i < 26 ? i % 26 : Math.floor(i / 26) - 1;\n\n      const second = i % 26;\n\n      const str = master[first] + master[second];\n\n      result.set(str, items[i]);\n    }\n    return result;\n  } else {\n    \"asdfghjklqwertyuiopzxcvbnm\"\n      .split(\"\")\n      .slice(0, items.length)\n      .forEach((key, idx) => {\n        result.set(key, items[idx]);\n      });\n\n    return result;\n  }\n}\n\n// pattern is:\n// index of step + output index\n// so step 0, output 0 is 01 for first output\n// if we have 10 steps, we add a 0 to the front of the first 9\n// ex: 001, 012, 101\n// we will never have more than 9 outputs, god forbid.\n\nexport function getHotkeyMapForOutputItems(\n  steps: BuilderGenerator[],\n  selectedStepIdx: number\n): Map<string, any> {\n  let result = new Map<string, any>();\n  // what's the string length of 10? -> 2.\n  const size = Number(steps.length).toString().length;\n  steps.forEach((step, idx) => {\n    if (idx >= selectedStepIdx) {\n      return;\n    }\n    const outputName = step.outputName;\n    console.log(\"step\", idx, \"padded\", padNumber(size, idx), outputName);\n    result.set(padNumber(size, idx), outputName);\n  });\n  return result;\n}\nfunction padNumber(size, number) {\n  // Convert the number to a string\n  let numberStr = number.toString();\n\n  // Calculate the number of leading zeros needed\n  let zerosNeeded = size - numberStr.length;\n\n  // Pad the number with leading zeros if necessary\n  if (zerosNeeded > 0) {\n    numberStr = \"0\".repeat(zerosNeeded) + numberStr;\n  }\n\n  return numberStr;\n}\nexport function hotKeyToItem<T>(hotKey: string, hotKeys: Map<string, T>) {\n  return hotKeys.get(hotKey);\n}\n\nexport function itemToHotKey<T>(item: T, hotKeys: Map<string, T>) {\n  return [...hotKeys.entries()].find(([key, value]) => value === item)?.[0];\n}\n`,\n'fileContents9': () => `\nimport { collapseTemplateAtKey, genTemplateWithVars, joiner, recursiveFold, replaceWithAllIsomorphic, stringCleaning, stringUnCleaning } from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\nexport function parseTemplates(file: Template) {\n    // need to parse out \\u30A7...\\u30A7\n    const template = genTemplateWithVars(\n      {\n        templateDefinition: () => \\u30A7export const templateName = {templateBody\\xD8n};\\u30A7,\n      },\n      [\"templateName\", \"templateBody\"]\n    );\n    // parsing itself, look at it go!\n    const gendTemplate = genTemplateWithVars(\n      {\n        genTemplate: () =>\n          \\u30A7export const templateName = genTemplateWithVars(\\xD8n  {templateBody},\\xD8n  [genVars]\\xD8n);\\u30A7,\n      },\n      [\"templateName\", \"templateBody\", \"genVars\"]\n    );\n    const fr = recursiveFold(\n      file,\n      [template, gendTemplate], // sort by how specific something is... huh\n      [],\n      { scope: () => \\u30A7\\xD8n\\u30A7 },\n      \"  \",\n      1\n    );\n    //console.log(stringUnCleaning(tts(fr?.result ?? {})));\n    // /console.log(stringUnCleaning(tts(fr?.divisors ?? {})));\n    return { ...fr.result, ...fr.divisors };\n  }\n\n\nconst templateMeta = genTemplateWithVars(\n    {\n      templateDefinition: () =>\n        \\u30A7{ name: \"templateName\", template: { templateBody } },\\u30A7,\n    },\n    [\"templateName\", \"templateBody\"]\n  );\n  \n  const genTemplateMeta = genTemplateWithVars(\n    {\n      genTemplate: () =>\n        \\u30A7{ name: \"templateName\", template: { templateBody }, vars: [genVars] },\\u30A7,\n    },\n    [\"templateName\", \"templateBody\", \"genVars\"]\n  );\n  export function buildTemplateMeta(templateFile: string) {\n    const cleaned = stringCleaning(templateFile);\n    const file = { file: () => cleaned };\n    const parsed = parseTemplates(file);\n  \n    const theMetaIso = replaceWithAllIsomorphic(parsed, [templateMeta]);\n    const theMetaIso2 = replaceWithAllIsomorphic(theMetaIso, [genTemplateMeta]);\n  \n    const collapsed = collapseTemplateAtKey(theMetaIso2, \"templateDefinition\");\n    const theStaticMeta = joiner(collapsed, \"templateDefinition\", \"metas\", \"\\xD8n\");\n    const theGenMeta = joiner(collapsed, \"genTemplate\", \"metas\", \"\\xD8n\");\n  \n    const templatesString = stringUnCleaning(\n      \"[\" + theStaticMeta[\"metas\"]() + \", \" + theGenMeta[\"metas\"]() + \"]\"\n    );\n  \n    return eval(templatesString);\n  }\n  \n  `,\n'fileContents10': () => `\nimport { cloneDeep } from \"lodash\";\n\nexport function setKeyValue(key, value, objInput) {\n    const obj = cloneDeep(objInput);\n    if (Array.isArray(obj)) {\n        obj.forEach(function(element) {\n            setKeyValue(key, value, element);\n        });\n    } else if (typeof obj === 'object' && obj !== null) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                if (prop === key) {\n                    obj[prop] = value;\n                }\n                if (typeof obj[prop] === 'object' && obj[prop] !== null) {\n                    setKeyValue(key, value, obj[prop]);\n                }\n            }\n        }\n    }\n    return obj;\n}`,\n'fileContents14': () => `\nimport { compact } from \"lodash\";\nimport { useEffect, useState } from \"react\";\n\nimport {\n  BuilderGenerator,\n  BuilderNewWord,\n  BuilderTemplate,\n  BuilderWord,\n} from \"./useWordBuilder\";\nimport {  parseWords } from \"../util/parsers/parseWords\";\nimport { parseGenerators } from \"../util/parsers/parseGenerators\";\nimport { buildTemplateMeta } from \"../util/parsers/parseTemplates\";\n\nexport function useMeta({\n  wordsFileText,\n  templatesFileText,\n  generatorsFileText,\n}: {\n  wordsFileText: string;\n  templatesFileText: string;\n  generatorsFileText: string;\n}) {\n  const [wordsMeta, setWordsMeta] = useState<BuilderWord[]>([]);\n  const [templatesMeta, setTemplatesMeta] = useState<BuilderTemplate[]>([]);\n  const [generatorsMeta, setGeneratorsMeta] = useState<BuilderGenerator[]>([]);\n  const [runtimeError, setRuntimeError] = useState<string | null>(null);\n  useEffect(() => {\n    // start with fake, move to ....how do we get from file system.\n    // VS Code API. do that separately?\n    // need to turn input into meta.\n\n    const parsedWords = parseWords(wordsFileText);\n    const parsedGenerators = parseGenerators(generatorsFileText);\n\n    const parsedTemplates = buildTemplateMeta(templatesFileText);\n    console.log(\"PARSEDAND GOOD\", {\n      parsedWords,\n      parsedGenerators,\n      parsedTemplates,\n    });\n\n    // grab all the meta! apply to the objects! go go go!\n    setWordsMeta([\n      {\n        name: \"combineEverything\",\n        steps: [],\n      },\n    ]); \n    setGeneratorsMeta(parsedGenerators);\n    setTemplatesMeta(compact(parsedTemplates));\n  }, [generatorsFileText, templatesFileText, wordsFileText]);\n  return { wordsMeta, templatesMeta, generatorsMeta };\n}\n`,\n'fileContents15': () => `\nimport { useState, useEffect, useCallback } from 'react';\n\nexport const useHotkeys = (hotkeysArray, callback, options = { enabled: true }) => {\n  // State to keep track of key sequences\n  const [keySequence, setKeySequence] = useState('');\n\n  const handleKeyDown = useCallback(\n    (event) => {\n      if (!options.enabled) return;\n\n      if (event.target.tagName === 'INPUT') {\n        return;\n      }\n\n      const key = event.key.toLowerCase();\n\n      // Append the new key to the sequence\n      const newSequence = keySequence + key;\n\n      // Check if the new sequence matches any of the hotkeys in the array\n      const matchedHotkey = hotkeysArray.find((hotkey) => newSequence.endsWith(hotkey));\n\n      if (matchedHotkey) {\n        // Trigger the callback with the matched hotkey\n        callback({key: matchedHotkey});\n        // Reset the sequence\n        setKeySequence('');\n      } else {\n        // Update the sequence with the new key\n        setKeySequence(newSequence);\n      }\n      if(newSequence.length>hotkeysArray[0].length){\n        setKeySequence('');\n      }\n    },\n    [keySequence, hotkeysArray, callback, options.enabled]\n  );\n\n  useEffect(() => {\n    if (options.enabled) {\n      window.addEventListener('keydown', handleKeyDown);\n    }\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown, options.enabled]);\n\n  return {\n    clearSequence: () => setKeySequence(''),\n  };\n};\n\nexport default useHotkeys;\n`,\n'fileContents17': () => `\nimport { tts } from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\nexport function formGeneratorFile(\n  generatorString: string,\n  template: Template,\n  templateModule: any,\n  generatorModule: any\n): string {\n  console.log(\"formGeneratorFile\", templateModule)\n  // future, check if Object.keys etc includes words foundin generatorRun\n  const templates = Object.keys(templateModule).filter(\n    (k) => generatorString.indexOf(k) > -1\n  );\n  const generators = Object.keys(generatorModule).filter(\n    (k) => generatorString.indexOf(k) > -1\n  );\n  const generalImports = \\u30A7import { getQueue, clearQueue } from \"./word-pool\"\n  import { \\xA7{templates.join(\n    \",\\xD8n\"\n  )} } from \"./template-pool\";\\u30A7;\n  const generatorsImport = \\u30A7import { tts,\\xD8nrun,\\xD8n\\xA7{generators.join(\n    \",\\xD8n\"\n  )} } from \"symmetric-parser\";\\u30A7;\n  const templateString = \\u30A7const template = \\xA7{tts(template, false)};\\u30A7;\n  const generatorRun = \\u30A7// @ts-ignore\\xD8nconst result = \\xA7{generatorString};\\xD8nconsole.log(tts(result,false));\\u30A7;\n  return \\u30A7\\xA7{generalImports}\\xD8n\\xA7{generatorsImport}\\xD8n\\xA7{templateString}\\xD8n\\xA7{generatorRun}\\u30A7;\n}\n`,\n'fileContents18': () => `\nimport React, { FC } from 'react';\n\ninterface TreeNode {\n  name: string;\n  value: Function | null;\n  children: { [key: string]: TreeNode };\n}\n\nconst MyComponent: FC = () => {\n  const code = \\u30A7({ \n    'shop1/would1,test1': ({would1, test1})=>\\xD8\\u30A7how \\xD8\\xA7{run(would1, 'would1')} you \\xD8\\xA7{run(test1, 'test1')} this too\\xD8\\u30A7, \n    'would1/something1,something2': ({something1, something2})=>\\xD8\\u30A7\\xD8\\xA7{run(something1,'something1')}\\xD8\\xA7{run(something2,'something2')}\\xD8\\u30A7, \n    'shop2/would2,test2': ({would2, test2})=>\\xD8\\u30A7how \\xD8\\xA7{run(would2, 'would2')} you \\xD8\\xA7{run(test2, 'test2')} this too\\xD8\\u30A7, \n    'shop3/would3,test3': ({would3, test3})=>\\xD8\\u30A7how \\xD8\\xA7{run(would3, 'would3')} you \\xD8\\xA7{run(test3, 'test3')} this too\\xD8\\u30A7, \n    'something1': ()=>\\xD8\\u30A7some value\\xD8\\u30A7, \n    'something2': ()=>\\xD8\\u30A7another one!\\xD8\\u30A7 \n  })\\u30A7;\n\n  // Parse the string into an object\n  const obj: { [key: string]: Function } = new Function(\\u30A7return \\xA7{code}\\u30A7)();\n\n  // Build the tree structure from the keys\n  const buildTree = (obj: { [key: string]: Function }): TreeNode => {\n    const root: TreeNode = { name: 'root', value: null, children: {} };\n\n    Object.entries(obj).forEach(([key, value]) => {\n      const parts = key.split('/');\n      let currentNode = root;\n\n      parts.forEach((part, index) => {\n        if (index < parts.length - 1) {\n          // Intermediate parts, process normally\n          if (!currentNode.children[part]) {\n            currentNode.children[part] = { name: part, value: null, children: {} };\n          }\n          currentNode = currentNode.children[part];\n        } else {\n          // Last part, split by commas\n          const subParts = part.split(',');\n          subParts.forEach((subPart) => {\n            if (!currentNode.children[subPart]) {\n              currentNode.children[subPart] = { name: subPart, value: null, children: {} };\n            }\n            // Assign the function to each subPart node\n            currentNode.children[subPart].value = value;\n          });\n        }\n      });\n      \n\n      // Assign the function to the current node\n      currentNode.value = value;\n    });\n\n    return root;\n  };\n\n  const tree = buildTree(obj);\n\n  // Callback for key click\n  const handleKeyClick = (keyPath: string): void => {\n    console.log('Key clicked:', keyPath);\n  };\n\n  // Callback for badge click\n  const handleBadgeClick = (variableName: string): void => {\n    console.log('Badge clicked:', variableName);\n  };\n\n  // Function to render the function's template string with badges\n  const renderFunction = (func: Function): JSX.Element | null => {\n    const funcStr = func.toString();\n    const templateStringMatch = funcStr.match(/\\u30A7([\\xD8s\\xD8S]*?)\\u30A7/);\n    if (!templateStringMatch) {\n      return null;\n    }\n    const templateString = templateStringMatch[1];\n    const parts = templateString.split(/(\\xD8\\xA7{[^}]+})/g);\n\n    return (\n      <div style={{ marginLeft: '20px' }}>\n        {parts.map((part, index) => {\n          if (part.startsWith('\\xA7{') && part.endsWith('}')) {\n            const runMatch = part.match(/\\xD8\\xA7{run\\xD8([^)]+,\\xD8s*'([^']+)'\\xD8)}/);\n            if (runMatch) {\n              const variableName = runMatch[1];\n              return (\n                <span\n                  key={index}\n                  onClick={() => handleBadgeClick(variableName)}\n                  style={{\n                    border: '1px solid black',\n                    padding: '2px',\n                    borderRadius: '3px',\n                    cursor: 'pointer',\n                    margin: '0 2px',\n                    backgroundColor: '#e0e0e0',\n                  }}\n                >\n                  {variableName}\n                </span>\n              );\n            } else {\n              // Handle other template expressions if needed\n              return part;\n            }\n          } else {\n\n            return part;\n          }\n        })}\n      </div>\n    );\n  };\n\n  // Recursive function to render the tree\n  const renderTree = (\n    node: TreeNode,\n    level: number = 0,\n    keyPath: string[] = []\n  ): JSX.Element[] => {\n    return Object.values(node.children).map((childNode) => {\n      const currentKeyPath = [...keyPath, childNode.name];\n      return (\n        <div key={currentKeyPath.join('/')}>\n          <div\n            style={{ marginLeft: \\u30A7\\xA7{level * 20}px\\u30A7, marginBottom: '5px' }}\n          >\n            <span\n              onClick={() => handleKeyClick(currentKeyPath.join('/'))}\n              style={{\n                color: 'blue',\n                textDecoration: 'underline',\n                cursor: 'pointer',\n              }}\n            >\n              {childNode.name}\n            </span>\n            {childNode.value && <div>{renderFunction(childNode.value)}</div>}\n          </div>\n          {renderTree(childNode, level + 1, currentKeyPath)}\n        </div>\n      );\n    });\n  };\n\n  return <div>{renderTree(tree)}</div>;\n};\n\nexport default MyComponent;\n`,\n'fileContents19': () => `\nimport React, { useState } from \"react\";\nexport const WordCreator = ({\n    createNewWord\n}: {\n    createNewWord: (wordName: string) => void;\n}) => {\n    const [newWordName, setNewWordName] = React.useState<string>(\"\");\n\n  return (\n    <>\n      <input\n        type=\"text\"\n        value={newWordName}\n        onChange={(e) => setNewWordName(e.target.value)}\n      />\n      <button onClick={() => createNewWord(newWordName)}>Create Word</button>\n    </>\n  );\n};\n`,\n'fileContents20': () => `\nimport React from \"react\";\nimport {\n  BuilderGenerator,\n  BuilderTemplate,\n  BuilderWord,\n  Types,\n  useWordBuilder,\n} from \"../hooks/useWordBuilder\";\nimport { FocusableElements } from \"./BuilderAccordion\";\n\nimport Typography from \"@mui/joy/Typography\";\nimport { Card } from \"@mui/joy\";\nimport ClearIcon from \"@mui/icons-material/Clear\";\nimport DynamicForm from \"./DynamicForm\";\nimport { useForm } from \"react-hook-form\";\nimport Chip from \"@mui/joy/Chip\";\nimport { useHotkeys } from \"../hooks/useHotkeys\";\nimport {\n  getHotkeyMapForOutputItems,\n  hotKeyToItem,\n  itemToHotKey,\n} from \"../util/hotKeyBuilder\";\n\nexport const WordEditorCard = ({\n  name,\n  inputs,\n  inputSchema,\n  outputName,\n  hotkeys,\n  setFocusedElement,\n  idx,\n  outputHotkey,\n  showOutputHotkey,\n  setFocusedStepIdx,\n  outputHotkeys,\n  removeStepFromWord,\n  templatesMeta,\n  formObject,\n  formKeyPrefix,\n  steps,\n}: {\n  name: string;\n  inputs?: Record<string, any>;\n  inputSchema: Record<string, Types>;\n  outputName?: string;\n  hotkeys: Map<string, any>;\n  setFocusedElement: (val: FocusableElements) => void;\n  idx: number;\n  outputHotkey: string;\n  showOutputHotkey: boolean;\n  setFocusedStepIdx: (idx: number) => void;\n  outputHotkeys: Map<string, any>;\n  removeStepFromWord: (idx: number) => void;\n  templatesMeta: BuilderTemplate[];\n  formObject: any; // really, the react-hook-form object\n  formKeyPrefix: string;\n  steps: BuilderGenerator[];\n}) => {\n  //  console.log(\"RENDERING\", name, inputs, outputs);\n  const registerWithPrefix = (key: string) => {\n    return formObject.register(\\u30A7\\xA7{formKeyPrefix}.\\xA7{key}\\u30A7);\n  };\n  console.log(\"FORM OBJECT\", formObject);\n  // we'll need to parse the input schema to determine what to put in the form\n  return (\n    <div\n      style={{\n        border: \"1px solid black\",\n        padding: \"10px\",\n        margin: \"10px\",\n      }}\n    >\n      <div\n        style={{\n          display: \"flex\",\n          flexDirection: \"row\",\n          gap: \"10px\",\n        }}\n      >\n        <span style={{ cursor: \"pointer\" }}>\n          <ClearIcon fontSize=\"small\" onClick={() => removeStepFromWord(idx)} />\n        </span>\n        <Typography level=\"body-xs\">{name}</Typography>\n      </div>\n      <DynamicForm\n        schema={inputSchema}\n        steps={steps}\n        stepIdx={idx}\n        hotkeys={hotkeys}\n        outputHotkeys={outputHotkeys}\n        setFocusedElement={setFocusedElement}\n        setFocusedStepIdx={() => setFocusedStepIdx(idx)}\n        templatesMeta={templatesMeta}\n        formObject={formObject}\n        formKeyPrefix={formKeyPrefix}\n      />\n      <div\n        style={{\n          display: \"flex\",\n          flexDirection: \"row\",\n          gap: \"10px\",\n        }}\n      >\n        <Typography level=\"body-xs\">Outputs</Typography>\n        <Chip variant=\"outlined\" color=\"primary\" size=\"sm\">\n          {outputName} {showOutputHotkey && <>| {outputHotkey}</>}\n        </Chip>\n      </div>\n    </div>\n  );\n};\nexport const WordBuilderForm = ({\n  stepHotKeys,\n  wordsMeta,\n  templatesMeta,\n  generatorsMeta,\n  setFocusedElement,\n  setFocusedWord,\n  templateHotKeys,\n  wordIdx,\n  focusedWord,\n  isStepHotKeysEnabled,\n  isTemplateHotKeysEnabled,\n  postMessage\n}: {\n  stepHotKeys: Map<string, any>;\n  wordsMeta: BuilderWord[];\n  templatesMeta: BuilderTemplate[];\n  generatorsMeta: BuilderGenerator[];\n  setFocusedElement: (val: FocusableElements) => void;\n  setFocusedWord: (val: number) => void;\n  templateHotKeys: Map<string, any>;\n  wordIdx: number;\n  focusedWord: number;\n  isStepHotKeysEnabled: boolean;\n  isTemplateHotKeysEnabled: boolean;\n  postMessage:any;\n}) => {\n  const {\n    newWord,\n    runtimeError,\n    addStepToWord,\n    updateStepPosition,\n    runWord,\n    removeStepFromWord,\n    submitWord,\n  } = useWordBuilder({ wordsMeta, templatesMeta, generatorsMeta, postMessage });\n  const isFocused = wordIdx === focusedWord;\n  useHotkeys(\n    Array.from(stepHotKeys.keys()),\n    (event) =>\n      addStepToWord(hotKeyToItem(event.key, stepHotKeys), newWord.steps.length),\n    { enabled: isFocused && isStepHotKeysEnabled }\n  );\n  const [focusedStepIdx, setFocusedStepIdx] = React.useState(null);\n  function onSubmit(results) {\n    console.log(\"submit\", results, \"steps\", steps);\n    submitWord(results);\n  }\n  const outputTemplateHotkeys = getHotkeyMapForOutputItems(\n    newWord.steps,\n    focusedStepIdx\n  );\n  const formObject = useForm();\n  const { handleSubmit } = formObject;\n  const { steps } = newWord;\n\n  return (\n    <div onClick={() => setFocusedWord(wordIdx)}>\n      Word Builder\n      <form onSubmit={handleSubmit(onSubmit)}>\n        <label style={{fontSize: \"12px\"}}>\n          Word name\n          <input type=\"text\" {...formObject.register(\"wordName\")} />\n        </label>\n        <br />\n        {steps.map((step, idx) => (\n          <WordEditorCard\n            {...step}\n            steps={steps}\n            hotkeys={templateHotKeys}\n            setFocusedElement={setFocusedElement}\n            idx={idx}\n            outputHotkeys={outputTemplateHotkeys}\n            outputHotkey={itemToHotKey(step.outputName, outputTemplateHotkeys)}\n            showOutputHotkey={\n              isTemplateHotKeysEnabled &&\n              itemToHotKey(step.outputName, outputTemplateHotkeys) != null\n            }\n            setFocusedStepIdx={setFocusedStepIdx}\n            removeStepFromWord={removeStepFromWord}\n            templatesMeta={templatesMeta}\n            formObject={formObject}\n            formKeyPrefix={step.outputName}\n          />\n        ))}\n        <button type=\"submit\">Submit</button>\n      </form>\n    </div>\n  );\n};\n`,\n'fileContents21': () => `\nimport React, { useEffect, useState } from \"react\";\nimport {\n  getDescendentsOfKey,\n  rs,\n  rsCompact,\n  tts,\n  sortTemplateByDeps,\n  genTemplateWithVars,\n  argsAndTemplateToFunction,\n  multiply,\n} from \"symmetric-parser\";\n\nimport { useTemplate, WordStep } from \"../hooks/useTemplate\";\nimport { Panel, PanelGroup, PanelResizeHandle } from \"react-resizable-panels\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { useRunner } from \"../hooks/useRunner\";\nimport { compact, last } from \"lodash\";\n\nexport type WordDefinition = {\n  name: string;\n  wordSteps: WordStep[];\n  meta?: Record<string, any>;\n  subTemplate?: Template;\n};\n\nconst FAVORITE_GENERATORS = [\"orderedParse\", \"nestedParse\"];\nconst COMMON_CHARS = [\n  { name: \"comma\", value: \",\" },\n  { name: \"newline\", value: \"\\xD8n\" },\n];\nexport const TemplateEditors = ({\n  templateDefinitions,\n  postMessage,\n  configPath,\n  filledGeneratorsFileText,\n  templateModule,\n  allFileTemplates,\n  runnableWords,\n}: {\n  templateDefinitions: WordDefinition[];\n  postMessage: any;\n  configPath: string;\n  filledGeneratorsFileText: string;\n  templateModule: any;\n  allFileTemplates: Template;\n  runnableWords: string[];\n}) => {\n  const {\n    generatorModule,\n    wordModule,\n    addToTemplatePool,\n    addToFilledGeneratorPool,\n    filledGenerators,\n    handleSaveAllFiles,\n    addFullTemplateToPool,\n  } = useRunner(postMessage, configPath, filledGeneratorsFileText);\n\n  const [stepsForPanel, setStepsForPanel] = useState<\n    Record<string, WordStep[]>\n  >({});\n\n  return (\n    <div>\n      <PanelGroup direction=\"horizontal\">\n        {templateDefinitions.map((def, i) => {\n          const generatorsTemplate = def.meta?.generators ?? {};\n\n          return (\n            <>\n              <TemplateEditor\n                definition={def}\n                templateModule={templateModule}\n                generatorModule={generatorModule}\n                generatorsTemplate={generatorsTemplate}\n                wordModule={wordModule}\n                setStepsForPanel={setStepsForPanel}\n                runnableSteps={filledGenerators}\n                addToTemplatePool={addToTemplatePool}\n                postMessage={postMessage}\n                addToFilledGeneratorPool={addToFilledGeneratorPool}\n                isMainEditor={i === 0}\n                handleSaveAllFiles={handleSaveAllFiles}\n                allFileTemplates={allFileTemplates}\n                runnableWords={runnableWords}\n                addFullTemplateToPool={addFullTemplateToPool}\n              />\n            </>\n          );\n        })}\n      </PanelGroup>\n      <div>\n        {Object.keys(stepsForPanel)?.map((k) => {\n          //console.log(\"steps for panel\", stepsForPanel, k, stepsForPanel?.[k]);\n          return (\n            <div>\n              Tree: {k}{\" \"}\n              {stepsForPanel?.[k]?.map((step) => {\n                return <div>{step.name}---[result]</div>;\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\n// THAT TEMPLATE BETTER BE SORTED or we could sort it idk\nconst filterTemplateToKey = (input: Template, rootKey: string) => {\n  const family = getDescendentsOfKey(rootKey, input, true);\n  const newTemplate = {};\n  family.forEach((key) => {\n    newTemplate[key] = input[key];\n  });\n  return sortTemplateByDeps(newTemplate);\n};\n\nfunction getGeneratorSignatureFromKey(\n  key: string,\n  generatorsTemplate: Template\n) {\n  for (const v of Object.values(generatorsTemplate)) {\n    const str = v();\n    if (str.indexOf(key + \"(\") === 0) {\n      return str;\n    }\n  }\n}\n\nexport const TemplateEditor = ({\n  definition,\n  templateModule,\n  generatorModule,\n  wordModule,\n  setStepsForPanel,\n  generatorsTemplate,\n  runnableSteps,\n  addToTemplatePool,\n  postMessage,\n  addToFilledGeneratorPool,\n  isMainEditor,\n  handleSaveAllFiles,\n  allFileTemplates,\n  runnableWords,\n  addFullTemplateToPool,\n}: {\n  definition: WordDefinition;\n  templateModule: any;\n  generatorModule: any;\n  wordModule: any;\n  setStepsForPanel: any;\n  generatorsTemplate: Template;\n  runnableSteps: Template;\n  addToTemplatePool: (name: string, template: string, args: string[]) => void;\n  postMessage: any;\n  addToFilledGeneratorPool: (filledGenerator: Template) => void;\n  isMainEditor: boolean;\n  handleSaveAllFiles: (template: Template) => void;\n  allFileTemplates: Template;\n  runnableWords: string[];\n  addFullTemplateToPool: (name: string, template: Template) => void;\n}) => {\n  const {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n    handleConvertWordSteps,\n    handleRunnableWordClick,\n    handleTransition,\n  } = useTemplate(\n    definition,\n    templateModule,\n    generatorModule,\n    wordModule,\n    postMessage,\n    isMainEditor\n  );\n  const {subTemplate} = definition;\n  const [insertMode, setInsertMode] = React.useState(false);\n  const [insertToKey, setInsertToKey] = React.useState(\"\");\n\n  useEffect(() => {\n    setStepsForPanel((prev) => ({ ...prev, [definition.name]: wordSteps }));\n  }, [wordSteps]);\n\n  const [filteredTemplates, setFilteredTemplates] = useState(compact([subTemplate??null]));\n  useEffect(() => {\n    setFilteredTemplates(compact([subTemplate??null]));\n  }, [subTemplate]);\n  function handleOpenFilter(key: string) {\n    const newFilteredTemplates = [\n      ...filteredTemplates,\n      filterTemplateToKey(template, key),\n    ];\n    setFilteredTemplates(newFilteredTemplates);\n  }\n  function handleRemoveKey(key: string) {\n    removeKey(key);\n  }\n  function handleClosePanel(idx: number) {\n    const newFilteredTemplates = [...filteredTemplates];\n    newFilteredTemplates.splice(idx, 1);\n    setFilteredTemplates(newFilteredTemplates);\n  }\n  function handleRunStep(stepString: string) {\n    applyGeneratorString(stepString);\n  }\n  function handleTemplateClick(templateName: string) {\n    const newTemplate = templateModule[templateName] ?? {\n      [templateName]: allFileTemplates[templateName],\n    };\n    if (newTemplate == null) {\n      throw new Error(\n        \"template not found in templateModule or allFileTemplates\"\n      );\n    }\n    if (!insertMode) {\n      insertTemplateIntoTemplate(newTemplate);\n    } else if (insertMode) {\n      insertTemplateIntoTemplateAtKey(newTemplate, insertToKey);\n    }\n  }\n  function handleGeneratorClick(generatorName: string) {\n    // create the insertion template based off name, finding it in generators string, etc\n    const genTempl = genTemplateWithVars(\n      {\n        step: () => \\u30A7\\xA7{generatorName}(template, genArgs)\\u30A7,\n      },\n      [\"genArgs\"]\n    );\n    if (!insertMode) {\n      insertTemplateIntoTemplate(genTempl);\n    } else if (insertMode) {\n      insertTemplateIntoTemplateAtKey(genTempl, insertToKey);\n    }\n  }\n  function handleAddDefinition(key: string, value: string) {\n    const funcPart = argsAndTemplateToFunction([], value);\n    const newTemplate = { [key]: funcPart };\n    if (insertMode) {\n      insertTemplateIntoTemplateAtKey(newTemplate, insertToKey);\n    } else {\n      insertTemplateIntoTemplate(newTemplate);\n    }\n  }\n\n  function handleAddSkeleton(key: string, value: string, args: string[]) {\n    const funcPart = argsAndTemplateToFunction([], value);\n    const templ = { [key]: funcPart };\n    const newTemplate = genTemplateWithVars(templ, args);\n    addToTemplatePool(key, value, args);\n    insertTemplateIntoTemplate(newTemplate);\n  }\n\n  function handleInsertTemplateName(value: string) {\n    const funcPart = argsAndTemplateToFunction([], value);\n    insertTemplateIntoTemplateAtKey({ templateName: funcPart }, insertToKey);\n  }\n\n  function handleRunnableWordNameClick(key: string) {\n    const funcPart = argsAndTemplateToFunction([], key);\n    insertTemplateIntoTemplateAtKey({ templateName: funcPart }, insertToKey);\n  }\n\n  function handleSaveIsolatedTemplate(name: string, template: Template) {\n    addFullTemplateToPool(name, template);\n  }\n\n  const templates = [template, ...filteredTemplates];\n  return (\n    <>\n      {templates.map((template, i) => {\n        return (\n          <>\n            <SkeletonPanel\n              handleTemplateClick={handleTemplateClick}\n              templateModule={templateModule}\n              generatorModule={generatorModule}\n              handleGeneratorClick={handleGeneratorClick}\n              handleAddDefinition={handleAddDefinition}\n              handleAddSkeleton={handleAddSkeleton}\n              generatorsTemplate={generatorsTemplate}\n              runnableSteps={runnableSteps}\n              handleRunStep={handleRunStep}\n              handleTemplateNameClick={handleInsertTemplateName}\n              allFileTemplates={allFileTemplates}\n              runnableWords={runnableWords}\n              handleRunnableWordClick={handleRunnableWordClick}\n              handleRunnableWordNameClick={handleRunnableWordNameClick}\n            />\n            <Panel\n              defaultSize={30}\n              minSize={20}\n              style={{ overflowX: \"scroll\" }}\n            >\n              {isMainEditor && (\n                <button onClick={handleTransition}>RUN TRANSITION</button>\n              )}\n              <h3 style={{ color: \"black\" }}>{definition.name}</h3>{\" \"}\n              <button\n                onClick={() => {\n                  handleConvertWordSteps();\n                }}\n              >\n                Convert wordSteps\n              </button>\n              {i > 0 && (\n                <button onClick={() => handleClosePanel(i - 1)}>Close</button>\n              )}\n              <TemplateTree\n                template={template}\n                addKeyToNumerator={addKeyToNumerator}\n                addKey={addKey}\n                handleOpenFilter={handleOpenFilter}\n                insertMode={insertMode}\n                setInsertMode={setInsertMode}\n                insertToKey={insertToKey}\n                setInsertToKey={setInsertToKey}\n                handleRemoveKey={handleRemoveKey}\n                handleSaveAllFiles={handleSaveAllFiles}\n                handleSaveIsolatedTemplate={handleSaveIsolatedTemplate}\n              />\n              <button\n                onClick={() =>\n                  addToFilledGeneratorPool(\n                    multiply(sortTemplateByDeps(template), {})\n                  )\n                }\n              >\n                SAVE step1\n              </button>\n            </Panel>\n            <PanelResizeHandle\n              style={{ border: \"1px solid black\", marginRight: \"6px\" }}\n            />\n          </>\n        );\n      })}\n    </>\n  );\n};\nexport const SkeletonPanel = ({\n  templateModule,\n  generatorModule,\n  handleTemplateClick,\n  handleAddDefinition,\n  handleAddSkeleton,\n  handleGeneratorClick,\n  generatorsTemplate,\n  runnableSteps,\n  handleRunStep,\n  handleTemplateNameClick,\n  allFileTemplates,\n  runnableWords,\n  handleRunnableWordClick,\n  handleRunnableWordNameClick,\n}: {\n  templateModule: any;\n  generatorModule: any;\n  handleTemplateClick: (templateName: string) => void;\n  handleAddDefinition: (key: string, value: string) => void;\n  handleAddSkeleton: (key: string, value: string, args: string[]) => void;\n  handleGeneratorClick: (generatorName: string) => void;\n  generatorsTemplate: Template;\n  runnableSteps: Template;\n  handleRunStep: any;\n  handleTemplateNameClick: (key: string) => void;\n  allFileTemplates: Template;\n  runnableWords: string[];\n  handleRunnableWordClick: (key: string) => void;\n  handleRunnableWordNameClick: (key: string) => void;\n}) => {\n  if (templateModule == null) return <div>loading templates...</div>;\n  const [defKeyName, setDefKeyName] = useState(\"\");\n  const [defValue, setDefValue] = useState(\"\");\n  const [lastClickedGenerator, setLastClickedGenerator] = useState(\"\");\n  //console.log(\"WHAT IS TEMPLATE MODULE HERE\", templateModule);\n  //console.log(\"is it null?\", generatorModule);\n  return (\n    <Panel defaultSize={20} minSize={20} style={{ overflowX: \"scroll\" }}>\n      <div>\n        <input\n          value={defKeyName}\n          onChange={(e) => setDefKeyName(e.target.value)}\n          placeholder=\"key\"\n        />\n        <input\n          value={defValue}\n          onChange={(e) => setDefValue(e.target.value)}\n          placeholder=\"value\"\n        />\n        <button\n          onClick={() => {\n            handleAddDefinition(defKeyName, defValue);\n            setDefKeyName(\"\");\n            setDefValue(\"\");\n          }}\n        >\n          Add Definition\n        </button>\n      </div>\n\n      {Object.keys(runnableSteps)?.map((rs) => {\n        //console.log(\"HERE WE ARE WITH RUNNABLE STEPS\", rs.toString(), rs);\n        const full = runnableSteps[rs]();\n        return (\n          <div\n            style={{\n              cursor: \"pointer\",\n              color: \"blue\",\n              textDecoration: \"underline\",\n            }}\n            onClick={() => handleRunStep(full)}\n          >\n            {full}\n          </div>\n        );\n      })}\n      <div style={{ color: \"black\" }}>Runnable Words:</div>\n      {runnableWords.map((k) => {\n        return (\n          <div>\n            <span\n              style={{\n                cursor: \"pointer\",\n                color: \"blue\",\n                textDecoration: \"underline\",\n              }}\n              onClick={() => handleRunnableWordClick(k)}\n            >\n              {k}\n            </span>\n            <span\n              onClick={() => handleRunnableWordNameClick(k)}\n              style={{\n                width: \"8px\",\n                height: \"8px\",\n                padding: \"0px\",\n                border: \"1px solid black\",\n                backgroundColor: \"#eee\",\n                color: \"black\",\n                cursor: \"pointer\",\n              }}\n            >\n              N\n            </span>\n          </div>\n        );\n      })}\n      <div style={{ color: \"black\" }}>Common:</div>\n      {COMMON_CHARS.map((k) => {\n        return (\n          <div\n            style={{\n              cursor: \"pointer\",\n              color: \"blue\",\n              textDecoration: \"underline\",\n            }}\n            onClick={() => {\n              handleAddDefinition(k.name, k.value);\n            }}\n          >\n            {k.name}\n          </div>\n        );\n      })}\n\n      <div style={{ color: \"black\" }}>Templates:</div>\n      {Object.keys(templateModule)?.map((k) => {\n        return (\n          <div>\n            <span\n              style={{\n                cursor: \"pointer\",\n                color: \"blue\",\n                textDecoration: \"underline\",\n              }}\n              onClick={() => handleTemplateClick(k)}\n            >\n              {k}\n            </span>\n            <span\n              onClick={() => handleTemplateNameClick(k)}\n              style={{\n                width: \"8px\",\n                height: \"8px\",\n                padding: \"0px\",\n                border: \"1px solid black\",\n                backgroundColor: \"#eee\",\n                color: \"black\",\n                cursor: \"pointer\",\n              }}\n            >\n              N\n            </span>\n          </div>\n        );\n      })}\n\n      <div style={{ color: \"black\" }}>File Templates:</div>\n      {Object.keys(allFileTemplates)?.map((k) => {\n        return (\n          <div>\n            <span\n              style={{\n                cursor: \"pointer\",\n                color: \"blue\",\n                textDecoration: \"underline\",\n              }}\n              onClick={() => handleTemplateClick(k)}\n            >\n              {k}\n            </span>\n            <span\n              onClick={() => handleTemplateNameClick(k)}\n              style={{\n                width: \"8px\",\n                height: \"8px\",\n                padding: \"0px\",\n                border: \"1px solid black\",\n                backgroundColor: \"#eee\",\n                color: \"black\",\n                cursor: \"pointer\",\n              }}\n            >\n              N\n            </span>\n          </div>\n        );\n      })}\n      <div style={{ color: \"black\" }}>Generators</div>\n      {lastClickedGenerator != null && (\n        <div style={{ color: \"red\", textDecoration: \"none\" }}>\n          {getGeneratorSignatureFromKey(\n            lastClickedGenerator,\n            generatorsTemplate\n          )}\n        </div>\n      )}\n      {FAVORITE_GENERATORS.map((k) => {\n        return (\n          <div\n            style={{\n              cursor: \"pointer\",\n              color: \"blue\",\n              textDecoration: \"underline\",\n            }}\n            onClick={() => {\n              handleGeneratorClick(k);\n              setLastClickedGenerator(k);\n            }}\n          >\n            {k}\n          </div>\n        );\n      })}\n\n      {Object.keys(generatorModule)\n        ?.sort()\n        ?.map((k) => {\n          return (\n            <div\n              style={{\n                cursor: \"pointer\",\n                color: \"blue\",\n                textDecoration: \"underline\",\n              }}\n              onClick={() => {\n                handleGeneratorClick(k);\n                setLastClickedGenerator(k);\n              }}\n            >\n              {k}{\" \"}\n            </div>\n          );\n        })}\n    </Panel>\n  );\n};\n// EXPECTS A SORTED input TEMPLATE\nexport const TemplateTree = ({\n  template,\n  addKeyToNumerator,\n  addKey,\n  handleOpenFilter,\n  handleRemoveKey,\n  insertMode,\n  setInsertMode,\n  insertToKey,\n  setInsertToKey,\n  handleSaveAllFiles,\n  handleSaveIsolatedTemplate,\n}: {\n  addKey: any;\n  addKeyToNumerator: any;\n  template: Template;\n  handleOpenFilter: any;\n  handleRemoveKey: any;\n  insertMode: boolean;\n  setInsertMode: any;\n  insertToKey: string;\n  setInsertToKey: any;\n  handleSaveAllFiles: (template: Template) => void;\n  handleSaveIsolatedTemplate: (name: string, template: Template) => void;\n}) => {\n  const [compiledTemplate, setCompiledTemplate] = React.useState(\"\");\n  const [collapsedSet, setCollapsedSet] = React.useState(new Set<string>());\n  const [hiddenSet, setHiddenSet] = React.useState(new Set<string>());\n  const indentHash = new Map<string, number>();\n\n  function handleRsClick(arg: string) {\n    addKey(arg);\n  }\n  const handleNumeratorClick = (numerator: string) => {\n    if (insertMode) {\n      if (numerator !== insertToKey) {\n        addKeyToNumerator(numerator, insertToKey);\n      } else {\n        setInsertMode(false);\n        setInsertToKey(\"\");\n      }\n    } else {\n      setInsertMode(true);\n      setInsertToKey(numerator);\n    }\n  };\n  //console.log(\"TEMPLATE\", template);\n  const handleCompile = () => {\n    setCompiledTemplate(tts(template));\n  };\n\n  const handleCollapse = (key: string) => {\n    const allChildren = getDescendentsOfKey(key, template, false);\n    const newCollapsedSet = new Set(collapsedSet);\n    const newHiddenSet = new Set(hiddenSet);\n    if (collapsedSet.has(key)) {\n      newCollapsedSet.delete(key);\n      allChildren.forEach((child) => {\n        newHiddenSet.delete(child);\n      });\n    } else {\n      newCollapsedSet.add(key);\n      allChildren.forEach((child) => {\n        newHiddenSet.add(child);\n      });\n    }\n\n    setHiddenSet(newHiddenSet);\n    setCollapsedSet(newCollapsedSet);\n  };\n  function handleSaveTemplate(name: string) {\n    handleSaveIsolatedTemplate(name, template);\n  }\n  //console.log(\"TEMPLATE TREE TEMPLATE\", template)\n  return (\n    <div>\n      <button onClick={() => handleSaveAllFiles(template)}>\n        Save All Files\n      </button>\n      <div>\n        <IsolatedTemplateSaver handleSave={handleSaveTemplate} />\n      </div>\n      {Object.keys(template)?.map((k, i) => {\n        const denoms = k.split(\"/\")[1]?.split(\",\");\n\n        const numerator = k.split(\"/\")[0];\n        const indentionMultiplier = indentHash.get(numerator) ?? 0;\n        denoms?.forEach((d) => {\n          indentHash.set(d, indentionMultiplier + 1);\n        });\n\n        const peekTreeNodes = denoms?.map((d) => {\n          if (template[d] != null) {\n            // we have a non-denom key, need to display and extra TreeNode while giving it the proper indentation\n            return (\n              <TreeNode\n                tKey={d}\n                indentionMultiplier={indentionMultiplier + 1}\n                insertMode={insertMode}\n                insertToKey={insertToKey}\n                hiddenSet={hiddenSet}\n                handleCollapse={handleCollapse}\n                handleNumeratorClick={handleNumeratorClick}\n                collapsedSet={collapsedSet}\n                template={template}\n                handleRsClick={handleRsClick}\n                denoms={denoms}\n                handleOpenFilter={handleOpenFilter}\n                handleRemoveKey={handleRemoveKey}\n              />\n            );\n          } else {\n            return null;\n          }\n        });\n\n        return (\n          <>\n            <TreeNode\n              tKey={k}\n              indentionMultiplier={indentionMultiplier}\n              insertMode={insertMode}\n              insertToKey={insertToKey}\n              hiddenSet={hiddenSet}\n              handleCollapse={handleCollapse}\n              handleNumeratorClick={handleNumeratorClick}\n              collapsedSet={collapsedSet}\n              template={template}\n              handleRsClick={handleRsClick}\n              denoms={denoms}\n              handleOpenFilter={handleOpenFilter}\n              handleRemoveKey={handleRemoveKey}\n            />\n            {peekTreeNodes?.map((node) => node)}\n          </>\n        );\n      })}\n\n      <button onClick={handleCompile}>Compile</button>\n      {compiledTemplate !== \"\" && (\n        <pre style={{ color: \"black\", fontSize: \"12px\" }}>\n          {compiledTemplate}\n        </pre>\n      )}\n    </div>\n  );\n};\nconst IsolatedTemplateSaver = ({\n  handleSave,\n}: {\n  handleSave: (name: string) => void;\n}) => {\n  const [name, setName] = useState(\"\");\n  return (\n    <>\n      <input\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        placeholder=\"Isolated Template Name\"\n      ></input>\n      <button onClick={() => handleSave(name)}>Save Templ</button>\n    </>\n  );\n};\nconst TreeNode = ({\n  tKey,\n  insertMode,\n  hiddenSet,\n  handleCollapse,\n  insertToKey,\n  handleNumeratorClick,\n  collapsedSet,\n  template,\n  handleRsClick,\n  denoms,\n  indentionMultiplier,\n  handleOpenFilter,\n  handleRemoveKey,\n}) => {\n  const numerator = tKey.split(\"/\")[0];\n\n  const clickableNumeratorColor = insertMode ? \"blue\" : \"green\";\n  return (\n    <div\n      style={{\n        marginLeft: \\u30A7\\xA7{denoms != null ? indentionMultiplier * 15 : 0}px\\u30A7,\n        display: hiddenSet.has(tKey) ? \"none\" : \"block\",\n      }}\n    >\n      <button onClick={() => handleCollapse(tKey)}>C</button>\n      <span\n        style={{\n          color: insertToKey === numerator ? \"black\" : clickableNumeratorColor,\n          textDecoration: insertToKey === numerator ? \"\" : \"underline\",\n          cursor: \"pointer\",\n        }}\n        onClick={() => handleNumeratorClick(numerator)}\n      >\n        {numerator}\n      </span>\n      <button onClick={() => handleOpenFilter(tKey)}>I</button>\n      <button\n        style={{ marginLeft: \"14px\" }}\n        onClick={() => handleRemoveKey(tKey)}\n      >\n        R\n      </button>\n\n      {collapsedSet.has(tKey) ? (\n        <span\n          onClick={() => handleCollapse(tKey)}\n          style={{\n            cursor: \"pointer\",\n            color: \"blue\",\n            textDecoration: \"underline\",\n            marginLeft: \"3px\",\n          }}\n        >\n          . . .\n        </span>\n      ) : (\n        renderPart(template[tKey].toString(), handleRsClick)\n      )}\n    </div>\n  );\n};\n\nfunction nakedPartToString(part: string) {\n  if (part.includes(\"\\u30A7\")) {\n    return part.substring(part.indexOf(\"\\u30A7\") + 1, part.lastIndexOf(\"\\u30A7\"));\n  } else {\n    return part.substring(part.indexOf('\"') + 1, part.lastIndexOf('\"'));\n  }\n}\n\nfunction rsToArg(rs: string) {\n  //    return \\u30A7\\xD8\\xA7{run(\\xA7{v},'\\xA7{v}')}\\u30A7;\n  return rs.substring(rs.indexOf(\"(\") + 1, rs.indexOf(\",\"));\n}\nfunction renderPart(part: string, handleRsClick: (arg: string) => void) {\n  const args = part\n    .substring(part.indexOf(\"{\") + 1, part.indexOf(\"}\"))\n    .split(\",\")\n    .map((arg) => arg.trim());\n  const compactRs = args.map((arg) => rsCompact(arg));\n  const nonCompactRs = args.map((arg) => rs(arg));\n  const doubleQuotedCompactRs = compactRs.map((crs) =>\n    crs.replaceAll(\"'\", '\"')\n  );\n  const doubleQuotedNonCompactRs = nonCompactRs.map((ncrs) =>\n    ncrs.replaceAll(\"'\", '\"')\n  );\n  const allRs = [\n    ...compactRs,\n    ...nonCompactRs,\n    ...doubleQuotedCompactRs,\n    ...doubleQuotedNonCompactRs,\n  ];\n  let funcPart = part.substring(part.indexOf(\"\\u30A7\") + 1, part.lastIndexOf(\"\\u30A7\"));\n  const parts = funcPart.split(/(\\xD8\\xA7{[^}]+})/g);\n  if (parts.length === 1) {\n    return (\n      <div style={{ color: \"red\", padding: \"0px 5px\" }}>\n        {nakedPartToString(part)}\n      </div>\n    );\n  }\n  let finalParts = [];\n  parts.forEach((part, index) => {\n    if (allRs.includes(part)) {\n      const arg = rsToArg(part);\n      finalParts.push(\n        <span\n          style={{\n            color: \"purple\",\n            cursor: \"pointer\",\n            margin: \"0px 2px\",\n            border: \"1px solid black\",\n            backgroundColor: \"#eee\",\n            padding: \"0px 2px\",\n          }}\n          onClick={() => handleRsClick(arg)}\n        >\n          {arg}\n        </span>\n      );\n    } else {\n      finalParts.push(part);\n    }\n  });\n  return <div style={{ color: \"red\", padding: \"0px 5px\" }}>{finalParts}</div>;\n}\n`,\n'fileContents22': () => `\nimport React from 'react';\nimport {useSortable} from '@dnd-kit/sortable';\nimport {CSS} from '@dnd-kit/utilities';\n\nimport {Item} from './Item';\n\nexport function SortableItem(props) {\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n  } = useSortable({id: props.id});\n  \n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n  };\n\n  return (\n    <Item ref={setNodeRef} style={style} {...attributes} {...listeners}>\n      {props.children}\n    </Item>\n  );\n}`,\n'fileContents23': () => `\nimport * as React from \"react\";\nimport { useQueueListener } from \"../hooks/useQueueListener\";\n\nimport { css } from \"@emotion/css\";\n\nconst currentStepStyle = {\n  color: \"red\",\n};\nconst upcomingStepStyle = {\n  color: \"blue\",\n};\nconst descriptionStyle = {\n  color: \"black\",\n  marginLeft: \"10px\",\n};\n\nconst baseStyle = css\\u30A7\n  overflow: hidden;\n  max-height: 17px;\n  &:hover {\nmax-height: 200px;\n  }\n\\u30A7;\nexport const QueueHeader = ({}) => {\n  const { queueSteps } = useQueueListener();\n  if(queueSteps.length === 0) {\n    return <div>No steps in queue</div>\n  }\n  const currentStep = queueSteps[0];\n  return (\n    <div className={baseStyle}>\n      {queueSteps.map((step, i) => {\n        const style = i === 0 ? currentStepStyle : upcomingStepStyle;\n        const bridge = i !== queueSteps.length - 1 ? \\u30A7-->\\u30A7 : \"\";\n        return (\n          <span style={style}>\n            {step.name}\n            {bridge}\n          </span>\n        );\n      })}\n      <span style={descriptionStyle}>\n        Current step: {currentStep.description}\n      </span>\n      <div>Next action: {currentStep.transitionAction}</div>\n    </div>\n  );\n};\n`,\n'fileContents24': () => `\nimport React, {forwardRef} from 'react';\n\nexport const Item = forwardRef(({id, ...props}: any, ref) => {\n  return (\n    <div {...props} ref={ref}>{props.children}</div>\n  )\n});`,\n'fileContents25': () => `\nimport React, { useState } from \"react\";\nimport AceEditor from \"react-ace\";\n\nexport const GTWVEditor = ({ handleSubmit }) => {\n  const [value, setValue] = useState(\"\");\n  const [args, setArgs] = useState(\"\");\n  const [key, setKey] = useState(\"\");\n  function onChange(newValue) {\n    setValue(newValue);\n  }\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={key}\n        onChange={(e) => setKey(e.target.value)}\n        placeholder=\"key\"\n      />\n      <AceEditor\n        mode=\"javascript\"\n        theme=\"github\"\n        onChange={onChange}\n        name=\"UNIQUE_ID_OF_DIV\"\n        value={value}\n        height=\"100px\"\n        width=\"500px\"\n      />\n      <input\n        type=\"text\"\n        value={args}\n        onChange={(e) => setArgs(e.target.value)}\n        placeholder=\"args\"\n      />\n      <button disabled={key==null||key==\"\"||value==null||value==\"\"||args==null||args==\"\"} onClick={() => handleSubmit({ value, args: args.split(\",\").map(a=>a.trim()), key })}>Submit</button>\n    </div>\n  );\n};\n`,\n'fileContents26': () => `\nimport * as React from \"react\";\nimport { Types } from \"../hooks/useWordBuilder\";\n\n// The function that takes a schema and outputs a form component\nexport function createForm(inputSchema) {\n  return function DynamicForm({ onSubmit, hotkeys, setFocusedElement }) {\n    const [formState, setFormState] = React.useState(() => {\n      const initialState = {};\n      for (const key in inputSchema) {\n        if (\n          inputSchema[key] === Types.Template ||\n          inputSchema[key] === Types.String\n        ) {\n          initialState[key] = \"\";\n        } else if (inputSchema[key] === Types.Object) {\n          initialState[key] = {};\n        }\n      }\n      return initialState;\n    });\n\n    const handleChange = (key, value) => {\n      setFormState((prevState) => ({\n        ...prevState,\n        [key]: value,\n      }));\n    };\n\n    const handleSubmit = (event) => {\n      event.preventDefault();\n      console.log(\"Form submitted:\", formState);\n      onSubmit(formState);\n    };\n\n    return (\n      <form onSubmit={handleSubmit}>\n        {Object.keys(inputSchema).map((key) => {\n          if (\n            inputSchema[key] === Types.Template ||\n            inputSchema[key] === Types.String\n          ) {\n            return (\n              <div key={key}>\n                <label>{key}</label>\n                <input\n                  type=\"text\"\n                  value={formState[key]}\n                  onChange={(e) => handleChange(key, e.target.value)}\n                />\n              </div>\n            );\n          } else if (inputSchema[key] === Types.Object) {\n            // Assuming nested objects would require more complex handling\n            return (\n              <div key={key}>\n                <label>{key} (Object)</label>\n                <textarea\n                  value={JSON.stringify(formState[key], null, 2)}\n                  onChange={(e) =>\n                    handleChange(key, JSON.parse(e.target.value))\n                  }\n                />\n              </div>\n            );\n          }\n          return null;\n        })}\n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  };\n}\n`,\n'fileContents27': () => `\nimport * as React from \"react\";\nimport { Controller, set, useFieldArray, useForm } from \"react-hook-form\";\nimport { BuilderGenerator, BuilderTemplate, Schema, Types } from \"../hooks/useWordBuilder\";\nimport { useHotkeys } from \"../hooks/useHotkeys\";\nimport { hotKeyToItem } from \"../util/hotKeyBuilder\";\nimport { Box, Chip, ChipDelete, Sheet } from \"@mui/joy\";\nimport { FocusableElements } from \"./BuilderAccordion\";\nimport { compact, isObject } from \"lodash\";\nimport { arrayMove } from \"@dnd-kit/sortable\";\nimport {\n  closestCenter,\n  DndContext,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\";\nimport { SortableItem } from \"./SortableItem\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\ninterface FormProps {\n  schema: Schema;\n  hotkeys: Map<string, any>;\n  setFocusedElement: (element: FocusableElements) => void;\n  setFocusedStepIdx: () => void;\n  outputHotkeys: Map<string, any>;\n  templatesMeta: BuilderTemplate[];\n  formObject: any;\n  formKeyPrefix: string;\n  steps:BuilderGenerator[];\n  stepIdx: number;\n}\n\nconst NestedFormFields = ({\n  register,\n  unregister,\n  control,\n  schema,\n  hotkeys,\n  hotkeyEnabledIndex,\n  setHotkeyEnabledIndex,\n  setValue,\n  getValues,\n  setFocusedElement,\n  setFocusedStepIdx,\n  outputHotkeys,\n  keyPrefix = null,\n  arrayFields,\n  setArrayFields,\n  nestIndex,\n  templatesMeta,\n  keyWithPrefix,\n  steps,\n  stepIdx\n}: {\n  register: any;\n  unregister: any;\n  control: any;\n  schema: Schema;\n  hotkeys: Map<string, any>;\n  hotkeyEnabledIndex: number;\n  setHotkeyEnabledIndex: (index: number) => void;\n  setValue: any;\n  getValues: any;\n  setFocusedElement: (element: FocusableElements) => void;\n  setFocusedStepIdx: (index: number) => void;\n  outputHotkeys: Map<string, any>;\n  keyPrefix: string | null;\n  arrayFields: Record<string, number>;\n  setArrayFields: (fields: Record<string, number>) => void;\n  nestIndex?: number;\n  templatesMeta: BuilderTemplate[];\n  keyWithPrefix: (key: string) => string;\n  steps: BuilderGenerator[],\n  stepIdx: number;\n}) => {\n  //console.count(\"generateFormFields\");\n  if (schema == null) return null;\n  //console.log(\"THE SCHEMA\", schema);\n  const [arrayCount, setArrayCount] = React.useState({});\n  const components = Object.keys(schema).map((schemaKey, i) => {\n    let key = schemaKey;\n    //console.log(\"doing key\", key);\n    //console.log(\"and schema at key...\", schema[key]);\n    if (Array.isArray(schema[key])) {\n      // RECURSE!!\n      //console.log(\"IS ARRAY!!!\", schema[key]);\n      // we must have an array field here, so can add multiple.\n      // but, we add multiple of the schema inside it, which can also have an array of objects.\n      const nestedSchema: Schema = schema[key][0] as Schema;\n\n      // we need the key to say \"key.0.subKey\", ex \"mappings.0.from\", \"mappings.0.to\", etc.\n      // while also being able to add to it....\n\n      const fullKey = keyPrefix != null ? \\u30A7\\xA7{keyPrefix}.\\xA7{key}\\u30A7 : key;\n\n      if (arrayCount[fullKey] == null) {\n        setArrayCount({ ...arrayCount, [fullKey]: 1 });\n      }\n\n      const nestedFormFields = [];\n      for (let i = 0; i < (arrayCount[fullKey] ?? 1); i++) {\n        const nestedKeyPrefix =\n          keyPrefix != null ? \\u30A7\\xA7{fullKey}.\\xA7{i}\\u30A7 : \\u30A7\\xA7{fullKey}.\\xA7{i}\\u30A7;\n        nestedFormFields.push(\n          <div>\n            {i}:\n            {i === arrayCount[fullKey] - 1 && (\n              <button\n                onClick={() => {\n                  setArrayCount({\n                    ...arrayCount,\n                    [fullKey]: arrayCount[fullKey] - 1,\n                  });\n                  unregister(keyWithPrefix(nestedKeyPrefix));\n                }}\n              >\n                Remove\n              </button>\n            )}\n            <NestedFormFields\n              register={register}\n              unregister={unregister}\n              control={control}\n              schema={nestedSchema}\n              hotkeys={hotkeys}\n              hotkeyEnabledIndex={hotkeyEnabledIndex}\n              setHotkeyEnabledIndex={setHotkeyEnabledIndex}\n              setValue={setValue}\n              getValues={getValues}\n              setFocusedElement={setFocusedElement}\n              setFocusedStepIdx={setFocusedStepIdx}\n              outputHotkeys={outputHotkeys}\n              keyPrefix={nestedKeyPrefix}\n              arrayFields={arrayFields}\n              setArrayFields={setArrayFields}\n              templatesMeta={templatesMeta}\n              keyWithPrefix={keyWithPrefix}\n              steps={steps}\n              stepIdx={stepIdx}\n            />\n          </div>\n        );\n      }\n      // we need the key to say \"key.0.subKey\", ex \"mappings.0.from\", \"mappings.0.to\", etc.\n\n      return (\n        <div>\n          <button\n            onClick={() => {\n              // add to the array count\n              setArrayCount({\n                ...arrayCount,\n                [fullKey]: arrayCount[fullKey] + 1,\n              });\n            }}\n          >\n            Add\n          </button>\n          {nestedFormFields}\n        </div>\n      );\n    }\n    if (!Array.isArray(schema[key]) && isObject(schema[key])) {\n      //console.log(\"IS OBJECT!!!\", schema[key]);\n      // if it's an object, then the object is another schema.\n      // nest, and call generateFormFields again.\n      const nestedSchema: Schema = schema[key] as Schema;\n      const nestedFormFields = (\n        <NestedFormFields\n          register={register}\n          unregister={unregister}\n          control={control}\n          schema={nestedSchema}\n          hotkeys={hotkeys}\n          hotkeyEnabledIndex={hotkeyEnabledIndex}\n          setHotkeyEnabledIndex={setHotkeyEnabledIndex}\n          setValue={setValue}\n          getValues={getValues}\n          setFocusedElement={setFocusedElement}\n          setFocusedStepIdx={setFocusedStepIdx}\n          outputHotkeys={outputHotkeys}\n          keyPrefix={null}\n          arrayFields={arrayFields}\n          setArrayFields={setArrayFields}\n          templatesMeta={templatesMeta}\n          keyWithPrefix={keyWithPrefix}\n          steps={steps}\n          stepIdx={stepIdx}\n        />\n      );\n      return <div key={key}>{nestedFormFields}</div>;\n    }\n\n    const schemaValue = schema[key];\n    // sneaky use of let, bad!\n    key = keyPrefix ? \\u30A7\\xA7{keyPrefix}.\\xA7{key}\\u30A7 : key;\n\n    switch (schemaValue) {\n      case Types.String:\n        return (\n          <div key={key}>\n            <label>{key}</label>\n            <input {...register(keyWithPrefix(key))} />\n          </div>\n        );\n      case Types.Number:\n        return (\n          <div key={key}>\n            <label>{key}</label>\n            <input {...register(keyWithPrefix(key))} />\n          </div>\n        );\n      case Types.Template:\n        return (\n          <div key={keyWithPrefix(key)}>\n            <SingleTemplatefield\n              name={keyWithPrefix(key)}\n              control={control}\n              hotkeys={hotkeys}\n              outputHotkeys={outputHotkeys}\n              idx={i}\n              isHotkeyEnabled={hotkeyEnabledIndex === i}\n              setIsHotkeyEnabled={setHotkeyEnabledIndex}\n              setValue={setValue}\n              setFocusedElement={setFocusedElement}\n              setFocusedStepIdx={setFocusedStepIdx}\n              templatesMeta={templatesMeta}\n              steps={steps}\n              stepIdx={stepIdx}\n            />\n          </div>\n        );\n      case Types.TemplateArray:\n        return (\n          <div key={keyWithPrefix(key)}>\n            <DynamicTemplatesField\n              name={keyWithPrefix(key)}\n              control={control}\n              hotkeys={hotkeys}\n              outputHotkeys={outputHotkeys}\n              idx={i}\n              isHotkeyEnabled={hotkeyEnabledIndex === i}\n              setIsHotkeyEnabled={setHotkeyEnabledIndex}\n              setValue={setValue}\n              getValues={getValues}\n              setFocusedElement={setFocusedElement}\n              setFocusedStepIdx={setFocusedStepIdx}\n              templatesMeta={templatesMeta}\n            />\n          </div>\n        );\n      default:\n        return null;\n    }\n  });\n\n  return (\n    <Box fontSize={12} p={1} m={1} sx={{ border: \"1px solid grey\" }}>\n      {components}\n    </Box>\n  );\n};\nconst SingleTemplatefield = ({\n  name,\n  control,\n  hotkeys,\n  idx,\n  isHotkeyEnabled,\n  setIsHotkeyEnabled,\n  setValue,\n  setFocusedElement,\n  setFocusedStepIdx,\n  outputHotkeys,\n  templatesMeta,\n  steps,\n  stepIdx\n}) => {\n  console.log(\"single templ field name\", name, idx)\n  React.useEffect(() => {\n    if(name.split(\".\").some(n=>n===\"input\")) {\n      const priorStepOutput = steps[stepIdx-1]?.outputName ?? \"wordInput\";\n      console.log(\"did we nail it?\", priorStepOutput, steps, steps[stepIdx-1])\n      setValue(name, priorStepOutput)\n    }\n  },[])\n  useHotkeys(\n    Array.from(hotkeys.keys()),\n    (event) => {\n      console.log(\"ITEM FROM HOTKEY31\", hotKeyToItem(event.key, hotkeys));\n      setValue(name, (hotKeyToItem(event.key, hotkeys) as Template).name);\n    },\n    { enabled: isHotkeyEnabled }\n  );\n  useHotkeys(\n    Array.from(outputHotkeys.keys()),\n    (event) => {\n      console.log(\"ITEM FROM HOTKEY4\",hotKeyToItem(event.key, outputHotkeys))\n      // stored as a string, so we need to make it a \"Template\" with a name\n      setValue(name, hotKeyToItem(event.key, outputHotkeys));\n    },\n    { enabled: isHotkeyEnabled }\n  );\n  return (\n    <div\n      key={idx}\n      onClick={(e) => {\n        setFocusedElement(FocusableElements.templateInput);\n        setIsHotkeyEnabled(idx);\n        // idx provided by parent, we don't call it here\n        setFocusedStepIdx();\n        e.stopPropagation();\n      }}\n      onFocus={() => {\n        setFocusedElement(FocusableElements.templateInput);\n        setIsHotkeyEnabled(idx);\n        setFocusedStepIdx();\n      }}\n      onBlur={() => {\n        setFocusedElement(FocusableElements.builder);\n        setFocusedStepIdx(null);\n        setIsHotkeyEnabled(null);\n      }}\n      tabIndex={idx}\n    >\n      <label>{name}</label>\n      <Controller\n        name={name}\n        control={control}\n        render={({ field }) => {\n          return (\n            <div>\n              <Sheet\n                variant=\"outlined\"\n                color=\"neutral\"\n                sx={{ width: 1, minHeight: 30 }}\n              >\n                {field.value != null && (\n                  <Chip\n                    size=\"sm\"\n                    variant=\"outlined\"\n                    endDecorator={\n                      <ChipDelete\n                        onDelete={() => {\n                          setValue(name, null);\n                        }}\n                      />\n                    }\n                  >\n                    {field.value}:\n                    {templatesMeta\n                      .find((t) => t?.name === field.value)\n                      ?.vars?.join(\", \")}\n                  </Chip>\n                )}\n              </Sheet>\n            </div>\n          );\n        }}\n      />\n    </div>\n  );\n};\n\nconst DynamicTemplatesField = ({\n  name,\n  control,\n  hotkeys,\n  isHotkeyEnabled,\n  setIsHotkeyEnabled,\n  idx,\n  setValue,\n  getValues,\n  setFocusedElement,\n  setFocusedStepIdx,\n  outputHotkeys,\n  templatesMeta,\n}) => {\n  useHotkeys(\n    Array.from(hotkeys.keys()),\n    (event) => {\n      const currentValues = getValues(name) ?? [];\n      console.log(\"ITEM FROM HOTKEY1\", hotKeyToItem(event.key, hotkeys));\n      setValue(\n        name,\n        compact([\n          ...currentValues,\n          (hotKeyToItem(event.key, hotkeys) as Template).name,\n        ])\n      );\n    },\n    { enabled: isHotkeyEnabled }\n  );\n  useHotkeys(\n    Array.from(outputHotkeys.keys()),\n    (event) => {\n      const currentValues = getValues(name) ?? [];\n      console.log(\"ITEM FROM HOTKEY\",hotKeyToItem(event.key, outputHotkeys))\n      setValue(\n        name,\n        compact([\n          ...currentValues,\n          hotKeyToItem(event.key, outputHotkeys),\n        ])\n      );\n    },\n    { enabled: isHotkeyEnabled }\n  );\n  const [focusedIdx, setFocusedIdx] = React.useState(null);\n\n  return (\n    <div\n      key={idx}\n      onClick={(e) => {\n        setFocusedElement(FocusableElements.templateInput);\n        setIsHotkeyEnabled(idx);\n        setFocusedStepIdx(idx);\n        e.stopPropagation();\n      }}\n      onFocus={() => {\n        setFocusedElement(FocusableElements.templateInput);\n        setIsHotkeyEnabled(idx);\n        setFocusedStepIdx(idx);\n      }}\n      onBlur={() => {\n        setIsHotkeyEnabled(null);\n        setFocusedElement(FocusableElements.builder);\n        setFocusedIdx(null);\n        setFocusedStepIdx(null);\n      }}\n      tabIndex={idx}\n    >\n      <label>{name}</label>\n      <Controller\n        name={name}\n        control={control}\n        render={({ field }) => {\n          // use the hot keys, it will swap the focused index\n          // finish by setting the new focusedIdx to the new idx it's in.\n          useHotkeys(\n            [\"arrowLeft\", \"arrowRight\"],\n            (event) => {\n              const newIdx =\n                event.key === \"ArrowLeft\" ? focusedIdx - 1 : focusedIdx + 1;\n              if (newIdx < 0 || newIdx >= field.value.length) {\n                return;\n              }\n              const newValues = arrayMove(field.value, focusedIdx, newIdx);\n              setValue(name, newValues);\n              setFocusedIdx(newIdx);\n            },\n            { enabled: focusedIdx !== null }\n          );\n          return (\n            <div>\n              <Sheet\n                variant=\"outlined\"\n                color=\"neutral\"\n                sx={{ width: 1, minHeight: 30 }}\n              >\n                {field.value?.map((item, i) => (\n                  <Chip\n                    size=\"sm\"\n                    variant=\"outlined\"\n                    onClick={() => {\n                      setFocusedIdx(i);\n                    }}\n                    color={focusedIdx === i ? \"primary\" : \"neutral\"}\n                    endDecorator={\n                      <ChipDelete\n                        onDelete={() => {\n                          const newValues = getValues(name).filter(\n                            (_, i2) => i2 !== i\n                          );\n                          setValue(name, newValues);\n                          setFocusedIdx(null);\n                        }}\n                      />\n                    }\n                  >\n                    {item}:{\" \"}\n                    {templatesMeta\n                      .find((t) => t?.name === item)\n                      ?.vars?.join(\", \")}\n                  </Chip>\n                ))}\n              </Sheet>\n            </div>\n          );\n        }}\n      />\n    </div>\n  );\n};\n\nconst DynamicForm: React.FC<FormProps> = ({\n  schema,\n  hotkeys,\n  setFocusedElement,\n  setFocusedStepIdx,\n  outputHotkeys,\n  templatesMeta,\n  formObject,\n  formKeyPrefix,\n  steps,\n  stepIdx,\n}) => {\n  const { control, setValue, getValues, unregister, register } = formObject;\n  const [hotkeyEnabledIndex, setHotkeyEnabledIndex] = React.useState(null);\n  const [arrayFields, setArrayFields] = React.useState({});\n\n  function keyWithPrefix(key: string) {\n    return \\u30A7\\xA7{formKeyPrefix}.\\xA7{key}\\u30A7;\n  }\n\n  return (\n    <div\n      onClick={() => {\n        setHotkeyEnabledIndex(null);\n        setFocusedElement(FocusableElements.builder);\n      }}\n    >\n      <NestedFormFields\n      steps={steps}\n      stepIdx={stepIdx}\n        register={register}\n        unregister={unregister}\n        control={control}\n        schema={schema}\n        hotkeys={hotkeys}\n        hotkeyEnabledIndex={hotkeyEnabledIndex}\n        setHotkeyEnabledIndex={setHotkeyEnabledIndex}\n        setValue={setValue}\n        getValues={getValues}\n        setFocusedElement={setFocusedElement}\n        setFocusedStepIdx={setFocusedStepIdx}\n        outputHotkeys={outputHotkeys}\n        keyPrefix={null}\n        arrayFields={arrayFields}\n        setArrayFields={setArrayFields}\n        templatesMeta={templatesMeta}\n        keyWithPrefix={keyWithPrefix}\n      />\n    </div>\n  );\n};\n\nexport default DynamicForm;\n`,\n'fileContents28': () => `\nimport React from \"react\";\nexport default function Dropdown({ options, onSelect, placeholder=\"Select an option\" }) {\n    const handleChange = (event) => {\n      onSelect(event.target.value);\n    };\n  \n    return (\n      <select onChange={handleChange}>\n        <option value=\"\" disabled selected>\n          {placeholder}\n        </option>\n        {options.map((option, index) => (\n          <option key={index} value={option}>\n            {option}\n          </option>\n        ))}\n      </select>\n    );\n  }`,\n'fileContents29': () => `\nimport * as React from \"react\";\nimport Tooltip from \"@mui/joy/Tooltip\";\nimport Chip from \"@mui/joy/Chip\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { Sheet } from \"@mui/joy\";\nimport {\n  BuilderGenerator\n} from \"../hooks/useWordBuilder\";\nimport {\n  itemToHotKey,\n  getHotKeyMapForItems\n} from \"../util/hotKeyBuilder\";\nimport { useMeta } from \"../hooks/useMeta\";\nimport { WordBuilderForm } from \"./WordBuilderForm\";\n\nfunction identity(t: Template): Template {\n  return t;\n}\nfunction combine(t1: Template, t2: Template): Template {\n  return { ...t1, ...t2 };\n}\n\ntype TemplateMeta = {\n  name: string;\n  templateBody: string;\n  hotkey: string;\n  showHotkey: boolean;\n  vars: string[];\n};\n\nconst TemplateNode = ({\n  name,\n  templateBody,\n  vars,\n  hotkey,\n  showHotkey,\n}: TemplateMeta) => {\n  return (\n    <Tooltip title={templateBody}>\n      <Chip variant=\"outlined\">\n        {name}: {vars?.join(\", \")} {showHotkey && <>| {hotkey}</>}\n      </Chip>\n    </Tooltip>\n  );\n};\ntype GeneratorMeta = {\n  name: string;\n  hotkey: string;\n  showHotkey: boolean;\n};\n\nconst GeneratorNode = ({ name, hotkey, showHotkey }: GeneratorMeta) => {\n  return (\n    <Tooltip title={name}>\n      <Chip variant=\"outlined\">\n        {name} {showHotkey && <>| {hotkey}</>}\n      </Chip>\n    </Tooltip>\n  );\n};\n\ntype WordMeta = {\n  name: string;\n  steps: BuilderGenerator[];\n  hotkey: string;\n  showHotkey: boolean;\n};\n\nconst WordNode = ({ name, steps, hotkey, showHotkey }: WordMeta) => {\n  const text = steps.toString();\n  return (\n    <Tooltip title={text}>\n      <Chip variant=\"outlined\">\n        {name} {showHotkey && <>| {hotkey}</>}\n      </Chip>\n    </Tooltip>\n  );\n};\n\n//  console.log(\"RENDERING\", name, inputs, outputs);\nfunction handleSubmit(results) {\n  console.log(\"submit\", results);\n}\n\nexport enum FocusableElements {\n  builder,\n  templateInput,\n  none,\n}\n\nconst BuilderAccordion = ({\n  generatorsFileText,\n  templatesFileText,\n  wordsFileText,\n  postMessage,\n}: {\n  generatorsFileText: string;\n  templatesFileText: string;\n  wordsFileText: string;\n  postMessage:any;\n}) => {\n  if (\n    generatorsFileText == null ||\n    templatesFileText == null ||\n    wordsFileText == null\n  ) {\n    return <div>Loading...</div>;\n  }\n  const { wordsMeta, templatesMeta, generatorsMeta } = useMeta({\n    wordsFileText,\n    templatesFileText,\n    generatorsFileText,\n  });\n\n  const [focusedElement, setFocusedElement] = React.useState<FocusableElements>(\n    FocusableElements.builder\n  );\n\n  const templateHotKeys = getHotKeyMapForItems(templatesMeta);\n  const stepHotKeys = getHotKeyMapForItems([...generatorsMeta, ...wordsMeta]);\n\n  const isStepHotKeysEnabled = focusedElement === FocusableElements.builder;\n  const isTemplateHotKeysEnabled =\n    focusedElement === FocusableElements.templateInput;\n\n  console.log(\"what is focused?\", focusedElement);\n  const [focusedWord, setFocusedWord] = React.useState(0);\n  // have a useEffect check that the form properly sets the input template value based on what is in step.\n  // that's odd though...there has to be a better way\n  return (\n    <div>\n      <Sheet variant=\"outlined\" color=\"neutral\">\n        Words\n        {wordsMeta.map((w) => (\n          <WordNode\n            name={w.name}\n            steps={w.steps}\n            hotkey={itemToHotKey(w, stepHotKeys)}\n            showHotkey={isStepHotKeysEnabled}\n          />\n        ))}\n        <hr />\n        Generators\n        {generatorsMeta.map((g) => (\n          <GeneratorNode\n            name={g.name}\n            hotkey={itemToHotKey(g, stepHotKeys)}\n            showHotkey={isStepHotKeysEnabled}\n          />\n        ))}\n        <hr />\n        Template Pool\n        {templatesMeta.map((t) => (\n          <TemplateNode\n            name={t.name}\n            templateBody={t.templateBody}\n            vars={t.vars}\n            hotkey={itemToHotKey(t, templateHotKeys)}\n            showHotkey={isTemplateHotKeysEnabled}\n          />\n        ))}\n        <hr />\n        <WordBuilderForm\n          stepHotKeys={stepHotKeys}\n          wordsMeta={wordsMeta}\n          templatesMeta={templatesMeta}\n          generatorsMeta={generatorsMeta}\n          setFocusedElement={setFocusedElement}\n          wordIdx={0}\n          templateHotKeys={templateHotKeys}\n          setFocusedWord={setFocusedWord}\n          focusedWord={focusedWord}\n          isStepHotKeysEnabled={isStepHotKeysEnabled}\n          isTemplateHotKeysEnabled={isTemplateHotKeysEnabled}\n          postMessage={postMessage}\n        />\n        <WordBuilderForm\n          stepHotKeys={stepHotKeys}\n          wordsMeta={wordsMeta}\n          templatesMeta={templatesMeta}\n          generatorsMeta={generatorsMeta}\n          setFocusedElement={setFocusedElement}\n          wordIdx={1}\n          templateHotKeys={templateHotKeys}\n          setFocusedWord={setFocusedWord}\n          focusedWord={focusedWord}\n          isStepHotKeysEnabled={isStepHotKeysEnabled}\n          isTemplateHotKeysEnabled={isTemplateHotKeysEnabled}\n          postMessage={postMessage}\n        />\n      </Sheet>\n    </div>\n  );\n};\n\nexport default BuilderAccordion;\n`,\n'fileContents30': () => `\nimport * as React from \"react\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport BuilderAccordion from \"./BuilderAccordion\";\nimport { CssVarsProvider } from \"@mui/joy\";\nimport { useFileSystem } from \"../hooks/useFileSystem\";\nimport TemplateDirect from \"./v2\";\nimport { TemplateEditors, TemplateTree } from \"./TemplateTree\";\nimport { useRunner } from \"../hooks/useRunner\";\nimport { tts } from \"symmetric-parser\";\nimport { buildAllGeneratorsTemplate } from \"../util/parsers/parseGenerators\";\nimport { WordStep } from \"../hooks/useTemplate\";\nimport { last } from \"lodash\";\nimport Dropdown from \"./Dropdown\";\nimport { WordCreator } from \"./WordCreator\";\nimport { GTWVEditor } from \"./GTWVEditor\";\n\nimport \"ace-builds/src-noconflict/mode-java\";\nimport \"ace-builds/src-noconflict/theme-github\";\nimport \"ace-builds/src-noconflict/ext-language_tools\";\nimport { QueueHeader } from \"./QueueHeader\";\n\nexport function \\xD2(func: () => string, keyName: string) {\n  try {\n    if (func == null) {\n      return \"\\xA7{run(\" + keyName + \", '\" + keyName + \"')}\";\n    }\n    if (typeof func === \"string\") {\n      throw new Error(\"func is string\");\n    }\n    const result = func();\n    return result;\n  } catch (e) {\n    return \"\\xA7{run(\" + keyName + \", '\" + keyName + \"')}\";\n  }\n}\ninterface vscode {\n  postMessage(message: any): void;\n}\ndeclare const vscode: vscode;\n\nconst sendMessage = () => {\n  console.log(\"button clicked\");\n  vscode.postMessage({ command: \"testing\" });\n};\n\nconst firsty: Template = {\n  firsty: () => \\u30A7this is where we do it\\u30A7,\n};\n\nconst playTemplate = \\u30A7({ \n    'shop1/would1,test1': ({would1, test1})=>\\xD8\\u30A7how \\xD8\\xA7{run(would1, 'would1')} you \\xD8\\xA7{run(test1, 'test1')} this too\\xD8\\u30A7, \n    'shop2/would2,test2': ({would2, test2})=>\\xD8\\u30A7how \\xD8\\xA7{run(would2, 'would2')} you \\xD8\\xA7{run(test2, 'test2')} this too\\xD8\\u30A7, \n    'shop3/would3,test3': ({would3, test3})=>\\xD8\\u30A7how \\xD8\\xA7{run(would3, 'would3')} you \\xD8\\xA7{run(test3, 'test3')} this too\\xD8\\u30A7, \n    'something1': ()=>\\xD8\\u30A7some value\\xD8\\u30A7, \n    'something2': ()=>\\xD8\\u30A7another one!\\xD8\\u30A7 \n  })\\u30A7;\n\nexport const CONFIG_PATH =\n  \"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig\";\nconst App = () => {\n  const {\n    readAllFiles,\n    generatorsFileText,\n    templatesFileText,\n    loading,\n    filledGeneratorsFileText,\n    wordNames,\n    currentWord,\n    currentWordName,\n    setWord,\n    createNewWord,\n    addToTemplatePool,\n    templateModule,\n    allFileTemplates,\n    runnableWords,\n    selectQueue,\n    queueNames,\n    subTemplate\n  } = useFileSystem(vscode.postMessage);\n  React.useEffect(() => {\n    readAllFiles(\"polTest\");\n  }, []);\n  const [showGTWVEditor, setShowGTWVEditor] = React.useState(false);\n  return (\n    <div>\n      <div><QueueHeader/></div>\n      <CssVarsProvider>\n        <Dropdown\n          options={queueNames}\n          onSelect={(value) => {\n            selectQueue(value);\n          }}\n          placeholder=\"Select a word\"\n        />\n        <Dropdown\n          options={wordNames}\n          onSelect={(value) => {\n            setWord(value);\n          }}\n          placeholder=\"Select a word\"\n        />\n        <WordCreator createNewWord={createNewWord} />\n        {showGTWVEditor && (\n          <GTWVEditor\n            handleSubmit={(value) => {\n              setShowGTWVEditor(false);\n              addToTemplatePool(value.key, value.value, value.args);\n            }}\n          />\n        )}\n        <button\n          onClick={() => {\n            setShowGTWVEditor(!showGTWVEditor);\n          }}\n        >\n          toggle GTWV Editor\n        </button>\n\n        {!loading && (\n          <>\n            <TemplateEditors\n              postMessage={vscode.postMessage}\n              configPath={CONFIG_PATH}\n              filledGeneratorsFileText={filledGeneratorsFileText}\n              templateModule={templateModule}\n              allFileTemplates={allFileTemplates}\n              runnableWords={runnableWords}\n              templateDefinitions={[\n                {\n                  name: currentWordName,\n                  wordSteps: currentWord,\n                  meta: {\n                    generators: buildAllGeneratorsTemplate(generatorsFileText),\n                  },\n                  subTemplate // added separately here bc it's for display purposes\n                },\n                {\n                  name: \"generators\",\n                  wordSteps: [{ result: {} }],\n                  meta: {\n                    generators: buildAllGeneratorsTemplate(generatorsFileText),\n                  },\n                },\n              ]}\n            />\n          </>\n        )}\n        {/*<BuilderAccordion \n          generatorsFileText={generatorsFileText} \n          templatesFileText={templatesFileText} \n          wordsFileText={wordsFileText} \n          postMessage={vscode.postMessage}\n        />*/}\n      </CssVarsProvider>\n    </div>\n  );\n};\n\nexport default App;\n`,\n'fileContents31': () => `\n`,\n'fileContents32': () => `\nimport { tts } from \"symmetric-parser\";\nimport * as fsService from \"../services/fsService\";\nimport { runWord, TemplateAsString } from \"../services/wordRunService\";\nimport { compact } from \"lodash\";\n\nexport type DequeueConfig = {\n  name: string;\n  description: string;\n  steps: DequeueStep[];\n};\nexport type DequeueStep = {\n  type: \"fs\" | \"template\";\n  config: string;\n  name: string;\n  description: string; // tooltip, explanations, etc\n  word?: string; // just the name. runs before sending template to the frontend\n  waitForTransitionCommand: boolean;\n  runWithEmptyTemplate: boolean;\n  transitionAction: string; //\"get\" // getOrCreate\n  subTemplate?: TemplateAsString;\n};\n\nconst typeToHandlerMap = {\n  fs: handleFs,\n  template: handleTemplate,\n};\n\nasync function handleRunStep(\n  step: DequeueStep,\n  templateAsString: TemplateAsString\n): Promise<TemplateAsString> {\n  // basically a super-router.\n  try {\n    const { type } = step;\n    const handler = typeToHandlerMap[type];\n    if (handler == null)\n      throw new Error(\\u30A7handleRunStep: handler doesn't exist for type \\xA7{type}\\u30A7);\n    const result = await handler(step, templateAsString);\n    return result;\n  } catch (e) {\n    throw new Error(e);\n  }\n}\n\n// basically a router.\nconst fsActionToServiceMap = {\n  get: fsService.get, // controller action?\n  getOrCreate: fsService.getOrCreate,\n  identity: fsService.identity,\n};\n\n// can be made generic?\nasync function handleFs(\n  step: DequeueStep,\n  input: TemplateAsString\n): Promise<TemplateAsString> {\n  const { config, transitionAction } = step;\n  const action = fsActionToServiceMap[transitionAction];\n  const result = await action(config, input);\n  return result;\n}\n\nasync function handleTemplate(\n  step: DequeueStep,\n  templateAsString: TemplateAsString\n): Promise<TemplateAsString> {\n  // ...\n  return templateAsString;\n}\n\n// make it agnostic from WHAT gets ran\ntype SubscribeCb = (step: DequeueStep, template: TemplateAsString) => void;\n\nexport default class Runner {\n  steps: DequeueStep[];\n  currentStep: DequeueStep;\n  currentTemplate: TemplateAsString;\n  subscribed: Map<string, SubscribeCb>;\n  isRunning: boolean;\n  constructor(steps: DequeueStep[]) {\n    if (steps == null || steps.length === 0) {\n      this.steps = [];\n    } else {\n      this.steps = steps;\n    }\n    this.subscribed = new Map();\n    this.isRunning = false;\n    this.currentStep = this.steps[0];\n  }\n  append(steps: DequeueStep[]) {\n    this.steps.push(...steps);\n  }\n  appendLeft(steps: DequeueStep[]) {\n    this.steps.unshift(...steps);\n  }\n  subscribe(name: string, cb: SubscribeCb) {\n    this.subscribed.set(name, cb);\n  }\n  unsubscribe(name: string) {\n    this.subscribed.delete(name);\n  }\n  onRunNext(step: DequeueStep, template: TemplateAsString) {\n    this.subscribed.forEach((cb, key) => {\n      try {\n        cb(step, template);\n      } catch (e) {\n        console.error(\\u30A7onRunNext failure, \\xA7{key} callback failed:\\u30A7);\n        console.error(e);\n      }\n    });\n  }\n  addSubTemplatesToQueue(templates: TemplateAsString[]) {\n\n    // this is nasty. we basically want to delay the transition action\n    // until the subTemplates queue'd steps are ran.\n    // then we run the currentStep's transition action.\n    // meaning we need to change the currentStep's transition action to identity\n    const oldTransitionAction = this.currentStep.transitionAction;\n    // use config from current step to deduce what the new config is\n    // then add to the queue\n    const queueSteps: DequeueStep[] = compact(templates).map((t) => {\n      console.log(\"queueing\", t)\n      return {\n        type: this.currentStep.type,\n        config: this.currentStep.config,\n        runWithEmptyTemplate: false,\n        subTemplate: t,\n        waitForTransitionCommand: true,\n        description: \"Queue item from subTemplate\",\n        name: this.currentStep.name + \"_subTemplate\",\n        transitionAction: \"identity\",\n      };\n    });\n    // the final step just runs the original transition action.\n    // no need to wait for anything.\n    queueSteps.push({\n      ...this.currentStep,\n      word: null,\n      waitForTransitionCommand: false,\n      transitionAction: oldTransitionAction,\n    });\n    this.appendLeft(queueSteps);\n    // every handler must implement identity\n    this.currentStep.transitionAction = \"identity\";\n    console.log(\"APPENEDED STEPS\", this.steps);\n  }\n\n  async initNextStep(\n    templateAsString: TemplateAsString = \"{}\"\n  ): Promise<TemplateAsString> {\n    this.isRunning = true;\n    const step = this.steps.shift();\n\n    if (step == null) {\n      console.log(\"no further steps\");\n      return templateAsString;\n    }\n    this.currentStep = step;\n    // someone else's event handler, returns void, affects nothing\n    this.onRunNext(step, this.currentTemplate);\n    const { config, word } = step;\n\n    let stepTemplate =\n      step.runWithEmptyTemplate === true ? \"{}\" : templateAsString;\n    if (word != null) {\n      const runWordTemplate =\n        step.runWithEmptyTemplate === true ? \"{}\" : templateAsString;\n      const { template: runResult, queuedTemplates } = await runWord(\n        config,\n        word,\n        runWordTemplate\n      );\n      if (queuedTemplates.length > 0) {\n        this.addSubTemplatesToQueue(queuedTemplates);\n      }\n      stepTemplate = runResult;\n    }\n    this.currentTemplate = stepTemplate;\n    if (!step.waitForTransitionCommand) {\n      const result = await this.transition(stepTemplate);\n      return result;\n    } else {\n      this.isRunning = false;\n      return stepTemplate;\n    }\n  }\n  // transition flow means.....we start at zero and it initializes.\n  // then on transition, we run the transition action and pass to the next step\n  async transition(input: TemplateAsString = \"{}\"): Promise<TemplateAsString> {\n    // the actual internal runner, returns Template, affects so many things\n    const stepResult = await handleRunStep(this.currentStep, input);\n    const fullResult = await this.initNextStep(stepResult);\n    return fullResult;\n  }\n}\n`,\n'fileContents33': () => `\nimport {\n  genTemplateWithVars,\n  joiner,\n  orderedFold,\n  performOnNodes,\n  recursiveFold,\n  stringCleaning,\n  swapValuesForGenericKeysWithCb,\n  joinOnValue,\n  replaceWithAllIsomorphic,\n  collapseTemplateAtKey,\n  stringUnCleaning,\n  multiply,\n  divide,\n  FoldMode,\n  tts,\n  argsAndTemplateToFunction,\n  findFirst,\n  makeTemplateGenericAtKey,\n  insertIntoTemplate,\n} from \"symmetric-parser\";\n\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\nconst generator = genTemplateWithVars(\n  {\n    generator: () => \\u30A7export function genName(genArgs): Template {genBody\\xD8n}\\u30A7,\n  },\n  [\"genName\", \"genArgs\", \"genBody\"]\n);\nexport function buildAllGeneratorsTemplate(generatorFile: string) {\n  const cleaned = stringCleaning(generatorFile);\n  const file = { allGenerators1: () => cleaned };\n  const fr = recursiveFold(\n    file,\n    [generator],\n    [],\n    { scope: () => \\u30A7\\xD8n\\u30A7 },\n    \"  \",\n    1\n  );\n\n  const frAll = {\n    ...fr.result,\n    ...fr.divisors,\n  };\n\n  const generatorParseTree = buildGeneratorParseTree(frAll);\n  let newTemplate = {};\n\n  performOnNodes(generatorParseTree, \"generator\", (t: Template) => {\n    const genSkel = genTemplateWithVars(\n      {\n        generator: () => \\u30A7genName(genArgs)\\u30A7,\n      },\n      [\"genName\", \"genArgs\"]\n    );\n    const nameTempl = makeTemplateGenericAtKey(\n      findFirst(t, \"genName\"),\n      \"genName\"\n    );\n    // console.log(\"NAME TEMPL\", nameTempl);\n    const argsTempl = makeTemplateGenericAtKey(\n      collapseTemplateAtKey(t, \"genArgs\"),\n      \"genArgs\"\n    );\n    //console.log(\"ARGS TEMPL\", argsTempl);\n\n    // console.log(\"ALL\", multiply(genSkel, multiply(nameTempl, argsTempl)));\n    newTemplate = insertIntoTemplate(\n      newTemplate,\n      multiply(genSkel, multiply(nameTempl, argsTempl))\n    );\n    return t;\n  });\n  return newTemplate;\n  const stringTree = tts(generatorParseTree, false);\n  const uncleaned = stringUnCleaning(stringTree);\n  return eval(uncleaned);\n}\nexport function parseGenerators(generatorFile: string) {\n  const cleaned = stringCleaning(generatorFile);\n  const file = { file: () => cleaned };\n\n  const fr = recursiveFold(\n    file,\n    [generator],\n    [],\n    { scope: () => \\u30A7\\xD8n\\u30A7 },\n    \"  \",\n    1\n  );\n\n  const frAll = {\n    ...fr.result,\n    ...fr.divisors,\n  };\n\n  const generatorParseTree = buildGeneratorParseTree(frAll);\n\n  const generatorMeta = buildGeneratorMeta(generatorParseTree);\n\n  const generatorString = stringUnCleaning(\n    \"[\" + generatorMeta[\"metas\"]() + \"]\"\n  );\n  // console.log(\"EVAL THIS\", generatorString);\n  const final = eval(generatorString);\n  return final;\n}\nconst replaceTempl = genTemplateWithVars(\n  {\n    typeDef: () => \\u30A7{ typeDefBody\\xD8n}\\u30A7,\n  },\n  [\"typeDefBody\"]\n);\nfunction buildGeneratorMeta(template: Template) {\n  const replacedTypeNames = joinOnValue(\n    \"MapArg\",\n    \"typeDefName\", // better to use a template for the type safety\n    \"typeDefBody\", // refactor for tomorrow^\n    (t: Template) => {\n      const of = orderedFold(t, [finalTypeKeyVal, finalTypeDefKeyVal], {\n        mode: FoldMode.Strict,\n      });\n      if (of == null) throw new Error(\"null fold\");\n      const allOf = { ...of.result, ...of.divisors };\n      const iso = multiply(\n        replaceWithAllIsomorphic(allOf, [newTypeKeyVal]),\n        {}\n      );\n\n      return multiply(iso, replaceTempl);\n    },\n    \"typeValue\",\n    template\n  );\n  const replacedTypeNames2 = joinOnValue(\n    \"MapOnto\",\n    \"typeDefName\", // better to use a template for the type safety\n    \"typeDefBody\", // refactor for tomorrow^\n    (t: Template) => {\n      const of = orderedFold(t, [finalTypeKeyVal, finalTypeDefKeyVal], {\n        mode: FoldMode.Strict,\n      });\n      if (of == null) throw new Error(\"null fold\");\n      const allOf = { ...of.result, ...of.divisors };\n      const iso = multiply(\n        replaceWithAllIsomorphic(allOf, [newTypeKeyVal]),\n        {}\n      );\n\n      return multiply(iso, replaceTempl);\n    },\n    \"typeValue\",\n    replacedTypeNames\n  );\n  // console.log(\"JOIN\", replacedTypeNames2);\n  const genMeta = performOnNodes(replacedTypeNames2, \"generator\", buildMeta);\n  // console.log(\"GENMETA\", tts(genMeta, false));\n  // we want {name: \"genName\", inputSchema: {metaBody}}\n  const allMeta = joiner(genMeta, \"meta\", \"metas\", \",\\xD8n\");\n  return allMeta;\n}\n\nfunction buildMeta(template: Template, index: number): Template {\n  const cbFuncStringd = replaceWithAllIsomorphic(template, [newCbTemplFunc]);\n  //console.log(\"CBFUNCSTRING\", tts(cbFuncStringd, false));\n  const all = performOnNodes(cbFuncStringd, \"typeValue\", (t: Template) => {\n    const folded = orderedFold(cbFuncStringd, [\n      stringArrayTypeValueTempl,\n      templateArrayTypeValueTempl,\n      templateTypeValueTempl,\n      stringTypeValueTempl,\n      numberTypeValueTempl,\n    ]);\n    if (folded == null) throw new Error(\"null fold\");\n    const all = { ...folded.result, ...folded.divisors };\n    // console.log(\"ALL\", tts(all,false));\n    return all;\n  });\n\n  const swapped = swapValuesForGenericKeysWithCb(all, [\n    { key: \"schemaTemplType\", newValue: () => \"'Template'\" },\n    { key: \"schemaStrArrType\", newValue: () => \"'StringArray'\" },\n    { key: \"schemaStrType\", newValue: () => \"'String'\" },\n    { key: \"schemaTemplArrType\", newValue: () => \"'TemplateArray'\" },\n    { key: \"schemaNumType\", newValue: () => \"'Number'\" },\n  ]);\n  // console.log(\"SWAPPEd\", swapped);\n  // what do we want this structure to be again..?\n  // g1:()=>\\u30A7{name:\"identity\",inputSchema:{template:Template}}\\u30A7\n\n  const funcStringd = replaceWithAllIsomorphic(swapped, [\n    newFinalRemainderFuncTypes,\n  ]);\n\n  const normalized = replaceWithAllIsomorphic(funcStringd, [\n    singleLineTypeKeyVal,\n  ]);\n\n  const replaced = replaceWithAllIsomorphic(normalized, [\n    schemaArrayObjectTypeTempl,\n    schemaSingleLineArrayObjectTypeTempl,\n  ]);\n\n  const collapsed = collapseTemplateAtKey(replaced, \"genArgs\");\n  if (collapsed == null) throw new Error(\"null collapsed\");\n\n  const joined = joiner(collapsed, \"genArgs\", \"genInputSchema\", \",\");\n  // joiner, uh...works for single values pretty well, too.\n  const name = joiner(template, \"genName\", \"genName\", \"\");\n  const metaTempl = genTemplateWithVars(\n    {\n      [\"meta\" + index]: () =>\n        \"{ name: 'genName', inputSchema: { genInputSchema }}\",\n    },\n    [\"genName\", \"genInputSchema\"]\n  );\n  const multi = multiply(multiply(joined, metaTempl), name);\n  const commaFix = { doubleComma: () => \\u30A7,,\\u30A7 };\n  const detection = divide(multi, commaFix);\n  const newDoubleComma = { doubleComma: () => \\u30A7,\\u30A7 };\n  const singleCommaOnly = multiply(detection, newDoubleComma);\n\n  //console.log(\"FINISHEd33\", tts(singleCommaOnly,false))\n  return singleCommaOnly;\n}\nfunction buildGeneratorParseTree(generators: Template) {\n  const gWithTypes = orderedFold(generators, [typesTempl]);\n  if (gWithTypes == null) {\n    throw new Error(\"No generators found\");\n  }\n  const all = { ...gWithTypes.result, ...gWithTypes.divisors };\n  //console.log(\"perf on nodeds\");\n  const parsedGenArgs = performOnNodes(all, \"genArgs\", parseGenArgs);\n  //console.log(\"fin parse tree\");\n  return parsedGenArgs;\n}\nfunction parseGenArgs(template: Template, index: number): Template {\n  //console.count(\"parsegenargs\");\n  //console.log(\"*******************************************\");\n  //console.log(\"template\", template);\n  const of = recursiveFold(\n    template,\n    [\n      cbFuncCommaTempl,\n      cbFuncNewlineTempl,\n      arrayObjectTypeTempl,\n      singleLineArrayObjectTypeTempl,\n      typeKeyVal,\n      inlineSemiColonFuncKeyVal,\n      semiColonTypes,\n      finalLineTypeFuncKeyVal,\n      finalTypeKeyVal,\n      finalLineTypeKeyVal,\n      remainderTypes,\n      finalRemainderFuncTypes,\n      finalRemainderTypes,\n      singleLineTypeKeyVal,\n      finalSingleLineTypeKeyVal,\n      singleTypeTempl,\n    ],\n    [],\n    { scope: () => \\u30A7\\xD8n\\u30A7 },\n    \"  \",\n    3,\n    index\n  );\n  if (of == null) {\n    throw new Error(\"No genArgs found\");\n  }\n\n  const all = { ...of.result, ...of.divisors };\n\n  return all;\n}\n\nconst typesTempl = genTemplateWithVars(\n  {\n    typeDef: () => \\u30A7type typeDefName = {typeDefBody\\xD8n};\\u30A7,\n  },\n  [\"typeDefName\", \"typeDefBody\"]\n);\n\nconst typeKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal1: () => \\u30A7\\xD8n  typeKeyName: typeValue,\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\nconst finalTypeKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7\\xD8n  typeKeyName: typeValue;\\xD8n\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\nconst finalTypeDefKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7  typeKeyName: typeValue;\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\nconst newTypeKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7typeKeyName: typeValue, \\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\nconst singleLineTypeKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7typeKeyName: typeValue,\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\nconst finalSingleLineTypeKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7 typeKeyName: typeValue\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\n\nconst finalLineTypeFuncKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal898: () => \\u30A7  typeKeyName: (typeFuncBody) => typeFuncReturn\\xD8n\\u30A7,\n  },\n  [\"typeKeyName\", \"typeFuncBody\", \"typeFuncReturn\"]\n);\nconst finalLineTypeKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal5: () => \\u30A7  typeKeyName: typeValue\\xD8n\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\nconst remainderTypes = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7typeKeyName: typeValue;\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\nconst finalRemainderFuncTypes = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7 typeKeyName: (typeFuncBody) => typeFuncReturn \\u30A7,\n  },\n  [\"typeKeyName\", \"typeFuncBody\", \"typeFuncReturn\"]\n);\nconst newFinalRemainderFuncTypes = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7 typeKeyName: \"(typeFuncBody) => typeFuncReturn\",\\u30A7,\n  },\n  [\"typeKeyName\", \"typeFuncBody\", \"typeFuncReturn\"]\n);\nconst cbFuncCommaTempl = genTemplateWithVars(\n  {\n    cbTempl: () => \\u30A7  cb: (cbTypeFuncBody) => Template,\\u30A7,\n  },\n\n  [\"cbTypeFuncBody\"]\n);\nconst numberTypeValueTempl = {\n  schemaNumType: () => \\u30A7number\\u30A7,\n};\nconst cbFuncNewlineTempl = genTemplateWithVars(\n  {\n    cbTempl: () => \\u30A7  cb: (cbTypeFuncBody) => Template\\u30A7,\n  },\n\n  [\"cbTypeFuncBody\"]\n);\nconst newCbTemplFunc = genTemplateWithVars(\n  {\n    cbTempl: () => \\u30A7  cb: \"(cbTypeFuncBody) => Template\",\\u30A7,\n  },\n\n  [\"cbTypeFuncBody\"]\n);\nconst finalRemainderTypes = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7 typeKeyName: typeValue \\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\n\nconst arrayObjectTypeTempl = genTemplateWithVars(\n  {\n    arrayNestType: () => \\u30A7Array<{objTypeBody\\xD8n  }>\\u30A7,\n  },\n  [\"objTypeBody\"]\n);\n\nconst schemaArrayObjectTypeTempl = genTemplateWithVars(\n  {\n    arrayNestType: () => \\u30A7[{objTypeBody\\xD8n  }]\\u30A7,\n  },\n  [\"objTypeBody\"]\n);\n\nconst singleLineArrayObjectTypeTempl = genTemplateWithVars(\n  {\n    arrayObjectType: () => \\u30A7Array<{ objTypeBody}>\\u30A7,\n  },\n  [\"objTypeBody\"]\n);\n\nconst schemaSingleLineArrayObjectTypeTempl = genTemplateWithVars(\n  {\n    arrayObjectType: () => \\u30A7[{ objTypeBody}]\\u30A7,\n  },\n  [\"objTypeBody\"]\n);\n\nconst semiColonTypes = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7  typeKeyName: typeValue;\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\n\nconst singleTypeTempl = genTemplateWithVars(\n  {\n    singleType: () => \\u30A7typeKeyName: typeValue\\u30A7,\n  },\n  [\"typeKeyName\", \"typeValue\"]\n);\nconst templateTypeValueTempl = {\n  schemaTemplType: () => \\u30A7Template\\u30A7,\n};\nconst stringTypeValueTempl = {\n  schemaStrType: () => \\u30A7string\\u30A7,\n};\nconst stringArrayTypeValueTempl = {\n  schemaStrArrType: () => \\u30A7string[]\\u30A7,\n};\nconst templateArrayTypeValueTempl = {\n  schemaTemplArrType: () => \\u30A7Template[]\\u30A7,\n};\n\nconst singleLineTypeFuncKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7  typeKeyName: (typeFuncBody) => typeFuncReturn,\\xD8n\\u30A7,\n  },\n\n  [\"typeKeyName\", \"typeFuncBody\", \"typeFuncReturn\"]\n);\n\nconst inlineSemiColonFuncKeyVal = genTemplateWithVars(\n  {\n    typeKeyVal: () => \\u30A7typeKeyName: (typeFuncBody) => typeFuncReturn;\\u30A7,\n  },\n\n  [\"typeKeyName\", \"typeFuncBody\", \"typeFuncReturn\"]\n);\n`,\n'fileContents34': () => `\nimport {\n  collapseAllBelowChildrenOfKey,\n  sortTemplateByDeps,\n  FoldMode,\n  genTemplateWithVars,\n  joiner,\n  joinOnSameValue,\n  orderedFold,\n  performIfHasTemplates,\n  performOnNodes,\n  recursiveFold,\n  replaceWithAllIsomorphic,\n  swapValuesForGenericKeysWithCb,\n  generateTemplateFromTemplate,\n  multiply,\n  mapIndexOfKey1AndValueOfKey2ToKey3,\n  performIfGenericKeyIsTemplate,\n  performIfHasGenericKey,\n  tts,\n  makeTemplateGenericAtKey,\n  findFirst,\n  findLast,\n  performIfNotGenericKeyHasValue\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\n\n\nconst fullWord = genTemplateWithVars(\n  {\n    fullWord: () => \\u30A7export function wordName(wordInput: Template) {\n  wordBody\n}\\u30A7,\n  },\n  [\"wordName\", \"wordBody\"]\n);\n\nexport function buildWordFromNameAndBody(name: string, body: Template) {\n  const nameTempl = { wordName: () => \\u30A7\\xA7{name}\\u30A7 };\n  const word = multiply(multiply(fullWord, body), nameTempl);\n  return word;\n}\nexport function buildWordBodyFromSteps(steps: string) {\n  const file = { file: () => steps };\n  //console.log(\"STEPS\", steps)\n  const stepOf = orderedFold(file, [stepBody], { mode: FoldMode.Strict });\n  if (stepOf == null) throw new Error(\"null fold\");\n  const stepOfResult = { ...stepOf.result, ...stepOf.divisors };\n  //console.log(\"OFRESULT\", tts(stepOfResult, false));\n  const sortedByDeps = sortTemplateByDeps(stepOfResult);\n  // console.log(\"OFRESULT\", tts(sortedByDeps, false));\n  const stepFunctions = performOnNodes(\n    sortedByDeps,\n    \"stepElement\",\n    createFunctionCodeFromStep\n  );\n  // console.log(\"STEP FUNCTIONS\", tts(stepFunctions, false));\n\n  const word = buildWordBody(stepFunctions);\n  //console.log(\"FINAL WORD\", tts(word, false));\n\n  return word;\n}\nfunction buildWordBody(stepExpressions: Template) {\n  // create word wrapper with name, etc\n  // build the return stmt from the last stepExpression, orderFold on const name =\n  const lastStepExpr = findLast(stepExpressions, \"stepExpression\");\n\n  const something = orderedFold(lastStepExpr, [stepExprName], {\n    mode: FoldMode.Strict,\n  });\n  if (something == null) return stepExpressions;\n  const { result } = something;\n  const nameExpr = findFirst(result, \"name\");\n  const generic = makeTemplateGenericAtKey(nameExpr, \"name\");\n  const retStepExpr = genTemplateWithVars(\n    {\n      stepExpression99999: () => \\u30A7return name;\\u30A7,\n    },\n    [\"name\"]\n  );\n  const returnStmt = multiply(generic, retStepExpr);\n  const combined = { ...stepExpressions, ...returnStmt };\n  return joiner(combined, \"stepExpression\", \"wordBody\", \"\\xD8n\");\n}\n\nfunction createFunctionCodeFromStep(stepTemplate: Template, index: number) {\n  console.log(\"STEP TEMPLATE\", tts(stepTemplate, false));\n  const of = recursiveFold(\n    stepTemplate,\n    [outputNameSchema, templNameSchema, inputSchemaTempl, inputValuesTempl],\n    [],\n    { scope: () => \\u30A7\\xD8n\\u30A7 },\n    \"  \",\n    1\n  );\n  const ofResult = { ...of.result, ...of.divisors };\n  console.log(\"OF RESULT W#@@@\", ofResult);\n  const typed = performOnNodes(ofResult, \"inputSchema\", (t: Template) => {\n    // TODO: ADD cb TEMPLATE\n    const of = recursiveFold(\n      t,\n      [\n        inputSchemaObjectBody,\n        quotedSchemaKeyVal,\n        inputSchemaArrayKeyVal, //save for last\n        endingSchemaKeyVal,\n      ],\n      [],\n      { scope: () => \\u30A7\\xD8n\\u30A7 },\n      \"  \",\n      6\n    );\n    if (of == null) throw new Error(\"null fold\");\n    const allOf = { ...of.result, ...of.divisors };\n    // NEW: create code template from the schema stuff\n    console.log(\"ALL OF\", tts(allOf, false));\n    return allOf;\n  });\n\n  const valuesParsed = performOnNodes(typed, \"inputValues\", (t: Template) => {\n    const of = recursiveFold(\n      t,\n      [\n        inputValueObjectBody,\n        quotedValueKeyVal, //save for last\n        inputValueArrayKeyVal,\n        endingValueKeyVal,\n      ],\n      [],\n      { scope: () => \\u30A7\\xD8n\\u30A7 },\n      \"  \",\n      6\n    );\n    if (of == null) throw new Error(\"null fold\");\n    const allOf = { ...of.result, ...of.divisors };\n\n    return allOf;\n  });\n  const templateTypeTempl = {\n    templateType: () => \\u30A7Template\\u30A7,\n  };\n\n  const stringTypeTempl = {\n    stringType: () => \\u30A7String\\u30A7,\n  };\n\n  const stringArrayTypeTempl = {\n    stringArrayType: () => \\u30A7StringArray\\u30A7,\n  };\n\n  const templateArrayTypeTempl = {\n    templateArrayType: () => \\u30A7TemplateArray\\u30A7,\n  };\n\n  const numberTypeTempl = {\n    numberType: () => \\u30A7Number\\u30A7,\n  };\n\n  const joinedOnValue = joinOnSameValue(\n    \"schemaInputKey\",\n    \"valueInputKey\",\n    (t: Template) => {\n      console.log(\"JOIN ON VALUE\", tts(t, false));\n      // we leave strings as is, so don't bother transforming them.\n      // stick to Template and Number.\n      // ONLY DO THIS on the schemaInputKey. If you check valueInputKey for these templates, it'll snag the wrong ones.\n      const t1 = performIfGenericKeyIsTemplate(\n        t,\n        \"schemaInputValue\",\n        templateTypeTempl,\n        (t: Template) => {\n          // the beautiful replaceWithAllIsomorphic\n          // DO THE THING HERE WHERE WE REPLACE THE STRING\n          console.log(\"THIS IS WHERE WE DO IT\", t);\n          const iso = replaceWithAllIsomorphic(t, [\n            quotedKeyUnquotedValueTemplPool,\n          ]);\n          console.log(\"AND THEN ISO\", iso);\n          return iso;\n        }\n      );\n\n      const t2 = performIfGenericKeyIsTemplate(\n        t1,\n        \"schemaInputValue\",\n        templateArrayTypeTempl,\n        (t: Template) => {\n          // you can flip and flop and do a bunch of gymnastics\n          // but sometime the quickest path is just a string replace.\n          const newlyArrayed = swapValuesForGenericKeysWithCb(t, [\n            {\n              key: \"valueInputValue\",\n              newValue: (str: string) => {\n                return \\u30A7[\\xA7{str\n                  .split('\"')\n                  .map((s) => (s.includes(\"\\xD8n\") ? s : \"templPool.\" + s))\n                  .join(\"\")}]\\u30A7;\n              },\n            },\n          ]);\n\n          return newlyArrayed;\n        }\n      );\n\n      const t3 = performIfHasTemplates(t2, [numberTypeTempl], (t: Template) => {\n        const iso = replaceWithAllIsomorphic(t, [quotedKeyUnquotedValue]);\n        return iso;\n      });\n\n      return t3;\n    },\n    valuesParsed,\n    undefined\n  );\n\n  // this will come home to bite us.\n  // it only collapses the arrays.\n  // what when there's an object to pass?\n  // ...actually I guess you'd just pass the object.\n  // ......huh.\n  const collapsedAtArray = collapseAllBelowChildrenOfKey(\n    joinedOnValue,\n    \"inputValueArrayKeyVal\"\n  );\n  const collapsedSchema = collapseAllBelowChildrenOfKey(\n    collapsedAtArray,\n    \"inputSchemaArrayKeyVal\"\n  );\n  console.log(\"COLLAPSEATARRY\", tts(collapsedSchema, false));\n  const joinedOnValueAfterCollapse = joinOnSameValue(\n    \"valueInputKey\",\n    \"schemaInputKey\",\n    (t: Template) => {\n      console.log(\"NEXT JOIN ON VALUE\", t);\n      // we leave strings as is, so don't bother transforming them.\n      // stick to Template and Number.\n      const t0 = performIfHasGenericKey(\n        t,\n        \"inputSchemaArrayKeyVal\",\n        (t: Template) => {\n          //  console.log(\"OBJECT WORK\", tts(t,false))\n          const newlyArrayed = swapValuesForGenericKeysWithCb(t, [\n            {\n              key: \"valueInputValue\",\n              newValue: (str: string) => \\u30A7[\\xA7{str}]\\u30A7,\n            },\n          ]);\n          return newlyArrayed;\n        }\n      );\n      //console.log(\"__________________________________________\")\n      const t1 = performIfGenericKeyIsTemplate(\n        t0,\n        \"schemaInputValue\",\n        stringTypeTempl,\n        (t: Template) => {\n          // the beautiful replaceWithAllIsomorphic\n          const swapped = swapValuesForGenericKeysWithCb(t, [\n            { key: \"valueInputValue\", newValue: (s) => \\u30A7\"\\xA7{s}\"\\u30A7 },\n          ]);\n          return swapped;\n        }\n      );\n      const t2 = performIfGenericKeyIsTemplate(\n        t1,\n        \"schemaInputValue\",\n        templateTypeTempl,\n        (t: Template) => {\n          // performIfHasValue(t, \"schemaInputKey\", \"input\", (t: Template) => { })\n          const res = performIfNotGenericKeyHasValue(\n            t,\n            \"schemaInputKey\",\n            \"input\",\n            (t: Template) => {\n              console.log(\"I THINK THIS IS IT\", t);\n              const swapped = swapValuesForGenericKeysWithCb(t, [\n                { key: \"valueInputValue\", newValue: (s) => \\u30A7templPool.\\xA7{s}\\u30A7 },\n              ]);\n              return swapped;\n            }\n          );\n          return res;\n        }\n      );\n      // what I want from this is {arg232: () => viv}\n      const t3 = mapIndexOfKey1AndValueOfKey2ToKey3(\n        t2,\n        \"schemaInputKey\",\n        \"valueInputValue\",\n        \"arg\"\n      );\n      console.log(\"WHAT IS t2\", t3);\n      return t3;\n    },\n    collapsedSchema,\n    \"schemaInputKey\"\n  );\n  console.log(\"POST COLLAPDS\", tts(joinedOnValueAfterCollapse, false));\n\n  const wordTemplate = generateTemplateFromTemplate(\n    joinedOnValueAfterCollapse,\n    \"stepExpression\" + index,\n    \\u30A7const varNameForOutput = templName(arg);\\u30A7,\n    [\"varNameForOutput\", \"templName\", \"arg\"],\n    [{ key: \"arg\", delimiter: \", \" }]\n  );\n\n  const step = multiply(wordTemplate, joinedOnValueAfterCollapse);\n  // console.log(\"step TEMPLATE\", tts(step, false));\n  return step;\n  /*\n  const sortedJoinedOnValueAfterCollapse = sortTemplateByDeps(\n    joinedOnValueAfterCollapse\n  );\n  //console.log(\"SORTED\", tts(sortedJoinedOnValueAfterCollapse, false));\n  const joinedValues = joiner(\n    sortedJoinedOnValueAfterCollapse,\n    \"valueInputValue\",\n    \"stepArgs\",\n    \", \"\n  );\n  //console.log(\"ALL JOINED\", tts(joinedValues, false));\n\n  const stepTempl = genTemplateWithVars(\n    {\n      [\"stepExpression\" + index]: () =>\n        \\u30A7const varNameForOutput = templName(stepArgs);\\xD8n\\u30A7,\n    },\n    [\"varNameForOutput\", \"templName\", \"stepArgs\"]\n  );\n\n  const step = applyToGenericHomomorphism(\n    { ...collapsedAtArray, ...joinedValues },\n    stepTempl\n  );\n  \n  console.log(\"STEP FINAL\", tts(step,false))\n  return step;\n  */\n}\n\nconst inputSchemaTempl = genTemplateWithVars(\n  {\n    inputSchema: () => \\u30A7\\xD8n    \"inputSchema\": {schemaBody\n    }\\u30A7,\n  },\n  [\"schemaBody\"]\n);\n\nconst inputValuesTempl = genTemplateWithVars(\n  {\n    inputValues: () => \\u30A7\\xD8n    \"inputValues\": {inputValuesBody\n    }\\u30A7,\n  },\n  [\"inputValuesBody\"]\n);\nconst templNameSchema = genTemplateWithVars(\n  {\n    templNameSchema: () => \\u30A7\\xD8n    \"name\": \"templName\",\\u30A7,\n  },\n  [\"templName\"]\n);\n\nconst outputNameSchema = genTemplateWithVars(\n  {\n    outputNameSchema: () => \\u30A7\\xD8n    \"outputName\": \"varNameForOutput\",\\u30A7,\n  },\n  [\"varNameForOutput\"]\n);\n\nconst inputSchemaArrayKeyVal = genTemplateWithVars(\n  {\n    inputSchemaArrayKeyVal: () =>\n      \\u30A7\\xD8n      \"schemaInputKey\": [schemaInputValue\\xD8n      ],\\u30A7,\n  },\n  [\"schemaInputKey\", \"schemaInputValue\"]\n);\n\nconst inputSchemaObjectBody = genTemplateWithVars(\n  {\n    inputSchemaObjectBody: () => \\u30A7      {schemaObjectBody\\xD8n      }\\u30A7,\n  },\n  [\"schemaObjectBody\"]\n);\n\nconst quotedSchemaKeyVal = genTemplateWithVars(\n  {\n    inputSchemaKeyVal: () => \\u30A7\\xD8n    \"schemaInputKey\": \"schemaInputValue\",\\u30A7,\n  },\n  [\"schemaInputKey\", \"schemaInputValue\"]\n);\n\nconst endingSchemaKeyVal = genTemplateWithVars(\n  {\n    inputSchemaKeyVal: () => \\u30A7\\xD8n    \"schemaInputKey\": \"schemaInputValue\"\\u30A7,\n  },\n  [\"schemaInputKey\", \"schemaInputValue\"]\n);\n\nconst inputValueArrayKeyVal = genTemplateWithVars(\n  {\n    inputValueArrayKeyVal: () =>\n      \\u30A7\\xD8n      \"valueInputKey\": [valueInputValue\\xD8n      ]\\u30A7,\n  },\n  [\"valueInputKey\", \"valueInputValue\"]\n);\n\nconst inputValueObjectBody = genTemplateWithVars(\n  {\n    inputValueObjectBody: () => \\u30A7      {valueObjectBody\\xD8n      }\\u30A7,\n  },\n  [\"valueObjectBody\"]\n);\n\nconst quotedValueKeyVal = genTemplateWithVars(\n  {\n    inputValueKeyVal: () => \\u30A7\\xD8n    \"valueInputKey\": \"valueInputValue\",\\u30A7,\n  },\n  [\"valueInputKey\", \"valueInputValue\"]\n);\n\nconst quotedKeyUnquotedValue = genTemplateWithVars(\n  {\n    inputValueKeyVal: () => \\u30A7\\xD8n    \"valueInputKey\": valueInputValue,\\u30A7,\n  },\n  [\"valueInputKey\", \"valueInputValue\"]\n);\n\nconst quotedKeyUnquotedValueTemplPool = genTemplateWithVars(\n  {\n    inputValueKeyVal: () => \\u30A7\\xD8n    \"valueInputKey\": templPool.valueInputValue,\\u30A7,\n  },\n  [\"valueInputKey\", \"valueInputValue\"]\n);\n\nconst endingValueKeyVal = genTemplateWithVars(\n  {\n    inputValueKeyVal: () => \\u30A7\\xD8n    \"valueInputKey\": \"valueInputValue\"\\u30A7,\n  },\n  [\"valueInputKey\", \"valueInputValue\"]\n);\n\nconst stepBody = genTemplateWithVars(\n  {\n    stepBody: () => \\u30A7\\xD8n  {stepElement\\xD8n  }\\u30A7,\n  },\n  [\"stepElement\"]\n);\n\nconst stepExprName = genTemplateWithVars(\n  {\n    stepExprName: () => \\u30A7const name = \\u30A7,\n  },\n  [\"name\"]\n);\n`,\n'fileContents35': () => `\nconst React = require('react');\nconst ReactDOM = require('react-dom');\nimport '@fontsource/inter';\n\n// Component import\nimport App from './components/App';\n\nReactDOM.render(<App />, document.getElementById('root') as HTMLElement);\n`,\n'fileContents36': () => `\nexport function getNonce() : string {\n  let text : string = \"\";\n  const possible : string =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  for (let i = 0; i < 32; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n}`,\n'fileContents37': () => `\nimport * as vscode from 'vscode';\nimport PanelClass from './panel'\n\n\nexport function activate(extContext: vscode.ExtensionContext) {\n    extContext.subscriptions.push(vscode.commands.registerCommand('symmetric-blueprints.start', () => {\n        PanelClass.createOrShow(extContext);\n\t}));\n    extContext.subscriptions.push(vscode.commands.registerCommand('symmetric-blueprints.insertActiveEditorFile', () => {\n        PanelClass.insertFileIntoTemplate(extContext);\n\t}));\n};\n\nexport function deactivate() { }`,\n'fileContents38': () => `\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport { readFromConfig } from \"./services/commandService\";\nimport { FoldMode, genTemplateWithVars, orderedFold, stringCleaning, tts } from \"symmetric-parser\";\n\nconst execAsync = promisify(exec);\n\nconst fullWord = genTemplateWithVars(\n  {\n    fullWord: () => \\u30A7export function wordName(wordInput: Template): Template {wordBody\\xD8n}\\u30A7,\n  },\n  [\"wordName\", \"wordBody\"]\n);\n// Run the compiled index.js file\nexport async function runIndexFile(outputDirectory) {\n  const indexPath = path.join(outputDirectory, \"src/index.ts\");\n  try {\n    const { stdout, stderr } = await execAsync(\\u30A7bun run \\xA7{indexPath}\\u30A7);\n    console.log(\"FROM STDOUT\", stdout);\n    if (stderr) console.error(stderr);\n    return stdout;\n  } catch (error) {\n    console.error(\\u30A7Execution error: \\xA7{error}\\u30A7);\n  }\n}\n\nexport async function saveWord(wordContents: string, wordsFilePath: string) {\n  const wordsContents = await fs.readFile(wordsFilePath, { encoding: \"utf8\" });\n  const cleaned = stringCleaning(wordsContents)\n  const t = {file: ()=> cleaned}\n  const wordTempls = orderedFold(t, [fullWord],{mode:FoldMode.AllOrNothing}) \n  if(wordTempls == null) {\n    console.error(\"Could not parse word file for some reason\")\n    return;\n  }\n  const {result, divisors} = wordTempls;\n  console.log(\"result\", tts(result,false), \"divisors\", tts(divisors,false))\n  \n}\n\nexport async function saveFile(filePath:string,fileContents:string) {\n  return fs.writeFile(filePath, fileContents);\n}\n\nexport async function readFile(filePath:string) {\n  return fs.readFile(filePath, { encoding: \"utf8\" });\n}\n\nexport async function runTs(generatorFilePath: string) {\n  try {\n    const { stdout, stderr } = await execAsync(\\u30A7bun run \\xA7{generatorFilePath}\\u30A7);\n    console.log(\"generator FROM STDOUT\", stdout);\n    if (stderr) console.error(stderr);\n    return stdout;\n  } catch (error) {\n    console.error(\\u30A7Execution error: \\xA7{error}\\u30A7);\n  }\n}`,\n'fileContents39': () => `\n`,\n'hookHandlerBody01': () => `\n        console.log(\"handling generator result\");\n        handleQueueUpdate(message);\n        `,\n'hookHandlerBody02': () => `\n        console.log(\"handling generator result\")\n        handleGeneratorResult(message);\n        `,\n'hookHandlerBody03': () => ` {\n        if (isMainTemplate) {\n          const { contents, filePath } = message.data;\n          const funcPart = argsAndTemplateToFunction([], contents);\n          const templ = { [filePath]: funcPart };\n          //console.log(\"FILE INSERT\", contents, filePath, templ);\n          insertTemplateIntoTemplate(templ);\n        }\n        `,\n'hookHandlerName01': () => \"queue_update\",\n'hookHandlerName02': () => \"generator_result\",\n'hookHandlerName03': () => \"file_insert\",\n'panelCommandBody01': () => ` {\n            const { template } = msg;\n\n            const templ = new Function(\"return \" + template)();\n            // we expect a compiled template here, so no denoms for anything, or an error if so\n            const templFileKeys = Object.keys(templ).filter(\n              (k) => k.indexOf(\".\") > -1\n            );\n            //console.log(\"TEMPL FILE KEYS\", templFileKeys);\n            const pathToConfig = this.runner.currentStep.config;\n            const filePathHashes = await getFilePathHashes(pathToConfig);\n            //console.log(\"FILE PATH HASHES\", filePathHashes);\n            for (const filePathHash of templFileKeys) {\n              //console.log(\"filepathhash\", filePathHash);\n              // we expect a compiled template here, so no denoms for anything, or an error if so\n              const filePath = filePathHashes[filePathHash];\n              //console.log(\"FILE PATH\", filePath);\n              const fileContents = templ[filePathHash]();\n              //console.log(\"writing file\", filePath, \"\\xD8n<>CONTENTS<>\\xD8n\",fileContents);\n              await overwriteFile(filePath, fileContents);\n            }\n\n            `,\n'panelCommandBody02': () => `\n            console.log(\"message received\");\n            // ensure bun is set up for the thing\n\n            `,\n'panelCommandBody03': () => `\n            console.log(\"reachedBrain\");\n            this._panel!.webview.postMessage({ command: \"refactor\" });\n            `,\n'panelCommandBody04': () => `\n            `,\n'panelCommandBody05': () => ` {\n            const { word } = msg;\n            const pathToConfig = this.runner.currentStep.config;\n            const wordsFile = await readFromConfig(\"WORDS_FILE\", pathToConfig);\n            // save to word file\n            const result = await saveWord(word, wordsFile);\n            `,\n'panelCommandName01': () => \"save_all_files\",\n'panelCommandName02': () => \"startup\",\n'panelCommandName03': () => \"testing\",\n'panelCommandName04': () => \"build_project\",\n'panelCommandName05': () => \"save_word\",\n'panelCommandName06': () => \"store_runnable_word\",\n'panelCommandName07': () => \"get_word\",\n'panelCommandName08': () => \"create_word\",\n'panelCommandName09': () => \"add_full_template\",\n'panelCommandName010': () => \"add_template\",\n'panelCommandName011': () => \"run_generator\",\n'panelCommandName012': () => \"run_word\",\n'panelCommandName013': () => \"add_filled_generator\",\n'panelCommandName014': () => \"save_word_steps\",\n'panelCommandName015': () => \"transition\",\n'panelCommandName016': () => \"select_queue\",\n'panelCommandName017': () => \"fetch_from_config\",\n'webviewCommandName11': () => \"config_data\",\n'webviewCommandName12': () => \"config_data\",\n'webviewCommandName13': () => \"config_data\",\n'webviewCommandName14': () => \"word_saved\",\n'webviewCommandName15': () => \"all_filled_generators\",\n'webviewCommandName16': () => \"word_run_result\",\n'webviewCommandName17': () => \"generator_result\",\n'webviewCommandName18': () => \"all_templates\",\n'webviewCommandName19': () => \"all_templates\",\n'webviewCommandName110': () => \"word_contents\",\n'webviewCommandName111': () => \"word_contents\",\n'webviewCommandName112': () => \"all_runnable_words\"\n}\n","files":{"generatorFilePath":"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/src/pools/1736096291002_generator.ts","resultFilePath":"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/src/pools/1736096291002_result"}}]