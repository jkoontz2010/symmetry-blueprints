{
'panel.ts3f5913a659/fileContents1': ({fileContents1})=>`${run(fileContents1, 'fileContents1')}`,
'useTemplate.ts60c890fb5b/fileContents2': ({fileContents2})=>`${run(fileContents2, 'fileContents2')}`,
'wordRunService.tsaa3e96021c/fileContents3': ({fileContents3})=>`${run(fileContents3, 'fileContents3')}`,
'fsService.tse294b67673/fileContents4': ({fileContents4})=>`${run(fileContents4, 'fileContents4')}`,
'configService.ts0198e0307e/fileContents5': ({fileContents5})=>`${run(fileContents5, 'fileContents5')}`,
'commandService.ts69cdb52686/fileContents6': ({fileContents6})=>`${run(fileContents6, 'fileContents6')}`,
'parseWords.ts0da51f25b2/fileContents7': ({fileContents7})=>`${run(fileContents7, 'fileContents7')}`,
'hotKeyBuilder.ts6daa92dc78/fileContents8': ({fileContents8})=>`${run(fileContents8, 'fileContents8')}`,
'parseTemplates.tsbf975773bc/fileContents9': ({fileContents9})=>`${run(fileContents9, 'fileContents9')}`,
'util.ts2d61ca9574/fileContents10': ({fileContents10})=>`${run(fileContents10, 'fileContents10')}`,
'useWordBuilder.ts50447cadc3/fileContents11': ({fileContents11})=>`${run(fileContents11, 'fileContents11')}`,
'useRunner.ts2d1ba9b42e/fileContents12': ({fileContents12})=>`${run(fileContents12, 'fileContents12')}`,
'useQueueListener.ts0a03de5ffe/fileContents13': ({fileContents13})=>`${run(fileContents13, 'fileContents13')}`,
'useMeta.tsaa5e4c5ba3/fileContents14': ({fileContents14})=>`${run(fileContents14, 'fileContents14')}`,
'useHotkeys.ts3ae905fc81/fileContents15': ({fileContents15})=>`${run(fileContents15, 'fileContents15')}`,
'useFileSystem.ts4f87732c11/fileContents16': ({fileContents16})=>`${run(fileContents16, 'fileContents16')}`,
'hgcgUtil.ts791df9ac7f/fileContents17': ({fileContents17})=>`${run(fileContents17, 'fileContents17')}`,
'v2.tsx715fc7afef/fileContents18': ({fileContents18})=>`${run(fileContents18, 'fileContents18')}`,
'WordCreator.tsx4102c005c8/fileContents19': ({fileContents19})=>`${run(fileContents19, 'fileContents19')}`,
'WordBuilderForm.tsxec964c89ec/fileContents20': ({fileContents20})=>`${run(fileContents20, 'fileContents20')}`,
'TemplateTree.tsx0524a0d899/fileContents21': ({fileContents21})=>`${run(fileContents21, 'fileContents21')}`,
'SortableItem.tsx3cad9f1f40/fileContents22': ({fileContents22})=>`${run(fileContents22, 'fileContents22')}`,
'QueueHeader.tsx6dd24430ee/fileContents23': ({fileContents23})=>`${run(fileContents23, 'fileContents23')}`,
'Item.tsxc641ad44fb/fileContents24': ({fileContents24})=>`${run(fileContents24, 'fileContents24')}`,
'GTWVEditor.tsxf2771a3915/fileContents25': ({fileContents25})=>`${run(fileContents25, 'fileContents25')}`,
'DynamicFormOld3.tsx0cf8ec536f/fileContents26': ({fileContents26})=>`${run(fileContents26, 'fileContents26')}`,
'DynamicForm.tsxdf152500d9/fileContents27': ({fileContents27})=>`${run(fileContents27, 'fileContents27')}`,
'Dropdown.tsx30dab73e04/fileContents28': ({fileContents28})=>`${run(fileContents28, 'fileContents28')}`,
'BuilderAccordion.tsxf6c47abb17/fileContents29': ({fileContents29})=>`${run(fileContents29, 'fileContents29')}`,
'App.tsxe233888b2d/fileContents30': ({fileContents30})=>`${run(fileContents30, 'fileContents30')}`,
'.DSfa3f423110/fileContents31': ({fileContents31})=>`${run(fileContents31, 'fileContents31')}`,
'runner.ts09798de81d/fileContents32': ({fileContents32})=>`${run(fileContents32, 'fileContents32')}`,
'parseGenerators.tsa908b43054/fileContents33': ({fileContents33})=>`${run(fileContents33, 'fileContents33')}`,
'createWordFromJson.ts895f3edd7a/fileContents34': ({fileContents34})=>`${run(fileContents34, 'fileContents34')}`,
'index.tsxec7ce083ed/fileContents35': ({fileContents35})=>`${run(fileContents35, 'fileContents35')}`,
'getNonce.ts47b72c4626/fileContents36': ({fileContents36})=>`${run(fileContents36, 'fileContents36')}`,
'extension.tsec46bfbfac/fileContents37': ({fileContents37})=>`${run(fileContents37, 'fileContents37')}`,
'compiler.tsc3618913d2/fileContents38': ({fileContents38})=>`${run(fileContents38, 'fileContents38')}`,
'.DSe7e2950e98/fileContents39': ({fileContents39})=>`${run(fileContents39, 'fileContents39')}`,
'fileContents11/commandSend03': ({commandSend03})=>`
import { customAlphabet } from "nanoid";
import { useState } from "react";
import { genTemplateWithVars } from "symmetric-parser";
import { Template } from "symmetric-parser/dist/src/templator/template-group";

import { cloneDeep } from "lodash";
import { setKeyValue } from "./util";
import {
  buildWordBodyFromSteps,
  buildWordFromNameAndBody,
} from "../util/parsers/createWordFromJson";

export type BuilderWord = {
  name: string;
  steps: BuilderGenerator[];
};
export type BuilderTemplate = {
  name: string;
  templateBody: string; // the body of the template
  vars: string[]; // the variables in the template
};

export type Schema = Record<string, any>;

export type BuilderGenerator = {
  name: string;
  inputs?: Record<string, any>;
  inputSchema: Schema;
  outputName?: string;
};

export type BuilderNewWord = {
  wordName: string;
  steps: BuilderGenerator[];
};

export enum Types {
  Template = "Template",
  TemplateArray = "TemplateArray",
  String = "String",
  StringArray = "StringArray",
  Number = "Number",
  Object = "Object", // recurse on this
  Function = "Function",
  ArrayOfObjects = "ArrayOfObjects", // recurse on this*/
}
const firsty: Template = {
  firsty: () => ェthis is where we do itェ,
};
const secondy: Template = {
  secondy: () => ェthat is the second timeェ,
};

const thirdy: Template = {
  thirdy: () => ェthis is the third timeェ,
};
const fourthy: Template = {
  fourthy: () => ェthis is the fourth timeェ,
};
const fifthy: Template = {
  fifthy: () => ェthis is the fifth timeェ,
};
const sixthy: Template = genTemplateWithVars(
  { sixthy: () => "I hope this works" },
  ["hope"]
);

function buildInputsFromSchema(schema: Schema) {
  const inputs: Record<string, any> = {};
  Object.entries(schema).forEach(([key, type]) => {
    if (type === Types.Template) {
      inputs[key] = null;
    } else if (type === Types.TemplateArray) {
      inputs[key] = [];
    } else if (type === Types.String) {
      inputs[key] = "";
    }
  });
  return inputs;
}

const identityGenerator: BuilderGenerator = {
  name: "identity",
  inputSchema: { template: Types.Template },
  inputs: { template: null },
};

const combineAllGenerator: BuilderGenerator = {
  name: "combineAll",
  inputSchema: { templates: Types.TemplateArray },
};

const combineGenerator = {
  name: "combine",
  generator: (template1: Template, template2: Template) => ({
    ...template1,
    ...template2,
  }),
  inputSchema: {
    template1: Types.Template,
    template2: Types.Template,
  },
  inputs: { template1: null, template2: null },
};
export function useWordBuilder({
  wordsMeta,
  templatesMeta,
  generatorsMeta,
  postMessage,
}: {
  wordsMeta: BuilderWord[];
  templatesMeta: BuilderTemplate[];
  generatorsMeta: BuilderGenerator[];
  postMessage: any;
}) {
  const [newWord, setNewWord] = useState<BuilderNewWord>({
    wordName: "new", // handled by form now, sorry for the tech debt!
    steps: [],
  });
  const [runtimeError, setRuntimeError] = useState<string | null>(null);

  function addStepToWord(step: any, position: number) {
    // if step doesn't have an output, we create one.
    // this should be specified by the generator...

    const alphabet =
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    const nanoid = customAlphabet(alphabet, 4);
    const stepOutputId = nanoid();

    const newStep = {
      ...step,
      outputName: step.name + "_" + stepOutputId,
      ...buildInputsFromSchema(step.inputSchema),
    };

    setNewWord((prev) => {
      const newSteps = [...prev.steps];
      newSteps.splice(position, 0, newStep);
      const stepsWithInput = setAllStepInputsToPriorStepOutput(newSteps);
      console.log("NEW STEPS", stepsWithInput);
      return { ...prev, steps: stepsWithInput };
    });
  }

  function submitWord(formSubmission: any) {
    console.log("SUBMITTING", formSubmission);
    // grab steps
    // update the values at each step
    const newSteps = newWord.steps.map((step) => {
      const stepOutputName = step.outputName;
      const formStep = formSubmission[stepOutputName];
      // put step values from formStep into step
      return { ...step, inputValues: formStep };
    });

    console.log("NEW WORD", JSON.stringify(newSteps, null, 2));

    const parsedSteps = buildWordBodyFromSteps(
      JSON.stringify(newSteps, null, 2)
    );
    const fullWord = buildWordFromNameAndBody(
      formSubmission.wordName,
      parsedSteps
    );
    // TODO: MAKE CONFIGURABLE

    console.log("PARSED STEPS", fullWord);
   ${run(commandSend03, 'commandSend03')}
    console.log("POSTED MESSAGE");
  }

  function setAllStepInputsToPriorStepOutput(steps) {
    return steps.map((step, idx) => {
      const priorStepOutput = steps[idx - 1]?.outputName ?? "wordInput";
      const inputSchema = cloneDeep(step.inputSchema);
      delete step.inputSchema;
      const newStep = setKeyValue("input", priorStepOutput, step);
      newStep.inputSchema = inputSchema;
      return newStep;
    });
  }

  function removeStepFromWord(position: number) {
    // go thru all steps. if any step uses output from
    // the deleted step, remove that output!
    const { steps } = newWord;
    const removedStep = steps[position];
    const removedOutput = removedStep.outputName;
    const newSteps = steps.filter((step) => {
      console.log("FULL STEP", step);
      if (step.inputs == null) return true;
      const inputs = Object.values(step?.inputs);
      console.log(
        "LOOKING AT",
        inputs,
        removedOutput,
        "FROM STEP",
        step.inputs
      );
      return !inputs.includes(removedOutput);
    });
    setNewWord((prev) => {
      newSteps.splice(position, 1);
      return { ...prev, steps: newSteps };
    });
  }

  function updateStepPosition(from: number, to: number) {
    setNewWord((prev) => {
      const newSteps = [...prev.steps];
      const [removed] = newSteps.splice(from, 1);
      newSteps.splice(to, 0, removed);
      return { ...prev, steps: newSteps };
    });
  }

  function runWord(name: string, input: Template = {}) {
    const outputs: Template[] = [];
    function registerOutput(output: Template) {
      outputs.push(output);
    }
    /*
    const word = words.find((w: BuilderWord) => w.name === name);
    // run the word raw. if any errors occur, let TypeScript return them, and we'll display.
    // we'll need to load it into typescript dynamically, which is very V2.
    try {
      word(input, registerOutput);
    } catch (e) {
      console.error(e);
      setRuntimeError(e.message);
    }
      */
  }

  return {
    newWord,
    runtimeError,
    addStepToWord,
    updateStepPosition,
    runWord,
    removeStepFromWord,
    submitWord,
  };
}
`,
'commandSend03/commandBody03': ({commandBody03})=>` postMessage({${run(commandBody03, 'commandBody03')}});`,
'commandBody03/nameProperty11': ({nameProperty11})=>`
      ${run(nameProperty11, 'nameProperty11')}
      word: fullWord.fullWord(),
      pathToConfig:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig",
    `,
'nameProperty11/commandName11': ({commandName11})=>`command: "${run(commandName11, 'commandName11')}",`,
'fileContents12/commandSend04,commandSend05,commandSend06,commandSend07': ({commandSend04, commandSend05, commandSend06, commandSend07})=>`
import { customAlphabet } from "nanoid";
import React, { useEffect, useState } from "react";
import {
  genTemplateWithVars,
  tts,
  argsAndTemplateToFunction,
} from "symmetric-parser";
import { Template } from "symmetric-parser/dist/src/templator/template-group";

export function useRunner(
  postMessage: any,
  configPath: string,
  filledGeneratorsFileText: string
) {
  const alphabet =
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  const nanoid = customAlphabet(alphabet, 4);
  //console.log("TEST??",filledGeneratorsFileText)
  const [msgId, setMsgId] = useState(nanoid());
  const [generatorModule, setGeneratorModule] = React.useState<any>({});
  const [templateModule, setTemplateModule] = React.useState<any>(null);
  const [wordModule, setWordModule] = React.useState<any>(null);
  const [filledGenerators, setFilledGenerators] = React.useState<Template>(
    new Function("return " + filledGeneratorsFileText)()
  );
  //console.log("FILLED GENERATORs", filledGenerators)
  useEffect(() => {
    setFilledGenerators(new Function("return " + filledGeneratorsFileText)());
  }, [filledGeneratorsFileText]);
  const fetchGenerators = async () => {
    const data = await import("../../pools/utility-templates");
    setGeneratorModule(data);
  };
  const fetchTemplates = async () => {
    const data = await import("../../pools/template-pool");
    //console.log("AFTER IMPORT", data);
    // @ts-ignore
    //console.log("GOOD LUCK", data);
    setTemplateModule(data);
  };

  useEffect(() => {
    fetchGenerators();
    fetchTemplates();
  }, []);

  useEffect(() => {
    window.addEventListener("message", (event) => {
      if (event.data.data.msgId !== msgId) return;
      const message = event.data; // The json data that the extension sent
      switch (message.command) {
        case "all_filled_generators": {
          //console.log("all_filled_generators", message.data);
          const { allFilledGenerators } = message.data;
          setFilledGenerators(new Function("return " + allFilledGenerators)());
          //console.log("NEW ALL FILELD",new Function("return " + allFilledGenerators)())
          break;
        }
      }
    });
  }, []);

  const addFullTemplateToPool = (name: string, template: Template) => {
    if (templateModule[name] != null) {
      throw new Error("Template with this name already exists");
    }
  ${run(commandSend04, 'commandSend04')}
   ${run(commandSend05, 'commandSend05')}
  };

  const addToFilledGeneratorPool = (filledGenerator: Template) => {
    if (Object.keys(filledGenerator).length !== 1) {
      throw new Error("Filled generator must have exactly one key");
    } else {
     ${run(commandSend06, 'commandSend06')}
    }
  };

  const handleSaveAllFiles = (template: Template) => {
   ${run(commandSend07, 'commandSend07')}
  };

  //console.log("here we are", generatorModule, templateModule, wordModule);

  return {
    templateModule,
    handleSaveAllFiles,
    generatorModule,
    wordModule,
    filledGenerators,
    addToTemplatePool,
    addToFilledGeneratorPool,
    addFullTemplateToPool
  };
}
`,
'commandSend07/commandBody07': ({commandBody07})=>` postMessage({${run(commandBody07, 'commandBody07')}});`,
'commandSend06/commandBody06': ({commandBody06})=>` postMessage({${run(commandBody06, 'commandBody06')}});`,
'commandBody06/nameProperty08': ({nameProperty08})=>`
        ${run(nameProperty08, 'nameProperty08')}
        pathToConfig: configPath,
        filledGenerator: tts(filledGenerator, false),
        msgId,
      `,
'nameProperty08/commandName08': ({commandName08})=>`command: "${run(commandName08, 'commandName08')}",`,
'commandSend05/commandBody05': ({commandBody05})=>` postMessage({${run(commandBody05, 'commandBody05')}});`,
'commandBody05/nameProperty09': ({nameProperty09})=>`
      ${run(nameProperty09, 'nameProperty09')}
      key,
      args: JSON.stringify(args),
      value,
      pathToConfig: configPath,
    `,
'nameProperty09/commandName09': ({commandName09})=>`command: "${run(commandName09, 'commandName09')}",`,
'commandSend04/commandBody04': ({commandBody04})=>` postMessage({${run(commandBody04, 'commandBody04')}});`,
'commandBody04/nameProperty10': ({nameProperty10})=>`
    ${run(nameProperty10, 'nameProperty10')}
    name,
    template: tts(template, false),
    pathToConfig: configPath,
   })
  }

  const addToTemplatePool = (key: string, value: string, args: string[]) => {
    const funcPart = argsAndTemplateToFunction([], value);
    const templ = { [key]: funcPart };
    const template = genTemplateWithVars(templ, args);
    //console.log("addToTemplatePool", template);
    if (templateModule[key] != null) {
      throw new Error("Template with this name already exists");
    }
    setTemplateModule((prev) => {
      return {
        ...prev,
        ...{ [key]: template },
      };
    `,
'nameProperty10/commandName10': ({commandName10})=>`command: "${run(commandName10, 'commandName10')}",`,
'commandBody07/nameProperty07': ({nameProperty07})=>`
      ${run(nameProperty07, 'nameProperty07')}
      pathToConfig: configPath,
      template: tts(template),
    `,
'nameProperty07/commandName07': ({commandName07})=>`command: "${run(commandName07, 'commandName07')}",`,
'fileContents16/commandSend08,commandSend09,commandSend010,commandSend011,commandSend012,commandSend013': ({commandSend08, commandSend09, commandSend010, commandSend011, commandSend012, commandSend013})=>`
import React from "react";
import { WordStep } from "./useTemplate";
import { tts } from "symmetric-parser";
import { Template } from "symmetric-parser/dist/src/templator/template-group";

function parseStringifiedTemplateModule(templateModule: string) {
  const templModuleFirstParse = new Function("return " + templateModule)();
  const templModule = Object.keys(templModuleFirstParse).reduce((acc, key) => {
    const templified = new Function("return " + templModuleFirstParse[key])();
    acc[key] = templified;
    return acc;
  }, {});
  return templModule;
}

export function useFileSystem(postMessage) {
  const [all, setAll] = React.useState<any>({
    generatorsFileText: null,
    templatesFileText: null,
    filledGeneratorsFileText: null,
    currentWord: null,
    wordNames: [],
    currentWordName: null,
    templateModule: null,
    allFileTemplates: null,
    runnableWords: null,
    queueNames: [],
    subTemplate: null
  });
  const [loading, setLoading] = React.useState(true);
  React.useEffect(() => {
    window.addEventListener("message", (event) => {
      const message = event.data; // The json data that the extension sent
      switch (message.command) {
        case "config_data": {
          const {
            generators,
            templates,
            filledGenerators,
            currentWord,
            wordNames,
            currentWordName,
            templateModule,
            fileTemplates,
            runnableWords,
            queueNames,
            subTemplate,
          }: {
            generators: string;
            templates: string;
            filledGenerators: string;
            currentWord: string;
            wordNames: string;
            currentWordName: string;
            templateModule: string;
            fileTemplates: string;
            runnableWords: string;
            queueNames: string;
            subTemplate: string;
          } = message.data;
          const rw = JSON.parse(runnableWords);
          const parsedCurrentWord = JSON.parse(currentWord).map((cw) => ({
            ...cw,
            result: new Function("return " + cw.result)(),
          }));
          const parsedAllFileTemplate = new Function(
            "return " + fileTemplates
          )();
          const parsedSubTemplate =
            subTemplate == null
              ? null
              : new Function("return " + subTemplate)();
          const templModule = parseStringifiedTemplateModule(templateModule);
          const parsedWordNames = JSON.parse(wordNames);
          const parsedQueueNames = JSON.parse(queueNames);

          const all ={
            generatorsFileText: generators,
            templatesFileText: templates,
            filledGeneratorsFileText: filledGenerators,
            currentWord: parsedCurrentWord,
            wordNames: parsedWordNames,
            currentWordName: currentWordName,
            templateModule: templModule,
            allFileTemplates: parsedAllFileTemplate,
            runnableWords: rw,
            queueNames: parsedQueueNames,
            subTemplate: parsedSubTemplate,
          };
          setAll(all);
          setLoading(false);
          break;
        }
        case "word_contents": {
          const { wordName, wordContents } = message.data;
          console.log("WORD CONTENTS", message);
          //setCurrentWordName(wordName);
          let parsedCurrentWord;
          if (wordContents === "[]") {
            parsedCurrentWord = [{ result: {} }];
          } else {
            parsedCurrentWord = JSON.parse(wordContents).map((cw) => ({
              ...cw,
              result: new Function("return " + cw.result)(),
            }));
          }
          //setCurrentWord(parsedCurrentWord);
          let newWordNames = all.wordNames;
          if (!all.wordNames.includes(wordName)) {
            newWordNames=[...all.wordNames, wordName];
          }
          setAll((prev) => ({ ...prev, wordNames: newWordNames, currentWord:parsedCurrentWord, currentWordName:wordName }));
          setLoading(false);
          break;
        }
        case "all_templates": {
          const { templateModule } = message.data;
          const templModule = parseStringifiedTemplateModule(templateModule);
          setAll((prev) => ({ ...prev, templateModule: templModule }));
          break;
        }
        case "all_file_templates": {
          const { fileTemplates } = message.data;

          setAll((prev) => ({ ...prev, allFileTemplates: new Function("return " + fileTemplates)() }));
          break;
        }
        case "all_runnable_words": {
          const { runnableWords } = message.data;
          const rw = JSON.parse(runnableWords);
          setAll((prev) => ({ ...prev, runnableWords: rw }));
        }
      }
    });
  }, []);
  const readAllFiles = (queueName: string) => {
   ${run(commandSend08, 'commandSend08')}
  };
  const writeFile = (path, data) => {
   ${run(commandSend09, 'commandSend09')}
  };
  const setWord = (name) => {
   ${run(commandSend010, 'commandSend010')}

    setLoading(true);
  };
  const createNewWord = (name) => {
    // word_contents received in response
   ${run(commandSend011, 'commandSend011')}
    setLoading(true);
  };
  const addToTemplatePool = (key: string, value: string, args: string[]) => {
    console.log("SENDING TO ADD TO TEMPLATE POOL", key, value, args);
   ${run(commandSend012, 'commandSend012')}
  };
  const selectQueue = (queueName) => {
   ${run(commandSend013, 'commandSend013')}
  };

  return {
    readAllFiles,
    createNewWord,
    writeFile,
    setWord,
    addToTemplatePool,
    selectQueue,
    loading,
    ...all,
  };
}
`,
'commandSend013/commandBody013': ({commandBody013})=>` postMessage({${run(commandBody013, 'commandBody013')}});`,
'commandSend012/commandBody012': ({commandBody012})=>` postMessage({${run(commandBody012, 'commandBody012')}});`,
'commandBody012/nameProperty02': ({nameProperty02})=>`
      ${run(nameProperty02, 'nameProperty02')}
      key,
      args: JSON.stringify(args),
      value,
    `,
'nameProperty02/commandName02': ({commandName02})=>`command: "${run(commandName02, 'commandName02')}",`,
'commandSend011/commandBody011': ({commandBody011})=>` postMessage({${run(commandBody011, 'commandBody011')}});`,
'commandBody011/nameProperty03': ({nameProperty03})=>`
      ${run(nameProperty03, 'nameProperty03')}
      wordName: name,
    `,
'nameProperty03/commandName03': ({commandName03})=>`command: "${run(commandName03, 'commandName03')}",`,
'commandSend010/commandBody010': ({commandBody010})=>` postMessage({${run(commandBody010, 'commandBody010')}});`,
'commandBody010/nameProperty04': ({nameProperty04})=>`
      ${run(nameProperty04, 'nameProperty04')}
      wordName: name,
    `,
'nameProperty04/commandName04': ({commandName04})=>`command: "${run(commandName04, 'commandName04')}",`,
'commandSend09/commandBody09': ({commandBody09})=>` postMessage({${run(commandBody09, 'commandBody09')}});`,
'commandBody09/nameProperty05': ({nameProperty05})=>` ${run(nameProperty05, 'nameProperty05')} path, data `,
'nameProperty05/commandName05': ({commandName05})=>`command: "${run(commandName05, 'commandName05')}",`,
'commandSend08/commandBody08': ({commandBody08})=>` postMessage({${run(commandBody08, 'commandBody08')}});`,
'commandBody08/nameProperty06': ({nameProperty06})=>` ${run(nameProperty06, 'nameProperty06')} queueName `,
'nameProperty06/commandName06': ({commandName06})=>`command: "${run(commandName06, 'commandName06')}",`,
'nameProperty01/commandName01': ({commandName01})=>`command: "${run(commandName01, 'commandName01')}",`,
'commandBody013/nameProperty01': ({nameProperty01})=>`
      ${run(nameProperty01, 'nameProperty01')}
      queueName,
    `,
'fileContents1/webviewCommandHandler01': ({webviewCommandHandler01})=>`
import * as vscode from "vscode";
import { getNonce } from "./getNonce";
import * as fs from "fs";
import { readFile, runTs, saveFile, saveWord } from "./compiler";
import {
  argsAndTemplateToFunction,
  insertIntoTemplate,
  tts,
} from "symmetric-parser";
import { Template } from "symmetric-parser/dist/src/templator/template-group";
import {
  getAllWordPathsByLastModified,
  getWordContents,
  getWordNamesFromWordPaths,
  sortFilesByLastModified,
  readFromConfig,
  getWordPath,
  storeFileHash,
  getFilePathHashes,
  overwriteFile,
  getAllFileTemplates,
  saveRunnableWord,
  getAllRunnableWords,
  createRunnableGeneratorFileContents,
} from "./services/commandService";
import { sha1 } from "js-sha1";
import { runWord } from "./services/wordRunService";
import Runner, { DequeueConfig } from "./runner/runner";
import { fetchFromConfig } from "./services/configService";

export function formFilePathHash(filePath: string) {
  const fileName = filePath.split("/").pop();
  const fileHash = sha1(filePath);
  return ェ§{fileHash.substring(0, 10)}_§{fileName}ェ;
}

export function readFromFile(file) {
  return new Promise((resolve, reject) => {
    fs.readFile(file, "utf8", function (err, data) {
      if (err) {
        console.log(err);
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}

const TEST_DEQUEUE: DequeueConfig = {
  name: "test",
  description: "runs fs, grabs the useTemplate file, and takes off parsing it!",
  steps: [
    {
      type: "fs",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.fsconfig",
      name: "testGrab",
      description: "test fs!!",
      waitForTransitionCommand: false,
      transitionAction: "get",
      runWithEmptyTemplate: false,
      word: "getUseTemplate",
    },
    {
      type: "template",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig",
      name: "blank",
      description:
        "starts with blank template. fill with fifth.tsx to ready for next step!",
      waitForTransitionCommand: false,
      transitionAction: "identity",
      runWithEmptyTemplate: false,
    },
    {
      type: "template",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig",
      name: "parseFifth",
      description: "runs the word that parses fifth.tsx",
      word: "ponTesterQueue",
      waitForTransitionCommand: true,
      transitionAction: "identity", // nothing
      runWithEmptyTemplate: false,
    },
  ],
};
const BLANK_TEMPL_DEQUEUE: DequeueConfig = {
  name: "blank template",
  description: "starts out with an empty word",
  steps: [
    {
      type: "template",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig",
      name: "blankTempl",
      description:
        "starts with blank template. fill with fifth.tsx to ready for next step!",
      waitForTransitionCommand: true,
      transitionAction: "identity",
      runWithEmptyTemplate: false,
    },
  ],
};
const POL_DEUQUE: DequeueConfig = {
  name: "polTest",
  description: "grabs anything postMessage-related and queues the links",
  steps: [
    {
      type: "fs",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.fsconfig",
      name: "polFs",
      description:
      "grabs anything postMessage-related",
      waitForTransitionCommand: true,
      transitionAction: "get",
      runWithEmptyTemplate: false,
    },{
      type: "template",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig",
      name: "blankTempl",
      description:
        "starts with blank template. fill with files found from polTest step!",
      waitForTransitionCommand: true,
      word: "fromParserTest",
      transitionAction: "identity",
      runWithEmptyTemplate: false,
    },
  ]
}
const BLANK_FS_DEQUEUE: DequeueConfig = {
  name: "blank fs",
  description: "starts out with an empty word",
  steps: [
    {
      type: "fs",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.fsconfig",
      name: "blankFs",
      description:
        "starts with blank template. fill with fifth.tsx to ready for next step!",
      waitForTransitionCommand: true,
      transitionAction: "identity",
      runWithEmptyTemplate: false,
    },
  ],
};
const ALL_SERVICES_DEQUEUE: DequeueConfig = {
  name: "show all service files",
  description: "testing out how a multi-grab works",
  steps: [
    {
      type: "fs",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.fsconfig",
      name: "blankFs",
      description:
        "starts with blank template. fill with fifth.tsx to ready for next step!",
      waitForTransitionCommand: false,
      transitionAction: "get",
      runWithEmptyTemplate: false,
      word: "getServices",
    },
    {
      type: "template",
      config:
        "/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/.spconfig",
      name: "allServicesTempl",
      description: "all the service files!",
      waitForTransitionCommand: true,
      transitionAction: "identity",
      runWithEmptyTemplate: false,
    },
  ],
};
const ALL_QUEUES = [
  TEST_DEQUEUE,
  BLANK_FS_DEQUEUE,
  BLANK_TEMPL_DEQUEUE,
  ALL_SERVICES_DEQUEUE,
  POL_DEUQUE
];

export default class PanelClass {
  public static currentPanel: PanelClass | undefined;

  private static readonly viewType = "PanelName";

  private readonly _panel: vscode.WebviewPanel;
  private readonly _extensionUri: vscode.Uri;
  private readonly _extContext: vscode.ExtensionContext;
  private _disposables: vscode.Disposable[] = [];
  private pathToConfig: string;
  private runner: Runner;

  public static createOrShow(extContext: vscode.ExtensionContext) {
    const column = vscode.window.activeTextEditor
      ? vscode.window.activeTextEditor.viewColumn
      : undefined;

    // If we already have a panel, show it.
    // Otherwise, create a new panel.
    if (PanelClass.currentPanel) {
      PanelClass.currentPanel._panel.reveal(column);
    } else {
      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);
      PanelClass.currentPanel = new PanelClass(
        extContext,
        vscode.ViewColumn.Two
      );
    }
  }

  public static async insertFileIntoTemplate(
    extContext: vscode.ExtensionContext
  ) {
    console.log("this is both broken and not going to be used anymore");
    const activeTextEditor = vscode.window.activeTextEditor;
    if (activeTextEditor == null) {
      return;
    }
    const activeEditorText = activeTextEditor.document.getText();
    const activeEditorFilePath = activeTextEditor.document.fileName;
    // we want to deterministically hash the filepath

    const filePathHash = formFilePathHash(activeEditorFilePath);
    const column = vscode.window.activeTextEditor
      ? vscode.window.activeTextEditor.viewColumn
      : undefined;

    // If we already have a panel, show it.
    // Otherwise, create a new panel.
    if (PanelClass.currentPanel) {
      PanelClass.currentPanel._panel.reveal(column);
    } else {
      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);
      PanelClass.currentPanel = new PanelClass(
        extContext,
        vscode.ViewColumn.Two
      );
    }

    // we also need to store this hash somewhere!
    console.log("DO WE HAVE PATH ", PanelClass.currentPanel.pathToConfig);
    storeFileHash(
      PanelClass.currentPanel.pathToConfig,
      filePathHash,
      activeEditorFilePath
    );

    /*PanelClass.currentPanel._panel.webview.postMessage({
      command: "file_insert",
      data: {
        contents: activeEditorText,
        filePath: filePathHash,
      },
    });*/
    const fileTemplates = await getAllFileTemplates(
      PanelClass.currentPanel.pathToConfig
    );
    PanelClass.currentPanel._panel.webview.postMessage({
      command: "all_file_templates",
      data: {
        fileTemplates: tts(fileTemplates, false),
      },
    });
  }
  //temporarily setting extcontext to any type
  private constructor(
    _extContext: vscode.ExtensionContext,
    column: vscode.ViewColumn
  ) {
    this._extContext = _extContext;
    this._extensionUri = _extContext.extensionUri;

    // Create and show a new webview panel
    function handleQueueUpdate() {
      
      const currentQueue = this.runner.steps?.map((step) => ({
        type: step.type,
        name: step.name,
        description: step.description,
        word: step.word ?? "-",
        isWaitingForCommand: step.waitForTransitionCommand,
        transitionAction: step.transitionAction,
      }))??[];
      console.log("queue update", currentQueue);
      this._panel!.webview.postMessage({
        command: "queue_update",
        data: {
          currentQueue: JSON.stringify(currentQueue),
        },
      });
    }
    this._panel = vscode.window.createWebviewPanel(
      PanelClass.viewType,
      "Blueprints",
      column,
      {
        // Enable javascript in the webview
        enableScripts: true,
        localResourceRoots: [this._extensionUri],
      }
    );

    // Set the webview's initial html content
    this._panel.webview.html = this._getHtmlForWebview(this._panel.webview);

    // Listen for when the panel is disposed
    // This happens when the user closes the panel or when the panel is closed programatically
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

    //Listen to messages
    this._panel.${run(webviewCommandHandler01, 'webviewCommandHandler01')}
    );
  }

  public dispose() {
    PanelClass.currentPanel = undefined;
    this._panel.dispose();
    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) {
        x.dispose();
      }
    }
  }

  private _getHtmlForWebview(webview: vscode.Webview) {
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, "out", "main.wv.js")
    );

    const styleUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, "media", "styles.css")
    );

    const nonce = getNonce();

    return ェ<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Symmetric Blueprints</title>
        <link rel="stylesheet" href="§{styleUri}">
      </head>
      <body>
        <div id="root"></div>
        <script>
          global = window
          
          const vscode = acquireVsCodeApi();
          window.onload = function() {
            vscode.postMessage({ command: 'startup' });
            console.log('HTML started up.');
          };
        </script>
        <script nonce="§{nonce}" src="§{scriptUri}"></script>
      </body>
      </html>
    ェ;
  }
}
`,
'webviewCommandHandler01/webviewHandler01': ({webviewHandler01})=>`webview.onDidReceiveMessage(${run(webviewHandler01, 'webviewHandler01')}this._disposables`,
'webviewPostMessageName111/webviewCommandName111': ({webviewCommandName111})=>`command: "${run(webviewCommandName111, 'webviewCommandName111')}",`,
'webviewPostMessageName110/webviewCommandName110': ({webviewCommandName110})=>`command: "${run(webviewCommandName110, 'webviewCommandName110')}",`,
'webviewPostMessageName19/webviewCommandName19': ({webviewCommandName19})=>`command: "${run(webviewCommandName19, 'webviewCommandName19')}",`,
'webviewPostMessageName18/webviewCommandName18': ({webviewCommandName18})=>`command: "${run(webviewCommandName18, 'webviewCommandName18')}",`,
'webviewPostMessageName17/webviewCommandName17': ({webviewCommandName17})=>`command: "${run(webviewCommandName17, 'webviewCommandName17')}",`,
'webviewPostMessageName16/webviewCommandName16': ({webviewCommandName16})=>`command: "${run(webviewCommandName16, 'webviewCommandName16')}",`,
'webviewPostMessageName15/webviewCommandName15': ({webviewCommandName15})=>`command: "${run(webviewCommandName15, 'webviewCommandName15')}",`,
'webviewPostMessageName14/webviewCommandName14': ({webviewCommandName14})=>`command: "${run(webviewCommandName14, 'webviewCommandName14')}",`,
'webviewPostMessageName13/webviewCommandName13': ({webviewCommandName13})=>`command: "${run(webviewCommandName13, 'webviewCommandName13')}",`,
'webviewPostMessageName12/webviewCommandName12': ({webviewCommandName12})=>`command: "${run(webviewCommandName12, 'webviewCommandName12')}",`,
'webviewPostMessageName11/webviewCommandName11': ({webviewCommandName11})=>`command: "${run(webviewCommandName11, 'webviewCommandName11')}",`,
'panelCommand017/panelCommandName017,panelCommandBody017': ({panelCommandName017, panelCommandBody017})=>`case "${run(panelCommandName017, 'panelCommandName017')}":${run(panelCommandBody017, 'panelCommandBody017')}break;`,
'panelCommand016/panelCommandName016,panelCommandBody016': ({panelCommandName016, panelCommandBody016})=>`case "${run(panelCommandName016, 'panelCommandName016')}":${run(panelCommandBody016, 'panelCommandBody016')}break;`,
'panelCommand015/panelCommandName015,panelCommandBody015': ({panelCommandName015, panelCommandBody015})=>`case "${run(panelCommandName015, 'panelCommandName015')}":${run(panelCommandBody015, 'panelCommandBody015')}break;`,
'panelCommand014/panelCommandName014,panelCommandBody014': ({panelCommandName014, panelCommandBody014})=>`case "${run(panelCommandName014, 'panelCommandName014')}":${run(panelCommandBody014, 'panelCommandBody014')}break;`,
'panelCommand013/panelCommandName013,panelCommandBody013': ({panelCommandName013, panelCommandBody013})=>`case "${run(panelCommandName013, 'panelCommandName013')}":${run(panelCommandBody013, 'panelCommandBody013')}break;`,
'panelCommand012/panelCommandName012,panelCommandBody012': ({panelCommandName012, panelCommandBody012})=>`case "${run(panelCommandName012, 'panelCommandName012')}":${run(panelCommandBody012, 'panelCommandBody012')}break;`,
'panelCommand011/panelCommandName011,panelCommandBody011': ({panelCommandName011, panelCommandBody011})=>`case "${run(panelCommandName011, 'panelCommandName011')}":${run(panelCommandBody011, 'panelCommandBody011')}break;`,
'panelCommand010/panelCommandName010,panelCommandBody010': ({panelCommandName010, panelCommandBody010})=>`case "${run(panelCommandName010, 'panelCommandName010')}":${run(panelCommandBody010, 'panelCommandBody010')}break;`,
'panelCommand09/panelCommandName09,panelCommandBody09': ({panelCommandName09, panelCommandBody09})=>`case "${run(panelCommandName09, 'panelCommandName09')}":${run(panelCommandBody09, 'panelCommandBody09')}break;`,
'panelCommand08/panelCommandName08,panelCommandBody08': ({panelCommandName08, panelCommandBody08})=>`case "${run(panelCommandName08, 'panelCommandName08')}":${run(panelCommandBody08, 'panelCommandBody08')}break;`,
'panelCommand07/panelCommandName07,panelCommandBody07': ({panelCommandName07, panelCommandBody07})=>`case "${run(panelCommandName07, 'panelCommandName07')}":${run(panelCommandBody07, 'panelCommandBody07')}break;`,
'panelCommand06/panelCommandName06,panelCommandBody06': ({panelCommandName06, panelCommandBody06})=>`case "${run(panelCommandName06, 'panelCommandName06')}":${run(panelCommandBody06, 'panelCommandBody06')}break;`,
'panelCommand05/panelCommandName05,panelCommandBody05': ({panelCommandName05, panelCommandBody05})=>`case "${run(panelCommandName05, 'panelCommandName05')}":${run(panelCommandBody05, 'panelCommandBody05')}break;`,
'panelCommand04/panelCommandName04,panelCommandBody04': ({panelCommandName04, panelCommandBody04})=>`case "${run(panelCommandName04, 'panelCommandName04')}":${run(panelCommandBody04, 'panelCommandBody04')}break;`,
'panelCommand03/panelCommandName03,panelCommandBody03': ({panelCommandName03, panelCommandBody03})=>`case "${run(panelCommandName03, 'panelCommandName03')}":${run(panelCommandBody03, 'panelCommandBody03')}break;`,
'panelCommand02/panelCommandName02,panelCommandBody02': ({panelCommandName02, panelCommandBody02})=>`case "${run(panelCommandName02, 'panelCommandName02')}":${run(panelCommandBody02, 'panelCommandBody02')}break;`,
'panelCommand01/panelCommandName01,panelCommandBody01': ({panelCommandName01, panelCommandBody01})=>`case "${run(panelCommandName01, 'panelCommandName01')}":${run(panelCommandBody01, 'panelCommandBody01')}break;`,
'webviewHandler01/panelCommand01,panelCommand02,panelCommand03,panelCommand04,panelCommand05,panelCommand06,panelCommand07,panelCommand08,panelCommand09,panelCommand010,panelCommand011,panelCommand012,panelCommand013,panelCommand014,panelCommand015,panelCommand016,panelCommand017': ({panelCommand01, panelCommand02, panelCommand03, panelCommand04, panelCommand05, panelCommand06, panelCommand07, panelCommand08, panelCommand09, panelCommand010, panelCommand011, panelCommand012, panelCommand013, panelCommand014, panelCommand015, panelCommand016, panelCommand017})=>`
      async (msg: any) => {
;
        switch (msg.command) {
          ${run(panelCommand01, 'panelCommand01')}
          }
          ${run(panelCommand02, 'panelCommand02')}
          ${run(panelCommand03, 'panelCommand03')}
          ${run(panelCommand04, 'panelCommand04')}
          ${run(panelCommand05, 'panelCommand05')}
          }
          ${run(panelCommand06, 'panelCommand06')}
          }
          ${run(panelCommand07, 'panelCommand07')}
          }
          ${run(panelCommand08, 'panelCommand08')}
          }
          ${run(panelCommand09, 'panelCommand09')}
          }
          ${run(panelCommand010, 'panelCommand010')}
          }
          ${run(panelCommand011, 'panelCommand011')}
          }
          ${run(panelCommand012, 'panelCommand012')}
          }
          ${run(panelCommand013, 'panelCommand013')}
          }
          ${run(panelCommand014, 'panelCommand014')}
          }
          ${run(panelCommand015, 'panelCommand015')}
          }
          ${run(panelCommand016, 'panelCommand016')}
          }
          ${run(panelCommand017, 'panelCommand017')}
        }
      },
      null,
      `,
'panelCommandBody017/webviewPostMessageName11': ({webviewPostMessageName11})=>`
            try {
              const {queueName} = msg;
              if(queueName == null) {
                throw new Error("Queue name is null");
              }
              const queue = ALL_QUEUES.find((q) => q.name === queueName);
              this.runner = new Runner(queue.steps);
              await this.runner.initNextStep();
              this.runner.unsubscribe("queueUpdate");
              this.runner.subscribe("queueUpdate", handleQueueUpdate.bind(this));

              // data will equal:
              // GENERATOR_FILE=src/generators/wordBuilder.ts
              // TEMPLATE_FILE=src/templates/wordBuilder.ts
              // WORDS_FILE=src/words/wordBuilder.ts
              // we want to parse each file path and send it back to the webview
              const data = await fetchFromConfig(
                this.runner.currentStep.config,
                this.runner
              );
              this._panel!.webview.postMessage({
                ${run(webviewPostMessageName11, 'webviewPostMessageName11')}
                data: {
                  ...data,
                  queueNames: JSON.stringify(ALL_QUEUES.map((q) => q.name)),
                },
              });

              //this._panel!.webview.postMessage({ command: 'config_data', data });
            } catch (e) {
              console.error(e);
            }
            `,
'panelCommandBody016/webviewPostMessageName12': ({webviewPostMessageName12})=>` {
            if (!ALL_QUEUES.some((q) => q.name === msg.queueName)) {
              console.log(
                "queue name vs ALL_QUEUES",
                msg.queueName,
                ALL_QUEUES
              );
              throw new Error("Queue not found, how did this happen?");
            }
            this.runner = new Runner(
              ALL_QUEUES.find((q) => q.name === msg.queueName).steps
            );
            this.runner.initNextStep();
            const pathToConfig = this.runner.currentStep.config;
            const data = await fetchFromConfig(pathToConfig, this.runner);
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName12, 'webviewPostMessageName12')}
              data: {
                ...data,
                queueNames: JSON.stringify(ALL_QUEUES.map((q) => q.name)),
              },
            });
            `,
'panelCommandBody015/webviewPostMessageName13': ({webviewPostMessageName13})=>` {
            const { template } = msg;
            await this.runner.transition(template);
            const pathToConfig = this.runner.currentStep.config;
            console.time("fetchFromConfig");
            const data = await fetchFromConfig(pathToConfig, this.runner);
            console.timeEnd("fetchFromConfig");
            // so on transition:
            // get the config from the step
            // fetch it all (make a service for it)
            // send it to the frontend like we do on startup
            // also send the current template as a new word result
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName13, 'webviewPostMessageName13')}
              data: {
                ...data,
                queueNames: JSON.stringify(ALL_QUEUES.map((q) => q.name)),
                subTemplate: this.runner.currentStep.subTemplate,
              },
            });
            `,
'panelCommandBody014/webviewPostMessageName14': ({webviewPostMessageName14})=>` {
            const { wordSteps, wordName, msgId } = msg;
            if (
              wordSteps.length === 0 ||
              wordSteps === "" ||
              wordSteps == null
            ) {
              throw new Error("No steps to save");
            }
            const pathToConfig = this.runner.currentStep.config;
            const projectDir = await readFromConfig(
              "PROJECT_DIR",
              pathToConfig
            );
            const wordFile = projectDir + "/word_" + wordName + ".json";
            await saveFile(wordFile, wordSteps);
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName14, 'webviewPostMessageName14')}
              data: {
                msgId,
              },
            });
            `,
'panelCommandBody013/webviewPostMessageName15': ({webviewPostMessageName15})=>` {
            const { msgId, filledGenerator } = msg;
            const pathToConfig = this.runner.currentStep.config;
            const projectDir = await readFromConfig(
              "PROJECT_DIR",
              pathToConfig
            );
            const filledGeneratorsPath = projectDir + "/filledGenerators.json";

            let currentFilledGenerators;
            try {
              currentFilledGenerators = await readFile(filledGeneratorsPath);
            } catch {
              currentFilledGenerators = "{}";
            }
            const cfgTemplate: Template = new Function(
              "return " + currentFilledGenerators
            )();
            const filledGeneratorTemplate: Template = new Function(
              "return " + filledGenerator
            )();
            const newFilledGenerators = insertIntoTemplate(
              cfgTemplate,
              filledGeneratorTemplate
            );
            await saveFile(
              filledGeneratorsPath,
              tts(newFilledGenerators, false)
            );
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName15, 'webviewPostMessageName15')}
              data: {
                msgId,
                allFilledGenerators: tts(newFilledGenerators, false),
              },
            });
            `,
'panelCommandBody012/webviewPostMessageName16': ({webviewPostMessageName16})=>` {
            const { wordName, template, msgId } = msg;
            const pathToConfig = this.runner.currentStep.config;
            const {
              template: result,
              wordRunFilePath,
              resultFilePath,
              queuedTemplates,
            } = await runWord(pathToConfig, wordName, template);
            // ADD queuedTemplates TO RUNNER
            this.runner.addSubTemplatesToQueue(queuedTemplates);
            // the queued items will change in the queue header
            // so the user will know buildQueue affected the queue
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName16, 'webviewPostMessageName16')}
              data: {
                msgId,
                wordRunFilePath: wordRunFilePath,
                resultFilePath: resultFilePath,
                result,
                wordString: ェ§{wordName}(template)ェ,
              },
            });
            `,
'panelCommandBody011/webviewPostMessageName17': ({webviewPostMessageName17})=>` {
            const pathToConfig = this.runner.currentStep.config;
            const { generatorString, template, msgId } = msg;
            console.log(
              "RUNNING",
              "msgId",
              msgId,
              "AND",

              generatorString,
              pathToConfig
            );
            const projectDir = await readFromConfig(
              "PROJECT_DIR",
              pathToConfig
            );
            const filePrefix = Date.now();
            const generatorRunFile = await createRunnableGeneratorFileContents(
              pathToConfig,
              generatorString,
              template
            );
            const generatorFile = filePrefix + "_generator.ts";
            const resultFile = filePrefix + "_result";
            const genFilePath = projectDir + "/" + generatorFile;
            const resultFilePath = projectDir + "/" + resultFile;
            await saveFile(genFilePath, generatorRunFile);
            const result = await runTs(genFilePath);
            console.log("RESULTv,", result);
            await saveFile(resultFilePath, result);

            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName17, 'webviewPostMessageName17')}
              data: {
                msgId,
                generatorFilePath: genFilePath,
                resultFilePath: resultFilePath,
                result,
                generatorString,
              },
            });
            `,
'panelCommandBody010/webviewPostMessageName18': ({webviewPostMessageName18})=>` {
            const { key, args, value } = msg;
            const funcPart = argsAndTemplateToFunction([], value);
            const templ = { [key]: funcPart };
            const templateString = ェgenTemplateWithVars(§{tts(
              templ,
              false
            )}, §{args});ェ;
            const pathToConfig = this.runner.currentStep.config;
            const templatesFilePath = await readFromConfig(
              "TEMPLATE_FILE",
              pathToConfig
            );
            const templatesFile = await readFromFile(templatesFilePath);
            console.log("CURR TEMPLATES FILE", templatesFile);
            // write template to templates file
            const newTemplatesFile =
              templatesFile + "Øn" + ェexport const §{key} = §{templateString}ェ;
            console.log("NEW TEMPLATES FILE", newTemplatesFile);
            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {
              if (err) {
                console.error(err);
              }
              console.log("success");
            });

            // bun run the file and send the result to the frontend
            const projectDir = await readFromConfig(
              "PROJECT_DIR",
              pathToConfig
            );
            const templateModule = await runTs(
              projectDir + "/template-getter.ts"
            );
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName18, 'webviewPostMessageName18')}
              data: {
                templateModule,
              },
            });

            `,
'panelCommandBody09/webviewPostMessageName19': ({webviewPostMessageName19})=>` {
            // a full template doesn't need to be generated
            // it's the actual object that is a template
            // we just need to add it to the template pool
            const { template, name } = msg;
            const pathToConfig = this.runner.currentStep.config;
            const templatesFilePath = await readFromConfig(
              "TEMPLATE_FILE",
              pathToConfig
            );
            const templatesFile = await readFromFile(templatesFilePath);
            console.log("CURR TEMPLATES FILE", templatesFile);
            // write template to templates file
            const newTemplatesFile =
              templatesFile + "Øn" + ェexport const §{name} = §{template}ェ;
            console.log("NEW TEMPLATES FILE", newTemplatesFile);
            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {
              if (err) {
                console.error(err);
              }
              console.log("success");
            });

            // bun run the file and send the result to the frontend
            const projectDir = await readFromConfig(
              "PROJECT_DIR",
              pathToConfig
            );
            const templateModule = await runTs(
              projectDir + "/template-getter.ts"
            );
            console.log("ALL OF TEMPLATE MODULE", templateModule);
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName19, 'webviewPostMessageName19')}
              data: {
                templateModule,
              },
            });
            `,
'panelCommandBody08/webviewPostMessageName110': ({webviewPostMessageName110})=>` {
            const { wordName, template } = msg;
            const pathToConfig = this.runner.currentStep.config;
            const projectDir = await readFromConfig(
              "PROJECT_DIR",
              pathToConfig
            );
            const wordFile = projectDir + "/word_" + wordName + ".json";
            // eventually, result might be something more, like a file insertion
            let wordTemplate = "{}";
            if (template != null) {
              wordTemplate = template;
            }
            let wordContents = JSON.stringify([{ result: wordTemplate }]);
            await saveFile(wordFile, wordContents);
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName110, 'webviewPostMessageName110')}
              data: {
                wordName,
                wordContents,
              },
            });
            `,
'panelCommandBody07/webviewPostMessageName111': ({webviewPostMessageName111})=>` {
            const { wordName } = msg;
            const pathToConfig = this.runner.currentStep.config;
            const wordPath = await getWordPath(pathToConfig, wordName);
            const wordContents = await getWordContents(wordPath);
            this._panel!.webview.postMessage({
              ${run(webviewPostMessageName111, 'webviewPostMessageName111')}
              data: {
                wordName,
                wordContents,
              },
            });
            `,
'panelCommandBody06/webviewPostMessageName112': ({webviewPostMessageName112})=>` {
            const { word } = msg;
            const pathToConfig = this.runner.currentStep.config;
            console.log("STORING RUNNABLE WORD", word, pathToConfig);
            try {
              await saveRunnableWord(pathToConfig, word);
              const runnableWords = await getAllRunnableWords(pathToConfig);
              this._panel!.webview.postMessage({
                ${run(webviewPostMessageName112, 'webviewPostMessageName112')}
                data: {
                  runnableWords: JSON.stringify(runnableWords),
                },
              });
            } catch (e) {
              console.error(e);
            }
            `,
'webviewPostMessageName112/webviewCommandName112': ({webviewCommandName112})=>`command: "${run(webviewCommandName112, 'webviewCommandName112')}",`,
'fileContents2/commandSend01,hookCmdHandler01,hookCmdHandler02,commandSend02': ({commandSend01, hookCmdHandler01, hookCmdHandler02, commandSend02})=>`
import { cloneDeep, compact, difference, last, uniqueId } from "lodash";
import { useEffect, useState } from "react";
import {
  appendKeyToKey,
  dumbCombine,
  insertIntoTemplate,
  sortTemplateByDeps,
  tts,
  argsAndTemplateToFunction,
} from "symmetric-parser";
import { Template } from "symmetric-parser/dist/src/templator/template-group";
import { formGeneratorFile } from "./hgcgUtil";
import { CONFIG_PATH } from "../components/App";
import { customAlphabet } from "nanoid";
import { WordDefinition } from "../components/TemplateTree";
import { pathToFileURL } from "url";

export type WordStep = {
  name?: string;
  args?: any[];
  result: Template;
  full?: string;
  files?: { generatorFilePath?: string; resultFilePath?: string };
};

export function useTemplate(
  definition: WordDefinition,
  templateModule: any,
  generatorModule: any,
  wordModule: any,
  postMessage: any,
  isMainTemplate: boolean
) {
  const alphabet =
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  const nanoid = customAlphabet(alphabet, 4);

  const [msgId, setMsgId] = useState(nanoid());
  let [template, setTemplate] = useState<Template>(
    last(definition.wordSteps).result
  );

  useEffect(() => {
    setTemplate(last(definition.wordSteps).result);
  },[definition])

  const [wordSteps, setWordSteps] = useState<WordStep[]>(definition.wordSteps);
  function logStep(name, args, result, files = {}) {
    const wordStep = {
      name: name,
      args: args,
      full: ェ§{name}(§{args.join(",")})ェ,
      result: cloneDeep(result),
      files,
    };

    const newWordSteps = [...wordSteps, wordStep];
    setWordSteps(newWordSteps);
    const stringifiedSteps = newWordSteps.map((ws) => {
      return {
        name: ws.name,
        args: ws.args,
        full: ws.full,
        result:
          typeof ws.result === "string" ? ws.result : tts(ws.result, false),
        files: ws.files,
      };
    });
    const wordName = definition.name;

   ${run(commandSend01, 'commandSend01')}
  }

  function removeKey(key: string) {
    const newTemplate = cloneDeep(template);
    delete newTemplate[key];
    logStep("deleteKey", [key], newTemplate);
    setTemplate(newTemplate);
  }
  function addKey(key: string) {
    const templateHasNumerator = Object.keys(template).some((k) => {
      return k.split("/")[0] === key;
    });
    if (templateHasNumerator) return;
    let combineWith = { [key]: () => ェェ };
    let newTemplate = dumbCombine(template, combineWith);
    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));
    logStep("dumbCombine", [template, combineWith], result);
    setTemplate(result);
  }

  function addKeyToNumerator(appendKey: string, toKey: string) {
    const fullToKey = Object.keys(template).find(
      (k) => k.split("/")[0] === toKey
    );
    if (fullToKey != null) {
      // check that the appendKey isn't already in there
      const denoms = fullToKey.split("/")[1]?.split(",");
      if (denoms?.includes(appendKey)) {
        return;
      }
    }
    let newTemplate = appendKeyToKey(template, appendKey, toKey);
    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));
    logStep("appendKeyToKey", [template, appendKey, toKey], result);

    setTemplate(result);
  }

  function insertTemplateIntoTemplate(templateToInsert: Template) {
    console.log("inserting template into template", templateToInsert);
    let newTemplate = insertIntoTemplate(template, templateToInsert);
    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));
    logStep("insertIntoTemplate", [template, templateToInsert], result);

    setTemplate(result);
  }
  function insertTemplateIntoTemplateAtKey(
    templateToInsert: Template,
    toKey: string
  ) {
    console.log(
      "insertTemplateIntoTemplateAtKey",
      templateToInsert,
      toKey,
      template
    );
    const oldKeys = Object.keys(template);
    let newTemplate = insertIntoTemplate(template, templateToInsert);
    logStep("insertIntoTemplate", [template, templateToInsert], newTemplate);

    const newKeys = Object.keys(newTemplate);
    const newestKey = newKeys
      .filter((k) => !oldKeys.includes(k))[0]
      ?.split("/")[0];
    //console.log("NEWEST KEY", newestKey);
    let appendedTemplate = appendKeyToKey(newTemplate, newestKey, toKey);
    const result = sortTemplateByDeps(sortTemplateByDeps(appendedTemplate));
    logStep("appendKeyToKey", [newTemplate, newestKey, toKey], result);
    setTemplate(result);
  }

  const handleGeneratorResult = (message: any) => {
    //console.log("WORD STEPS ON MESSAGE", wordSteps);

    //console.log("MESSAGE DATA", message.data);
    const { generatorFilePath, resultFilePath, result, generatorString } =
      message.data;
    //console.log("generator_result", result);
    const name = generatorString.substring(0, generatorString.indexOf("("));

    const args = generatorString
      .substring(generatorString.indexOf("(") + 1, generatorString.indexOf(")"))
      .split(",");

    logStep(name, args, result, {
      generatorFilePath,
      resultFilePath,
    });
    setTemplate(new Function("return " + result)());
  };

  const handleWordRunResult = (message:any) => {
    const { wordRunFilePath, resultFilePath, result, wordString } =
      message.data;
    console.log("word_run_result", result);
    const name = wordString.substring(0, wordString.indexOf("("));

    const args = ["template"]

    logStep(name, args, result, {
      wordRunFilePath,
      resultFilePath,
    });
    setTemplate(new Function("return " + result)());
  }

  function handleGenericMessage(event: MessageEvent) {
    const message = event.data; // The json data that the extension sent
    ${run(hookCmdHandler01, 'hookCmdHandler01')}
        break;
    }
  }
  useEffect(() => {
    window.addEventListener("message", handleGenericMessage);
    return () => {
      window.removeEventListener("message", handleGenericMessage);
    };
  }, [isMainTemplate]);
  function handleMessage(event: MessageEvent) {
    if (event.data.data.msgId !== msgId) return;
    const message = event.data; // The json data that the extension sent
    ${run(hookCmdHandler02, 'hookCmdHandler02')} {
        // defaults give a good end-of-switch-statement parse hack
        break;
      }
    }
  }
  useEffect(() => {
    window.addEventListener("message", handleMessage);
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, [wordSteps]);
  function applyGeneratorString(generatorString: string) {
    // form it and send it over

    // send it over via postMessage
   ${run(commandSend02, 'commandSend02')}
  }
  const handleConvertWordSteps = () => {
    const parsedWord=parseWordStepsIntoWord(definition.name, wordSteps)
    console.log("parsedWord", parsedWord, wordSteps);
    postMessage({
      command: "store_runnable_word",
      word: parsedWord,
    })
  }
  const handleRunnableWordClick = (rWordName:string) => {
    // postMessage
    // run word
    // get result back

    postMessage({
      command: "run_word",
      wordName:rWordName,
      template: tts(template,false),
      msgId,
    })
  }
  const handleTransition = () => {
    postMessage({
      command: "transition",
      template: tts(template,false),
    })
  }
  //console.log("Word steps", wordSteps);
  return {
    template,
    addKey,
    addKeyToNumerator,
    insertTemplateIntoTemplate,
    insertTemplateIntoTemplateAtKey,
    wordSteps,
    applyGeneratorString,
    removeKey,
    handleConvertWordSteps,
    handleRunnableWordClick,
    handleTransition
  };
}

function parseWordStepsIntoWord(wordName:string, wordSteps: WordStep[]): string {
	const callbacks = compact(wordSteps.map(step=> {
		if(step.name==="insertIntoTemplate") {
			return null
		}
    if(step.full==null) {return null}
		return ェ(template)=>§{step.full}ェ
	}))

	const word = ェexport const §{wordName} = flow(§{callbacks.join(",")})ェ
  return word;
}`,
'hookCmdHandler02/hookCommandHandlerBody02': ({hookCommandHandlerBody02})=>`switch (message.command)${run(hookCommandHandlerBody02,'hookCommandHandlerBody02')}default:`,
'hookCmdHandler01/hookCommandHandlerBody01': ({hookCommandHandlerBody01})=>`switch (message.command)${run(hookCommandHandlerBody01,'hookCommandHandlerBody01')}default:`,
'hookCommandHandlerBody01/hookCmdHandleSection03': ({hookCmdHandleSection03})=>` {
      ${run(hookCmdHandleSection03, 'hookCmdHandleSection03')}
      } 
      `,
'hookCmdHandleSection03/hookHandlerName03,hookHandlerBody03': ({hookHandlerName03, hookHandlerBody03})=>`case "${run(hookHandlerName03,'hookHandlerName03')}":${run(hookHandlerBody03,'hookHandlerBody03')}break;`,
'commandSend02/commandBody02': ({commandBody02})=>` postMessage({${run(commandBody02, 'commandBody02')}});`,
'commandBody02/nameProperty12': ({nameProperty12})=>`
      ${run(nameProperty12, 'nameProperty12')}
      generatorString,
      template: tts(template,false),
      msgId,
    `,
'nameProperty12/commandName12': ({commandName12})=>`command: "${run(commandName12, 'commandName12')}",`,
'commandSend01/commandBody01': ({commandBody01})=>` postMessage({${run(commandBody01, 'commandBody01')}});`,
'commandBody01/nameProperty13': ({nameProperty13})=>`
      ${run(nameProperty13, 'nameProperty13')}
      wordSteps: JSON.stringify(stringifiedSteps),
      wordName,
      msgId,
    `,
'nameProperty13/commandName13': ({commandName13})=>`command: "${run(commandName13, 'commandName13')}",`,
'hookCommandHandlerBody02/hookCmdHandleSection02,hookCmdHandleSection02': ({hookCmdHandleSection02})=>` {
      ${run(hookCmdHandleSection02, 'hookCmdHandleSection02')}
      ${run(hookCmdHandleSection02, 'hookCmdHandleSection02')}
      }
      `,
'hookCmdHandleSection02/hookHandlerName02,hookHandlerBody02': ({hookHandlerName02, hookHandlerBody02})=>`case "${run(hookHandlerName02,'hookHandlerName02')}":${run(hookHandlerBody02,'hookHandlerBody02')}break;`,
'fileContents13/hookCmdHandler03': ({hookCmdHandler03})=>`
import { useEffect, useState } from "react";
import { DequeueStep } from "../../runner/runner";
type QueueStepData = {
  type: string;
  name: string;
  description: string;
  word: string;
  isWaitingForCommand: boolean;
  transitionAction: string;
}
const FAKE_DATA = [
  {
      "type": "template",
      "name": "parseFifth_subTemplate",
      "description": "Queue item from subTemplate",
      "word": "-",
      "isWaitingForCommand": true,
      "transitionAction": "identity"
  },
  {
      "type": "template",
      "name": "parseFifth",
      "description": "runs the word that parses fifth.tsx",
      "word": "-",
      "isWaitingForCommand": false,
      "transitionAction": "identity"
  }
]
export function useQueueListener() {
  const [queueSteps, setQueueSteps] = useState<QueueStepData[]>(FAKE_DATA);
  function handleQueueUpdate(message) {
    const newQueueSteps = message.data;

  }
  function handleMessage(event: MessageEvent) {
    const message = event.data; // The json data that the extension sent
    ${run(hookCmdHandler03, 'hookCmdHandler03')} {
        // defaults give a good end-of-switch-statement parse hack
        break;
      }
    }
  }
  useEffect(() => {
    window.addEventListener("message", handleMessage);
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, []);

  return {
    queueSteps,
  }
}
`,
'hookCmdHandler03/hookCommandHandlerBody03': ({hookCommandHandlerBody03})=>`switch (message.command)${run(hookCommandHandlerBody03,'hookCommandHandlerBody03')}default:`,
'hookCommandHandlerBody03/hookCmdHandleSection01': ({hookCmdHandleSection01})=>` {
      ${run(hookCmdHandleSection01, 'hookCmdHandleSection01')}
      `,
'hookCmdHandleSection01/hookHandlerName01,hookHandlerBody01': ({hookHandlerName01, hookHandlerBody01})=>`case "${run(hookHandlerName01,'hookHandlerName01')}":${run(hookHandlerBody01,'hookHandlerBody01')}break;`,
'commandName01': ()=>`select_queue`,
'commandName02': ()=>`add_template`,
'commandName03': ()=>`create_word`,
'commandName04': ()=>`get_word`,
'commandName05': ()=>`writeFile`,
'commandName06': ()=>`fetch_from_config`,
'commandName07': ()=>`save_all_files`,
'commandName08': ()=>`add_filled_generator`,
'commandName09': ()=>`add_template`,
'commandName10': ()=>`add_full_template`,
'commandName11': ()=>`save_word`,
'commandName12': ()=>`run_generator`,
'commandName13': ()=>`save_word_steps`,
'fileContents3': ()=>`
import { readFromConfig } from "./commandService";
import { runTs, saveFile } from "../compiler";

export function formWordRunFile(wordName: string, template: string): string {
  return ェimport { getQueue, clearQueue, §{wordName} } from "./word-pool";Ønimport { tts } from "symmetric-parser";
  function Ò(func: () => string, keyName: string) {
  try {
    if (func == null) {
      return "Ø§{run(" + keyName + ", '" + keyName + "')}";
    }
    if (typeof func === "string") {
      throw new Error("func is string");
    }
    const result = func();
    return result;
  } catch (e) {
    return "Ø§{run(" + keyName + ", '" + keyName + "')}";
  }
}
  Ønconst template = §{template};Ønconst result = §{wordName}(template);Ønconst queue=getQueue();Ønconsole.log(tts(result, false));Ønif(queue.length>0) {Ønconsole.log("
");Ønqueue.forEach(q=>console.log(tts(q,false),"
"))}ØnclearQueue();ェ;
}

export type TemplateAsString = string;

export type WordRunResult = {
  template: string;
  wordRunFilePath: string;
  resultFilePath: string;
  queuedTemplates: string[];
};

type WordRunParse = {
  template: string;
  queue: string[];
}
function parseWordRunResult(result: string): WordRunParse {
  const split = result.split("