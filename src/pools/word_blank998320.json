[{"result":"{\n'useTemplate.ts60c890fb5b/fileContents1': ({fileContents1})=>`${run(fileContents1, 'fileContents1')}`,\n'fileContents1': ()=>`\nimport { cloneDeep, compact, difference, last, uniqueId } from \"lodash\";\nimport { useEffect, useState } from \"react\";\nimport {\n  appendKeyToKey,\n  dumbCombine,\n  insertIntoTemplate,\n  sortTemplateByDeps,\n  tts,\n  argsAndTemplateToFunction,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { formGeneratorFile } from \"./hgcgUtil\";\nimport { CONFIG_PATH } from \"../components/App\";\nimport { customAlphabet } from \"nanoid\";\nimport { WordDefinition } from \"../components/TemplateTree\";\nimport { pathToFileURL } from \"url\";\n\nexport type WordStep = {\n  name?: string;\n  args?: any[];\n  result: Template;\n  full?: string;\n  files?: { generatorFilePath?: string; resultFilePath?: string };\n};\n\nexport function useTemplate(\n  definition: WordDefinition,\n  templateModule: any,\n  generatorModule: any,\n  wordModule: any,\n  postMessage: any,\n  isMainTemplate: boolean\n) {\n  const alphabet =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const nanoid = customAlphabet(alphabet, 4);\n\n  const [msgId, setMsgId] = useState(nanoid());\n  let [template, setTemplate] = useState<Template>(\n    last(definition.wordSteps).result\n  );\n\n  useEffect(() => {\n    setTemplate(last(definition.wordSteps).result);\n  },[definition])\n\n  const [wordSteps, setWordSteps] = useState<WordStep[]>(definition.wordSteps);\n  function logStep(name, args, result, files = {}) {\n    const wordStep = {\n      name: name,\n      args: args,\n      full: ェ§{name}(§{args.join(\",\")})ェ,\n      result: cloneDeep(result),\n      files,\n    };\n\n    const newWordSteps = [...wordSteps, wordStep];\n    setWordSteps(newWordSteps);\n    const stringifiedSteps = newWordSteps.map((ws) => {\n      return {\n        name: ws.name,\n        args: ws.args,\n        full: ws.full,\n        result:\n          typeof ws.result === \"string\" ? ws.result : tts(ws.result, false),\n        files: ws.files,\n      };\n    });\n    const wordName = definition.name;\n\n    postMessage({\n      command: \"save_word_steps\",\n      wordSteps: JSON.stringify(stringifiedSteps),\n      wordName,\n      msgId,\n    });\n  }\n\n  function removeKey(key: string) {\n    const newTemplate = cloneDeep(template);\n    delete newTemplate[key];\n    logStep(\"deleteKey\", [key], newTemplate);\n    setTemplate(newTemplate);\n  }\n  function addKey(key: string) {\n    const templateHasNumerator = Object.keys(template).some((k) => {\n      return k.split(\"/\")[0] === key;\n    });\n    if (templateHasNumerator) return;\n    let combineWith = { [key]: () => ェェ };\n    let newTemplate = dumbCombine(template, combineWith);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"dumbCombine\", [template, combineWith], result);\n    setTemplate(result);\n  }\n\n  function addKeyToNumerator(appendKey: string, toKey: string) {\n    const fullToKey = Object.keys(template).find(\n      (k) => k.split(\"/\")[0] === toKey\n    );\n    if (fullToKey != null) {\n      // check that the appendKey isn't already in there\n      const denoms = fullToKey.split(\"/\")[1]?.split(\",\");\n      if (denoms?.includes(appendKey)) {\n        return;\n      }\n    }\n    let newTemplate = appendKeyToKey(template, appendKey, toKey);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"appendKeyToKey\", [template, appendKey, toKey], result);\n\n    setTemplate(result);\n  }\n\n  function insertTemplateIntoTemplate(templateToInsert: Template) {\n    console.log(\"inserting template into template\", templateToInsert);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], result);\n\n    setTemplate(result);\n  }\n  function insertTemplateIntoTemplateAtKey(\n    templateToInsert: Template,\n    toKey: string\n  ) {\n    console.log(\n      \"insertTemplateIntoTemplateAtKey\",\n      templateToInsert,\n      toKey,\n      template\n    );\n    const oldKeys = Object.keys(template);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], newTemplate);\n\n    const newKeys = Object.keys(newTemplate);\n    const newestKey = newKeys\n      .filter((k) => !oldKeys.includes(k))[0]\n      ?.split(\"/\")[0];\n    //console.log(\"NEWEST KEY\", newestKey);\n    let appendedTemplate = appendKeyToKey(newTemplate, newestKey, toKey);\n    const result = sortTemplateByDeps(sortTemplateByDeps(appendedTemplate));\n    logStep(\"appendKeyToKey\", [newTemplate, newestKey, toKey], result);\n    setTemplate(result);\n  }\n\n  const handleGeneratorResult = (message: any) => {\n    //console.log(\"WORD STEPS ON MESSAGE\", wordSteps);\n\n    //console.log(\"MESSAGE DATA\", message.data);\n    const { generatorFilePath, resultFilePath, result, generatorString } =\n      message.data;\n    console.log(\"generator_result\", result);\n    const name = generatorString.substring(0, generatorString.indexOf(\"(\"));\n\n    const args = generatorString\n      .substring(generatorString.indexOf(\"(\") + 1, generatorString.indexOf(\")\"))\n      .split(\",\");\n\n    logStep(name, args, result, {\n      generatorFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  };\n\n  const handleWordRunResult = (message:any) => {\n    const { wordRunFilePath, resultFilePath, result, wordString } =\n      message.data;\n    console.log(\"word_run_result\", result);\n    const name = wordString.substring(0, wordString.indexOf(\"(\"));\n\n    const args = [\"template\"]\n\n    logStep(name, args, result, {\n      wordRunFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  }\n\n  function handleGenericMessage(event: MessageEvent) {\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"file_insert\": {\n        if (isMainTemplate) {\n          const { contents, filePath } = message.data;\n          const funcPart = argsAndTemplateToFunction([], contents);\n          const templ = { [filePath]: funcPart };\n          //console.log(\"FILE INSERT\", contents, filePath, templ);\n          insertTemplateIntoTemplate(templ);\n        }\n        break;\n      } \n      default:\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleGenericMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleGenericMessage);\n    };\n  }, [isMainTemplate]);\n  function handleMessage(event: MessageEvent) {\n    if (event.data.data.msgId !== msgId) return;\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"generator_result\":\n        handleGeneratorResult(message);\n        break;\n      case \"word_run_result\": {\n        handleWordRunResult(message);\n        break;\n      }\n      default: {\n        // defaults give a good end-of-switch-statement parse hack\n        break;\n      }\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleMessage);\n    };\n  }, [wordSteps]);\n  function applyGeneratorString(generatorString: string) {\n    // form it and send it over\n\n    // send it over via postMessage\n    postMessage({\n      command: \"run_generator\",\n      generatorString,\n      template: tts(template,false),\n      msgId,\n    });\n  }\n  const handleConvertWordSteps = () => {\n    const parsedWord=parseWordStepsIntoWord(definition.name, wordSteps)\n    console.log(\"parsedWord\", parsedWord, wordSteps);\n    postMessage({\n      command: \"store_runnable_word\",\n      word: parsedWord,\n    })\n  }\n  const handleRunnableWordClick = (rWordName:string) => {\n    // postMessage\n    // run word\n    // get result back\n\n    postMessage({\n      command: \"run_word\",\n      wordName:rWordName,\n      template: tts(template,false),\n      msgId,\n    })\n  }\n  const handleTransition = () => {\n    postMessage({\n      command: \"transition\",\n      template: tts(template,false),\n    })\n  }\n  console.log(\"Word steps\", wordSteps);\n  return {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n    handleConvertWordSteps,\n    handleRunnableWordClick,\n    handleTransition\n  };\n}\n\nfunction parseWordStepsIntoWord(wordName:string, wordSteps: WordStep[]): string {\n\tconst callbacks = compact(wordSteps.map(step=> {\n\t\tif(step.name===\"insertIntoTemplate\") {\n\t\t\treturn null\n\t\t}\n    if(step.full==null) {return null}\n\t\treturn ェ(template)=>§{step.full}ェ\n\t}))\n\n\tconst word = ェexport const §{wordName} = flow(§{callbacks.join(\",\")})ェ\n  return word;\n}`\n}"},{"name":"orderedParse","args":["template"," [commandSend]"],"full":"orderedParse(template, [commandSend])","result":"{\n'useTemplate.ts60c890fb5b/fileContents1': ({ fileContents1 }) => `${run(fileContents1, \"fileContents1\")}`,\n'fileContents1/commandSend01,commandSend02': ({ commandSend01, commandSend02 }) => `\nimport { cloneDeep, compact, difference, last, uniqueId } from \"lodash\";\nimport { useEffect, useState } from \"react\";\nimport {\n  appendKeyToKey,\n  dumbCombine,\n  insertIntoTemplate,\n  sortTemplateByDeps,\n  tts,\n  argsAndTemplateToFunction,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { formGeneratorFile } from \"./hgcgUtil\";\nimport { CONFIG_PATH } from \"../components/App\";\nimport { customAlphabet } from \"nanoid\";\nimport { WordDefinition } from \"../components/TemplateTree\";\nimport { pathToFileURL } from \"url\";\n\nexport type WordStep = {\n  name?: string;\n  args?: any[];\n  result: Template;\n  full?: string;\n  files?: { generatorFilePath?: string; resultFilePath?: string };\n};\n\nexport function useTemplate(\n  definition: WordDefinition,\n  templateModule: any,\n  generatorModule: any,\n  wordModule: any,\n  postMessage: any,\n  isMainTemplate: boolean\n) {\n  const alphabet =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const nanoid = customAlphabet(alphabet, 4);\n\n  const [msgId, setMsgId] = useState(nanoid());\n  let [template, setTemplate] = useState<Template>(\n    last(definition.wordSteps).result\n  );\n\n  useEffect(() => {\n    setTemplate(last(definition.wordSteps).result);\n  },[definition])\n\n  const [wordSteps, setWordSteps] = useState<WordStep[]>(definition.wordSteps);\n  function logStep(name, args, result, files = {}) {\n    const wordStep = {\n      name: name,\n      args: args,\n      full: \\u30A7\\xA7{name}(\\xA7{args.join(\",\")})\\u30A7,\n      result: cloneDeep(result),\n      files,\n    };\n\n    const newWordSteps = [...wordSteps, wordStep];\n    setWordSteps(newWordSteps);\n    const stringifiedSteps = newWordSteps.map((ws) => {\n      return {\n        name: ws.name,\n        args: ws.args,\n        full: ws.full,\n        result:\n          typeof ws.result === \"string\" ? ws.result : tts(ws.result, false),\n        files: ws.files,\n      };\n    });\n    const wordName = definition.name;\n\n    ${run(commandSend01, \"commandSend01\")}\n  }\n\n  function removeKey(key: string) {\n    const newTemplate = cloneDeep(template);\n    delete newTemplate[key];\n    logStep(\"deleteKey\", [key], newTemplate);\n    setTemplate(newTemplate);\n  }\n  function addKey(key: string) {\n    const templateHasNumerator = Object.keys(template).some((k) => {\n      return k.split(\"/\")[0] === key;\n    });\n    if (templateHasNumerator) return;\n    let combineWith = { [key]: () => \\u30A7\\u30A7 };\n    let newTemplate = dumbCombine(template, combineWith);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"dumbCombine\", [template, combineWith], result);\n    setTemplate(result);\n  }\n\n  function addKeyToNumerator(appendKey: string, toKey: string) {\n    const fullToKey = Object.keys(template).find(\n      (k) => k.split(\"/\")[0] === toKey\n    );\n    if (fullToKey != null) {\n      // check that the appendKey isn't already in there\n      const denoms = fullToKey.split(\"/\")[1]?.split(\",\");\n      if (denoms?.includes(appendKey)) {\n        return;\n      }\n    }\n    let newTemplate = appendKeyToKey(template, appendKey, toKey);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"appendKeyToKey\", [template, appendKey, toKey], result);\n\n    setTemplate(result);\n  }\n\n  function insertTemplateIntoTemplate(templateToInsert: Template) {\n    console.log(\"inserting template into template\", templateToInsert);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], result);\n\n    setTemplate(result);\n  }\n  function insertTemplateIntoTemplateAtKey(\n    templateToInsert: Template,\n    toKey: string\n  ) {\n    console.log(\n      \"insertTemplateIntoTemplateAtKey\",\n      templateToInsert,\n      toKey,\n      template\n    );\n    const oldKeys = Object.keys(template);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], newTemplate);\n\n    const newKeys = Object.keys(newTemplate);\n    const newestKey = newKeys\n      .filter((k) => !oldKeys.includes(k))[0]\n      ?.split(\"/\")[0];\n    //console.log(\"NEWEST KEY\", newestKey);\n    let appendedTemplate = appendKeyToKey(newTemplate, newestKey, toKey);\n    const result = sortTemplateByDeps(sortTemplateByDeps(appendedTemplate));\n    logStep(\"appendKeyToKey\", [newTemplate, newestKey, toKey], result);\n    setTemplate(result);\n  }\n\n  const handleGeneratorResult = (message: any) => {\n    //console.log(\"WORD STEPS ON MESSAGE\", wordSteps);\n\n    //console.log(\"MESSAGE DATA\", message.data);\n    const { generatorFilePath, resultFilePath, result, generatorString } =\n      message.data;\n    console.log(\"generator_result\", result);\n    const name = generatorString.substring(0, generatorString.indexOf(\"(\"));\n\n    const args = generatorString\n      .substring(generatorString.indexOf(\"(\") + 1, generatorString.indexOf(\")\"))\n      .split(\",\");\n\n    logStep(name, args, result, {\n      generatorFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  };\n\n  const handleWordRunResult = (message:any) => {\n    const { wordRunFilePath, resultFilePath, result, wordString } =\n      message.data;\n    console.log(\"word_run_result\", result);\n    const name = wordString.substring(0, wordString.indexOf(\"(\"));\n\n    const args = [\"template\"]\n\n    logStep(name, args, result, {\n      wordRunFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  }\n\n  function handleGenericMessage(event: MessageEvent) {\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"file_insert\": {\n        if (isMainTemplate) {\n          const { contents, filePath } = message.data;\n          const funcPart = argsAndTemplateToFunction([], contents);\n          const templ = { [filePath]: funcPart };\n          //console.log(\"FILE INSERT\", contents, filePath, templ);\n          insertTemplateIntoTemplate(templ);\n        }\n        break;\n      } \n      default:\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleGenericMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleGenericMessage);\n    };\n  }, [isMainTemplate]);\n  function handleMessage(event: MessageEvent) {\n    if (event.data.data.msgId !== msgId) return;\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"generator_result\":\n        handleGeneratorResult(message);\n        break;\n      case \"word_run_result\": {\n        handleWordRunResult(message);\n        break;\n      }\n      default: {\n        // defaults give a good end-of-switch-statement parse hack\n        break;\n      }\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleMessage);\n    };\n  }, [wordSteps]);\n  function applyGeneratorString(generatorString: string) {\n    // form it and send it over\n\n    // send it over via postMessage\n    ${run(commandSend02, \"commandSend02\")}\n  }\n  const handleConvertWordSteps = () => {\n    const parsedWord=parseWordStepsIntoWord(definition.name, wordSteps)\n    console.log(\"parsedWord\", parsedWord, wordSteps);\n    postMessage({\n      command: \"store_runnable_word\",\n      word: parsedWord,\n    })\n  }\n  const handleRunnableWordClick = (rWordName:string) => {\n    // postMessage\n    // run word\n    // get result back\n\n    postMessage({\n      command: \"run_word\",\n      wordName:rWordName,\n      template: tts(template,false),\n      msgId,\n    })\n  }\n  const handleTransition = () => {\n    postMessage({\n      command: \"transition\",\n      template: tts(template,false),\n    })\n  }\n  console.log(\"Word steps\", wordSteps);\n  return {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n    handleConvertWordSteps,\n    handleRunnableWordClick,\n    handleTransition\n  };\n}\n\nfunction parseWordStepsIntoWord(wordName:string, wordSteps: WordStep[]): string {\n\tconst callbacks = compact(wordSteps.map(step=> {\n\t\tif(step.name===\"insertIntoTemplate\") {\n\t\t\treturn null\n\t\t}\n    if(step.full==null) {return null}\n\t\treturn \\u30A7(template)=>\\xA7{step.full}\\u30A7\n\t}))\n\n\tconst word = \\u30A7export const \\xA7{wordName} = flow(\\xA7{callbacks.join(\",\")})\\u30A7\n  return word;\n}`,\n'commandSend02/commandBody02': ({commandBody02})=>`postMessage({${run(commandBody02,'commandBody02')}});`,\n'commandBody02/postCmdArgument01,postCmdArgument02,postCmdArgument03,postCmdArgument04': ({ postCmdArgument01, postCmdArgument02, postCmdArgument03, postCmdArgument04 }) => `\n${run(postCmdArgument01, \"postCmdArgument01\")}${run(postCmdArgument02, \"postCmdArgument02\")}${run(postCmdArgument03, \"postCmdArgument03\")}${run(postCmdArgument04, \"postCmdArgument04\")}    `,\n'postCmdArgument01/commandArg01': ({ commandArg01 }) => `  ${run(commandArg01, \"commandArg01\")},\n`,\n'postCmdArgument02/commandArg02': ({ commandArg02 }) => `  ${run(commandArg02, \"commandArg02\")},\n`,\n'postCmdArgument03/commandArg03': ({ commandArg03 }) => `  ${run(commandArg03, \"commandArg03\")},\n`,\n'postCmdArgument04/commandArg04': ({ commandArg04 }) => `  ${run(commandArg04, \"commandArg04\")},\n`,\n'commandSend01/commandBody01': ({commandBody01})=>`postMessage({${run(commandBody01,'commandBody01')}});`,\n'commandBody01/postCmdArgument05,postCmdArgument06,postCmdArgument07,postCmdArgument08': ({ postCmdArgument05, postCmdArgument06, postCmdArgument07, postCmdArgument08 }) => `\n${run(postCmdArgument05, \"postCmdArgument05\")}${run(postCmdArgument06, \"postCmdArgument06\")}${run(postCmdArgument07, \"postCmdArgument07\")}${run(postCmdArgument08, \"postCmdArgument08\")}    `,\n'postCmdArgument05/commandArg05': ({ commandArg05 }) => `  ${run(commandArg05, \"commandArg05\")},\n`,\n'postCmdArgument06/commandArg06': ({ commandArg06 }) => `  ${run(commandArg06, \"commandArg06\")},\n`,\n'postCmdArgument07/commandArg07': ({ commandArg07 }) => `  ${run(commandArg07, \"commandArg07\")},\n`,\n'postCmdArgument08/commandArg08': ({ commandArg08 }) => `  ${run(commandArg08, \"commandArg08\")},\n`,\n'commandArg01': () => '    command: \"run_generator\"',\n'commandArg02': () => \"    generatorString\",\n'commandArg03': () => \"    template: tts(template,false)\",\n'commandArg04': () => \"    msgId\",\n'commandArg05': () => '    command: \"save_word_steps\"',\n'commandArg06': () => \"    wordSteps: JSON.stringify(stringifiedSteps)\",\n'commandArg07': () => \"    wordName\",\n'commandArg08': () => \"    msgId\"\n}\n","files":{"generatorFilePath":"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/src/pools/1735838030083_generator.ts","resultFilePath":"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/src/pools/1735838030083_result"}}]