[{"result":"{\n\n}"},{"name":"insertIntoTemplate","args":[{},{}],"full":"insertIntoTemplate([object Object],[object Object])","result":"{\n'fifth.tsxa4023e8966': ()=>`\nimport { cloneDeep, difference, last, uniqueId } from \"lodash\";\nimport { useEffect, useState } from \"react\";\nimport {\n  appendKeyToKey,\n  dumbCombine,\n  insertIntoTemplate,\n  sortTemplateByDeps,\n  tts,\n  argsAndTemplateToFunction,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { formGeneratorFile } from \"./hgcgUtil\";\nimport { CONFIG_PATH } from \"../components/App\";\nimport { customAlphabet } from \"nanoid\";\nimport { WordDefinition } from \"../components/TemplateTree\";\n\nexport type WordStep = {\n  name?: string;\n  args?: any[];\n  result: Template;\n  files?: { generatorFilePath?: string; resultFilePath?: string };\n};\n\nexport function useTemplate(\n  definition: WordDefinition,\n  templateModule: any,\n  generatorModule: any,\n  wordModule: any,\n  postMessage: any,\n  isMainTemplate: boolean\n) {\n  const alphabet =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const nanoid = customAlphabet(alphabet, 4);\n\n  const [msgId, setMsgId] = useState(nanoid());\n  let [template, setTemplate] = useState<Template>(\n    last(definition.wordSteps).result\n  );\n\n  const [wordSteps, setWordSteps] = useState<WordStep[]>(definition.wordSteps);\n  function logStep(name, args, result, files = {}) {\n    console.log(\"PREV STEPS\", wordSteps);\n    const wordStep = {\n      name: name,\n      args: args,\n      result: cloneDeep(result),\n      files,\n    };\n\n    const newWordSteps = [...wordSteps, wordStep];\n    setWordSteps(newWordSteps);\n    const stringifiedSteps = newWordSteps.map((ws) => {\n      return {\n        name: ws.name,\n        args: ws.args,\n        result:\n          typeof ws.result === \"string\" ? ws.result : tts(ws.result, false),\n        files: ws.files,\n      };\n    });\n    console.log(\"STRINGIFIED STEPS\", stringifiedSteps);\n    const wordName = definition.name;\n\n    postMessage({\n      command: \"save_word_steps\",\n      wordSteps: JSON.stringify(stringifiedSteps),\n      wordName,\n      pathToConfig: CONFIG_PATH,\n      msgId,\n    });\n  }\n\n  function removeKey(key: string) {\n    const newTemplate = cloneDeep(template);\n    delete newTemplate[key];\n    logStep(\"deleteKey\", [key], newTemplate);\n    setTemplate(newTemplate);\n  }\n  function addKey(key: string) {\n    const templateHasNumerator = Object.keys(template).some((k) => {\n      return k.split(\"/\")[0] === key;\n    });\n    if (templateHasNumerator) return;\n    let combineWith = { [key]: () => ェェ };\n    let newTemplate = dumbCombine(template, combineWith);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"dumbCombine\", [template, combineWith], result);\n    setTemplate(result);\n  }\n\n  function addKeyToNumerator(appendKey: string, toKey: string) {\n    const fullToKey = Object.keys(template).find(\n      (k) => k.split(\"/\")[0] === toKey\n    );\n    if (fullToKey != null) {\n      // check that the appendKey isn't already in there\n      const denoms = fullToKey.split(\"/\")[1]?.split(\",\");\n      if (denoms?.includes(appendKey)) {\n        return;\n      }\n    }\n    let newTemplate = appendKeyToKey(template, appendKey, toKey);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"appendKeyToKey\", [template, appendKey, toKey], result);\n\n    setTemplate(result);\n  }\n\n  function insertTemplateIntoTemplate(templateToInsert: Template) {\n    console.log(\"inserting template into template\", templateToInsert);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], result);\n\n    setTemplate(result);\n  }\n  function insertTemplateIntoTemplateAtKey(\n    templateToInsert: Template,\n    toKey: string\n  ) {\n    console.log(\n      \"insertTemplateIntoTemplateAtKey\",\n      templateToInsert,\n      toKey,\n      template\n    );\n    const oldKeys = Object.keys(template);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], newTemplate);\n\n    const newKeys = Object.keys(newTemplate);\n    const newestKey = newKeys\n      .filter((k) => !oldKeys.includes(k))[0]\n      ?.split(\"/\")[0];\n    console.log(\"NEWEST KEY\", newestKey);\n    let appendedTemplate = appendKeyToKey(newTemplate, newestKey, toKey);\n    const result = sortTemplateByDeps(sortTemplateByDeps(appendedTemplate));\n    logStep(\"appendKeyToKey\", [newTemplate, newestKey, toKey], result);\n    setTemplate(result);\n  }\n\n  const handleGeneratorResult = (message: any) => {\n    console.log(\"WORD STEPS ON MESSAGE\", wordSteps);\n\n    console.log(\"MESSAGE DATA\", message.data);\n    const { generatorFilePath, resultFilePath, result, generatorString } =\n      message.data;\n    console.log(\"generator_result\", result);\n    const name = generatorString.substring(0, generatorString.indexOf(\"(\"));\n\n    const args = generatorString\n      .substring(generatorString.indexOf(\"(\") + 1, generatorString.indexOf(\")\"))\n      .split(\",\");\n\n    logStep(name, args, result, {\n      generatorFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  };\n\n  function handleGenericMessage(event: MessageEvent) {\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"file_insert\":\n        if (isMainTemplate) {\n          const { contents, filePath } = message.data;\n          const funcPart = argsAndTemplateToFunction([], contents);\n          const templ = { [filePath]: funcPart };\n          console.log(\"FILE INSERT\", contents, filePath, templ);\n          insertTemplateIntoTemplate(templ);\n        }\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleGenericMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleGenericMessage);\n    };\n  }, [isMainTemplate]);\n  function handleMessage(event: MessageEvent) {\n    if (event.data.data.msgId !== msgId) return;\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"generator_result\":\n        handleGeneratorResult(message);\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleMessage);\n    };\n  }, [wordSteps]);\n  function applyGeneratorString(generatorString: string) {\n    // form it and send it over\n    const generatorRunFile = formGeneratorFile(\n      generatorString,\n      template,\n      templateModule,\n      generatorModule\n    );\n    // send it over via postMessage\n    postMessage({\n      command: \"run_generator\",\n      generatorRunFile,\n      generatorString,\n      pathToConfig: CONFIG_PATH,\n      msgId,\n    });\n  }\n  console.log(\"Word steps\", wordSteps);\n  return {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n  };\n}\n`\n}","files":{}},{"name":"insertIntoTemplate","args":[{},{}],"full":"insertIntoTemplate([object Object],[object Object])","result":"{\n'fifth.tsxa4023e8966': ()=>`\nimport { cloneDeep, difference, last, uniqueId } from \"lodash\";\nimport { useEffect, useState } from \"react\";\nimport {\n  appendKeyToKey,\n  dumbCombine,\n  insertIntoTemplate,\n  sortTemplateByDeps,\n  tts,\n  argsAndTemplateToFunction,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { formGeneratorFile } from \"./hgcgUtil\";\nimport { CONFIG_PATH } from \"../components/App\";\nimport { customAlphabet } from \"nanoid\";\nimport { WordDefinition } from \"../components/TemplateTree\";\n\nexport type WordStep = {\n  name?: string;\n  args?: any[];\n  result: Template;\n  files?: { generatorFilePath?: string; resultFilePath?: string };\n};\n\nexport function useTemplate(\n  definition: WordDefinition,\n  templateModule: any,\n  generatorModule: any,\n  wordModule: any,\n  postMessage: any,\n  isMainTemplate: boolean\n) {\n  const alphabet =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const nanoid = customAlphabet(alphabet, 4);\n\n  const [msgId, setMsgId] = useState(nanoid());\n  let [template, setTemplate] = useState<Template>(\n    last(definition.wordSteps).result\n  );\n\n  const [wordSteps, setWordSteps] = useState<WordStep[]>(definition.wordSteps);\n  function logStep(name, args, result, files = {}) {\n    console.log(\"PREV STEPS\", wordSteps);\n    const wordStep = {\n      name: name,\n      args: args,\n      result: cloneDeep(result),\n      files,\n    };\n\n    const newWordSteps = [...wordSteps, wordStep];\n    setWordSteps(newWordSteps);\n    const stringifiedSteps = newWordSteps.map((ws) => {\n      return {\n        name: ws.name,\n        args: ws.args,\n        result:\n          typeof ws.result === \"string\" ? ws.result : tts(ws.result, false),\n        files: ws.files,\n      };\n    });\n    console.log(\"STRINGIFIED STEPS\", stringifiedSteps);\n    const wordName = definition.name;\n\n    postMessage({\n      command: \"save_word_steps\",\n      wordSteps: JSON.stringify(stringifiedSteps),\n      wordName,\n      pathToConfig: CONFIG_PATH,\n      msgId,\n    });\n  }\n\n  function removeKey(key: string) {\n    const newTemplate = cloneDeep(template);\n    delete newTemplate[key];\n    logStep(\"deleteKey\", [key], newTemplate);\n    setTemplate(newTemplate);\n  }\n  function addKey(key: string) {\n    const templateHasNumerator = Object.keys(template).some((k) => {\n      return k.split(\"/\")[0] === key;\n    });\n    if (templateHasNumerator) return;\n    let combineWith = { [key]: () => ェェ };\n    let newTemplate = dumbCombine(template, combineWith);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"dumbCombine\", [template, combineWith], result);\n    setTemplate(result);\n  }\n\n  function addKeyToNumerator(appendKey: string, toKey: string) {\n    const fullToKey = Object.keys(template).find(\n      (k) => k.split(\"/\")[0] === toKey\n    );\n    if (fullToKey != null) {\n      // check that the appendKey isn't already in there\n      const denoms = fullToKey.split(\"/\")[1]?.split(\",\");\n      if (denoms?.includes(appendKey)) {\n        return;\n      }\n    }\n    let newTemplate = appendKeyToKey(template, appendKey, toKey);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"appendKeyToKey\", [template, appendKey, toKey], result);\n\n    setTemplate(result);\n  }\n\n  function insertTemplateIntoTemplate(templateToInsert: Template) {\n    console.log(\"inserting template into template\", templateToInsert);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], result);\n\n    setTemplate(result);\n  }\n  function insertTemplateIntoTemplateAtKey(\n    templateToInsert: Template,\n    toKey: string\n  ) {\n    console.log(\n      \"insertTemplateIntoTemplateAtKey\",\n      templateToInsert,\n      toKey,\n      template\n    );\n    const oldKeys = Object.keys(template);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], newTemplate);\n\n    const newKeys = Object.keys(newTemplate);\n    const newestKey = newKeys\n      .filter((k) => !oldKeys.includes(k))[0]\n      ?.split(\"/\")[0];\n    console.log(\"NEWEST KEY\", newestKey);\n    let appendedTemplate = appendKeyToKey(newTemplate, newestKey, toKey);\n    const result = sortTemplateByDeps(sortTemplateByDeps(appendedTemplate));\n    logStep(\"appendKeyToKey\", [newTemplate, newestKey, toKey], result);\n    setTemplate(result);\n  }\n\n  const handleGeneratorResult = (message: any) => {\n    console.log(\"WORD STEPS ON MESSAGE\", wordSteps);\n\n    console.log(\"MESSAGE DATA\", message.data);\n    const { generatorFilePath, resultFilePath, result, generatorString } =\n      message.data;\n    console.log(\"generator_result\", result);\n    const name = generatorString.substring(0, generatorString.indexOf(\"(\"));\n\n    const args = generatorString\n      .substring(generatorString.indexOf(\"(\") + 1, generatorString.indexOf(\")\"))\n      .split(\",\");\n\n    logStep(name, args, result, {\n      generatorFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  };\n\n  function handleGenericMessage(event: MessageEvent) {\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"file_insert\":\n        if (isMainTemplate) {\n          const { contents, filePath } = message.data;\n          const funcPart = argsAndTemplateToFunction([], contents);\n          const templ = { [filePath]: funcPart };\n          console.log(\"FILE INSERT\", contents, filePath, templ);\n          insertTemplateIntoTemplate(templ);\n        }\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleGenericMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleGenericMessage);\n    };\n  }, [isMainTemplate]);\n  function handleMessage(event: MessageEvent) {\n    if (event.data.data.msgId !== msgId) return;\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"generator_result\":\n        handleGeneratorResult(message);\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleMessage);\n    };\n  }, [wordSteps]);\n  function applyGeneratorString(generatorString: string) {\n    // form it and send it over\n    const generatorRunFile = formGeneratorFile(\n      generatorString,\n      template,\n      templateModule,\n      generatorModule\n    );\n    // send it over via postMessage\n    postMessage({\n      command: \"run_generator\",\n      generatorRunFile,\n      generatorString,\n      pathToConfig: CONFIG_PATH,\n      msgId,\n    });\n  }\n  console.log(\"Word steps\", wordSteps);\n  return {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n  };\n}\n`,\n'panel.tsb779abdb70': ()=>`\nimport * as vscode from \"vscode\";\nimport { getNonce } from \"./getNonce\";\nimport * as fs from \"fs\";\nimport { readFile, runIndexFile, runTs, saveFile, saveWord } from \"./compiler\";\nimport {\n  argsAndTemplateToFunction,\n  genTemplateWithVars,\n  insertIntoTemplate,\n  tts,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport {\n  getAllWordPathsByLastModified,\n  getWordContents,\n  getWordNamesFromWordPaths,\n  sortFilesByLastModified,\n  readFromConfig,\n  getWordPath,\n  storeFileHash,\n  getFilePathHashes,\n  getFilePathFromHashes,\n  overwriteFile,\n  getAllFileTemplates,\n  saveRunnableWord,\n  getAllRunnableWords,\n  createRunnableGeneratorFileContents,\n} from \"./commandService\";\nimport { sha1 } from \"js-sha1\";\nimport { formWordRunFile } from \"./wordRunService\";\n\nfunction formFilePathHash(filePath: string) {\n  const fileName = filePath.split(\"/\").pop();\n  const fileHash = sha1(filePath);\n  return ェ§{fileHash.substring(0, 10)}_§{fileName}ェ;\n}\n\nfunction readFromFile(file) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(file, \"utf8\", function (err, data) {\n      if (err) {\n        console.log(err);\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nexport default class PanelClass {\n  public static currentPanel: PanelClass | undefined;\n\n  private static readonly viewType = \"PanelName\";\n\n  private readonly _panel: vscode.WebviewPanel;\n  private readonly _extensionUri: vscode.Uri;\n  private readonly _extContext: vscode.ExtensionContext;\n  private _disposables: vscode.Disposable[] = [];\n  private pathToConfig: string;\n\n  public static createOrShow(extContext: vscode.ExtensionContext) {\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    // If we already have a panel, show it.\n    // Otherwise, create a new panel.\n    if (PanelClass.currentPanel) {\n      PanelClass.currentPanel._panel.reveal(column);\n    } else {\n      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);\n      PanelClass.currentPanel = new PanelClass(\n        extContext,\n        vscode.ViewColumn.Two\n      );\n    }\n  }\n\n  public static async insertFileIntoTemplate(\n    extContext: vscode.ExtensionContext\n  ) {\n    const activeTextEditor = vscode.window.activeTextEditor;\n    if (activeTextEditor == null) {\n      return;\n    }\n    const activeEditorText = activeTextEditor.document.getText();\n    const activeEditorFilePath = activeTextEditor.document.fileName;\n    // we want to deterministically hash the filepath\n\n    const filePathHash = formFilePathHash(activeEditorFilePath);\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    // If we already have a panel, show it.\n    // Otherwise, create a new panel.\n    if (PanelClass.currentPanel) {\n      PanelClass.currentPanel._panel.reveal(column);\n    } else {\n      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);\n      PanelClass.currentPanel = new PanelClass(\n        extContext,\n        vscode.ViewColumn.Two\n      );\n    }\n\n    // we also need to store this hash somewhere!\n    console.log(\"DO WE HAVE PATH \", PanelClass.currentPanel.pathToConfig);\n    storeFileHash(\n      PanelClass.currentPanel.pathToConfig,\n      filePathHash,\n      activeEditorFilePath\n    );\n\n    /*PanelClass.currentPanel._panel.webview.postMessage({\n      command: \"file_insert\",\n      data: {\n        contents: activeEditorText,\n        filePath: filePathHash,\n      },\n    });*/\n    const fileTemplates = await getAllFileTemplates(\n      PanelClass.currentPanel.pathToConfig\n    );\n    PanelClass.currentPanel._panel.webview.postMessage({\n      command: \"all_file_templates\",\n      data: {\n        fileTemplates: tts(fileTemplates, false),\n      },\n    });\n  }\n  //temporarily setting extcontext to any type\n  private constructor(\n    _extContext: vscode.ExtensionContext,\n    column: vscode.ViewColumn\n  ) {\n    this._extContext = _extContext;\n    this._extensionUri = _extContext.extensionUri;\n\n    // Create and show a new webview panel\n    this._panel = vscode.window.createWebviewPanel(\n      PanelClass.viewType,\n      \"Blueprints\",\n      column,\n      {\n        // Enable javascript in the webview\n        enableScripts: true,\n        localResourceRoots: [this._extensionUri],\n      }\n    );\n\n    // Set the webview's initial html content\n    this._panel.webview.html = this._getHtmlForWebview(this._panel.webview);\n\n    // Listen for when the panel is disposed\n    // This happens when the user closes the panel or when the panel is closed programatically\n    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n\n    //Listen to messages\n    this._panel.webview.onDidReceiveMessage(\n      async (msg: any) => {\n        console.log(\"DID RECEIVE MSG\", msg);\n        switch (msg.command) {\n          case \"set_config_path\": {\n            const { pathToConfig } = msg;\n            console.log(\"SET CONFIG PATH\", pathToConfig);\n            this.pathToConfig = pathToConfig;\n          }\n          case \"save_all_files\": {\n            const { template, pathToConfig } = msg;\n\n            const templ = new Function(\"return \" + template)();\n            // we expect a compiled template here, so no denoms for anything, or an error if so\n            const templFileKeys = Object.keys(templ).filter(\n              (k) => k.indexOf(\".\") > -1\n            );\n            //console.log(\"TEMPL FILE KEYS\", templFileKeys);\n            const filePathHashes = await getFilePathHashes(pathToConfig);\n            //console.log(\"FILE PATH HASHES\", filePathHashes);\n            for (const filePathHash of templFileKeys) {\n              //console.log(\"filepathhash\", filePathHash);\n              // we expect a compiled template here, so no denoms for anything, or an error if so\n              const filePath = filePathHashes[filePathHash];\n              //console.log(\"FILE PATH\", filePath);\n              const fileContents = templ[filePathHash]();\n              //console.log(\"writing file\", filePath, \"Øn<>CONTENTS<>Øn\",fileContents);\n              await overwriteFile(filePath, fileContents);\n            }\n\n            break;\n          }\n          case \"startup\":\n            console.log(\"message received\");\n            // ensure bun is set up for the thing\n\n            break;\n          case \"testing\":\n            console.log(\"reachedBrain\");\n            this._panel!.webview.postMessage({ command: \"refactor\" });\n            break;\n          case \"build_project\":\n            break;\n          case \"save_word\": {\n            const { word, pathToConfig } = msg;\n            const wordsFile = await readFromConfig(\"WORDS_FILE\", pathToConfig);\n            // save to word file\n            const result = await saveWord(word, wordsFile);\n            break;\n          }\n          case \"store_runnable_word\": {\n            const { word, pathToConfig } = msg;\n            console.log(\"STORING RUNNABLE WORD\", word, pathToConfig);\n            try {\n              await saveRunnableWord(pathToConfig, word);\n              const runnableWords = await getAllRunnableWords(pathToConfig);\n              this._panel!.webview.postMessage({\n                command: \"all_runnable_words\",\n                data: {\n                  runnableWords: JSON.stringify(runnableWords),\n                },\n              });\n            } catch (e) {\n              console.error(e);\n            }\n            break;\n          }\n          case \"get_word\": {\n            const { wordName, pathToConfig } = msg;\n            const wordPath = await getWordPath(pathToConfig, wordName);\n            const wordContents = await getWordContents(wordPath);\n            this._panel!.webview.postMessage({\n              command: \"word_contents\",\n              data: {\n                wordName,\n                wordContents,\n              },\n            });\n            break;\n          }\n          case \"create_word\": {\n            const { wordName, pathToConfig, template } = msg;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const wordFile = projectDir + \"/word_\" + wordName + \".json\";\n            // eventually, result might be something more, like a file insertion\n            let wordTemplate = \"{}\";\n            if (template != null) {\n              wordTemplate = template;\n            }\n            let wordContents = JSON.stringify([{ result: wordTemplate }]);\n            await saveFile(wordFile, wordContents);\n            this._panel!.webview.postMessage({\n              command: \"word_contents\",\n              data: {\n                wordName,\n                wordContents,\n              },\n            });\n            break;\n          }\n          case \"add_full_template\": {\n            // a full template doesn't need to be generated\n            // it's the actual object that is a template\n            // we just need to add it to the template pool\n            const {template, name, pathToConfig} = msg;\n            const templatesFilePath = await readFromConfig(\n              \"TEMPLATE_FILE\",\n              pathToConfig\n            );\n            const templatesFile = await readFromFile(templatesFilePath);\n            console.log(\"CURR TEMPLATES FILE\", templatesFile);\n            // write template to templates file\n            const newTemplatesFile =\n              templatesFile + \"Øn\" + ェexport const §{name} = §{template}ェ;\n            console.log(\"NEW TEMPLATES FILE\", newTemplatesFile);\n            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {\n              if (err) {\n                console.error(err);\n              }\n              console.log(\"success\");\n            });\n\n            // bun run the file and send the result to the frontend\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const templateModule = await runTs(\n              projectDir + \"/template-getter.ts\"\n            );\n            console.log(\"ALL OF TEMPLATE MODULE\", templateModule)\n            this._panel!.webview.postMessage({\n              command: \"all_templates\",\n              data: {\n                templateModule,\n              },\n            });\n            break;\n          }\n          case \"add_template\": {\n            const { key, args, value, pathToConfig } = msg;\n            const funcPart = argsAndTemplateToFunction([], value);\n            const templ = { [key]: funcPart };\n            const templateString = ェgenTemplateWithVars(§{tts(\n              templ,\n              false\n            )}, §{args});ェ;\n            const templatesFilePath = await readFromConfig(\n              \"TEMPLATE_FILE\",\n              pathToConfig\n            );\n            const templatesFile = await readFromFile(templatesFilePath);\n            console.log(\"CURR TEMPLATES FILE\", templatesFile);\n            // write template to templates file\n            const newTemplatesFile =\n              templatesFile + \"Øn\" + ェexport const §{key} = §{templateString}ェ;\n            console.log(\"NEW TEMPLATES FILE\", newTemplatesFile);\n            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {\n              if (err) {\n                console.error(err);\n              }\n              console.log(\"success\");\n            });\n\n            // bun run the file and send the result to the frontend\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const templateModule = await runTs(\n              projectDir + \"/template-getter.ts\"\n            );\n            this._panel!.webview.postMessage({\n              command: \"all_templates\",\n              data: {\n                templateModule,\n              },\n            });\n\n            break;\n          }\n          case \"run_generator\": {\n            const { generatorString, template, pathToConfig, msgId } = msg;\n            console.log(\n              \"RUNNING\",\n              \"msgId\",\n              msgId,\n              \"AND\",\n\n              generatorString,\n              pathToConfig\n            );\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filePrefix = Date.now();\n            const generatorRunFile = await createRunnableGeneratorFileContents(\n              pathToConfig,\n              generatorString,\n              template\n            );\n            const generatorFile = filePrefix + \"_generator.ts\";\n            const resultFile = filePrefix + \"_result\";\n            const genFilePath = projectDir + \"/\" + generatorFile;\n            const resultFilePath = projectDir + \"/\" + resultFile;\n            await saveFile(genFilePath, generatorRunFile);\n            const result = await runTs(genFilePath);\n            console.log(\"RESULTv,\", result);\n            await saveFile(resultFilePath, result);\n\n            this._panel!.webview.postMessage({\n              command: \"generator_result\",\n              data: {\n                msgId,\n                generatorFilePath: genFilePath,\n                resultFilePath: resultFilePath,\n                result,\n                generatorString,\n              },\n            });\n            break;\n          }\n          case \"run_word\": {\n            const { wordName, template, pathToConfig, msgId } = msg;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filePrefix = Date.now();\n            const wordRunFile = formWordRunFile(wordName, template);\n            const wordRunFileName = filePrefix + \"_wordRun.ts\";\n            const resultFile = filePrefix + \"_result\";\n            const wordRunFilePath = projectDir + \"/\" + wordRunFileName;\n            const resultFilePath = projectDir + \"/\" + resultFile;\n            await saveFile(wordRunFilePath, wordRunFile);\n            const result = await runTs(wordRunFilePath);\n            console.log(\"word run RESULTv,\", result);\n            await saveFile(resultFilePath, result);\n\n            this._panel!.webview.postMessage({\n              command: \"word_run_result\",\n              data: {\n                msgId,\n                wordRunFilePath: wordRunFilePath,\n                resultFilePath: resultFilePath,\n                result,\n                wordString: ェ§{wordName}(template)ェ,\n              },\n            });\n            break;\n          }\n          case \"add_filled_generator\": {\n            const { msgId, filledGenerator, pathToConfig } = msg;\n\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filledGeneratorsPath = projectDir + \"/filledGenerators.json\";\n\n            let currentFilledGenerators;\n            try {\n              currentFilledGenerators = await readFile(filledGeneratorsPath);\n            } catch {\n              currentFilledGenerators = \"{}\";\n            }\n            const cfgTemplate: Template = new Function(\n              \"return \" + currentFilledGenerators\n            )();\n            const filledGeneratorTemplate: Template = new Function(\n              \"return \" + filledGenerator\n            )();\n            const newFilledGenerators = insertIntoTemplate(\n              cfgTemplate,\n              filledGeneratorTemplate\n            );\n            await saveFile(\n              filledGeneratorsPath,\n              tts(newFilledGenerators, false)\n            );\n            this._panel!.webview.postMessage({\n              command: \"all_filled_generators\",\n              data: {\n                msgId,\n                allFilledGenerators: tts(newFilledGenerators, false),\n              },\n            });\n            break;\n          }\n          case \"save_word_steps\": {\n            const { wordSteps, wordName, pathToConfig, msgId } = msg;\n            if (\n              wordSteps.length === 0 ||\n              wordSteps === \"\" ||\n              wordSteps == null\n            ) {\n              throw new Error(\"No steps to save\");\n              break;\n            }\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const wordFile = projectDir + \"/word_\" + wordName + \".json\";\n            await saveFile(wordFile, wordSteps);\n            this._panel!.webview.postMessage({\n              command: \"word_saved\",\n              data: {\n                msgId,\n              },\n            });\n            break;\n          }\n          case \"fetch_from_config\":\n            try {\n              const { pathToConfig } = msg;\n\n              // data will equal:\n              // GENERATOR_FILE=src/generators/wordBuilder.ts\n              // TEMPLATE_FILE=src/templates/wordBuilder.ts\n              // WORDS_FILE=src/words/wordBuilder.ts\n              // we want to parse each file path and send it back to the webview\n\n              const generatorPath = await readFromConfig(\n                \"GENERATOR_FILE\",\n                pathToConfig\n              );\n\n              const templatePath = await readFromConfig(\n                \"TEMPLATE_FILE\",\n                pathToConfig\n              );\n              const runnableWords = await getAllRunnableWords(pathToConfig);\n              const projectDir = await readFromConfig(\n                \"PROJECT_DIR\",\n                pathToConfig\n              );\n              const filledGeneratorsPath =\n                projectDir + \"/filledGenerators.json\";\n              const allWordPaths = await getAllWordPathsByLastModified(\n                pathToConfig\n              );\n              const sortedWordPaths = await sortFilesByLastModified(\n                allWordPaths\n              );\n\n              const templateModule = await runTs(\n                projectDir + \"/template-getter.ts\"\n              );\n\n              const promises = [\n                readFromFile(generatorPath),\n                readFromFile(templatePath),\n                readFromFile(filledGeneratorsPath),\n                getWordContents(sortedWordPaths[0]),\n              ];\n              const fileTemplates = await getAllFileTemplates(\n                PanelClass.currentPanel.pathToConfig\n              );\nconsole.log(\"FROM STARTUP TEMPLATE MODEUL\", templateModule)\n              const wordNames = getWordNamesFromWordPaths(allWordPaths);\n              const currentWordName = sortedWordPaths[0]\n                .split(\"_\")[1]\n                .replace(\".json\", \"\");\n              Promise.all(promises).then((data) => {\n                const [generators, templates, filledGenerators, currentWord] =\n                  data;\n                this._panel!.webview.postMessage({\n                  command: \"config_data\",\n                  data: {\n                    generators,\n                    templates,\n                    filledGenerators,\n                    currentWord,\n                    currentWordName,\n                    wordNames: JSON.stringify(wordNames),\n                    templateModule,\n                    fileTemplates: tts(fileTemplates, false),\n                    runnableWords: JSON.stringify(runnableWords),\n                  },\n                });\n              });\n\n              //this._panel!.webview.postMessage({ command: 'config_data', data });\n            } catch (e) {\n              console.error(e);\n            }\n            break;\n        }\n      },\n      null,\n      this._disposables\n    );\n  }\n\n  public dispose() {\n    PanelClass.currentPanel = undefined;\n    this._panel.dispose();\n    while (this._disposables.length) {\n      const x = this._disposables.pop();\n      if (x) {\n        x.dispose();\n      }\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"out\", \"main.wv.js\")\n    );\n\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"media\", \"styles.css\")\n    );\n\n    const nonce = getNonce();\n\n    return ェ<!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Symmetric Blueprints</title>\n        <link rel=\"stylesheet\" href=\"§{styleUri}\">\n      </head>\n      <body>\n        <div id=\"root\"></div>\n        <script>\n          global = window\n          \n          const vscode = acquireVsCodeApi();\n          window.onload = function() {\n            vscode.postMessage({ command: 'startup' });\n            console.log('HTML started up.');\n          };\n        </script>\n        <script nonce=\"§{nonce}\" src=\"§{scriptUri}\"></script>\n      </body>\n      </html>\n    ェ;\n  }\n}\n`\n}","files":{}},{"name":"orderedParse","args":["template"," [commandSend]"],"full":"orderedParse(template, [commandSend])","result":"{\n'commandSend017/commandBody017': ({commandBody017})=>`postMessage({${run(commandBody017,'commandBody017')}});`,\n'commandSend016/commandBody016': ({commandBody016})=>`postMessage({${run(commandBody016,'commandBody016')}});`,\n'commandSend015/commandBody015': ({commandBody015})=>`postMessage({${run(commandBody015,'commandBody015')}});`,\n'commandSend014/commandBody014': ({commandBody014})=>`postMessage({${run(commandBody014,'commandBody014')}});`,\n'commandSend013/commandBody013': ({commandBody013})=>`postMessage({${run(commandBody013,'commandBody013')}});`,\n'commandSend012/commandBody012': ({commandBody012})=>`postMessage({${run(commandBody012,'commandBody012')}});`,\n'commandSend011/commandBody011': ({commandBody011})=>`postMessage({${run(commandBody011,'commandBody011')}});`,\n'commandSend010/commandBody010': ({commandBody010})=>`postMessage({${run(commandBody010,'commandBody010')}});`,\n'commandSend09/commandBody09': ({commandBody09})=>`postMessage({${run(commandBody09,'commandBody09')}});`,\n'commandSend08/commandBody08': ({commandBody08})=>`postMessage({${run(commandBody08,'commandBody08')}});`,\n'commandSend07/commandBody07': ({commandBody07})=>`postMessage({${run(commandBody07,'commandBody07')}});`,\n'commandSend06/commandBody06': ({commandBody06})=>`postMessage({${run(commandBody06,'commandBody06')}});`,\n'commandSend05/commandBody05': ({commandBody05})=>`postMessage({${run(commandBody05,'commandBody05')}});`,\n'commandSend04/commandBody04': ({commandBody04})=>`postMessage({${run(commandBody04,'commandBody04')}});`,\n'commandSend03/commandBody03': ({commandBody03})=>`postMessage({${run(commandBody03,'commandBody03')}});`,\n'commandSend02/commandBody02': ({commandBody02})=>`postMessage({${run(commandBody02,'commandBody02')}});`,\n'commandSend01/commandBody01': ({commandBody01})=>`postMessage({${run(commandBody01,'commandBody01')}});`,\n'fifth.tsxa4023e8966/commandSend01,commandSend02': ({commandSend01, commandSend02})=>`\nimport { cloneDeep, difference, last, uniqueId } from \"lodash\";\nimport { useEffect, useState } from \"react\";\nimport {\n  appendKeyToKey,\n  dumbCombine,\n  insertIntoTemplate,\n  sortTemplateByDeps,\n  tts,\n  argsAndTemplateToFunction,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { formGeneratorFile } from \"./hgcgUtil\";\nimport { CONFIG_PATH } from \"../components/App\";\nimport { customAlphabet } from \"nanoid\";\nimport { WordDefinition } from \"../components/TemplateTree\";\n\nexport type WordStep = {\n  name?: string;\n  args?: any[];\n  result: Template;\n  files?: { generatorFilePath?: string; resultFilePath?: string };\n};\n\nexport function useTemplate(\n  definition: WordDefinition,\n  templateModule: any,\n  generatorModule: any,\n  wordModule: any,\n  postMessage: any,\n  isMainTemplate: boolean\n) {\n  const alphabet =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const nanoid = customAlphabet(alphabet, 4);\n\n  const [msgId, setMsgId] = useState(nanoid());\n  let [template, setTemplate] = useState<Template>(\n    last(definition.wordSteps).result\n  );\n\n  const [wordSteps, setWordSteps] = useState<WordStep[]>(definition.wordSteps);\n  function logStep(name, args, result, files = {}) {\n    console.log(\"PREV STEPS\", wordSteps);\n    const wordStep = {\n      name: name,\n      args: args,\n      result: cloneDeep(result),\n      files,\n    };\n\n    const newWordSteps = [...wordSteps, wordStep];\n    setWordSteps(newWordSteps);\n    const stringifiedSteps = newWordSteps.map((ws) => {\n      return {\n        name: ws.name,\n        args: ws.args,\n        result:\n          typeof ws.result === \"string\" ? ws.result : tts(ws.result, false),\n        files: ws.files,\n      };\n    });\n    console.log(\"STRINGIFIED STEPS\", stringifiedSteps);\n    const wordName = definition.name;\n\n    ${run(commandSend01, 'commandSend01')}\n  }\n\n  function removeKey(key: string) {\n    const newTemplate = cloneDeep(template);\n    delete newTemplate[key];\n    logStep(\"deleteKey\", [key], newTemplate);\n    setTemplate(newTemplate);\n  }\n  function addKey(key: string) {\n    const templateHasNumerator = Object.keys(template).some((k) => {\n      return k.split(\"/\")[0] === key;\n    });\n    if (templateHasNumerator) return;\n    let combineWith = { [key]: () => ェェ };\n    let newTemplate = dumbCombine(template, combineWith);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"dumbCombine\", [template, combineWith], result);\n    setTemplate(result);\n  }\n\n  function addKeyToNumerator(appendKey: string, toKey: string) {\n    const fullToKey = Object.keys(template).find(\n      (k) => k.split(\"/\")[0] === toKey\n    );\n    if (fullToKey != null) {\n      // check that the appendKey isn't already in there\n      const denoms = fullToKey.split(\"/\")[1]?.split(\",\");\n      if (denoms?.includes(appendKey)) {\n        return;\n      }\n    }\n    let newTemplate = appendKeyToKey(template, appendKey, toKey);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"appendKeyToKey\", [template, appendKey, toKey], result);\n\n    setTemplate(result);\n  }\n\n  function insertTemplateIntoTemplate(templateToInsert: Template) {\n    console.log(\"inserting template into template\", templateToInsert);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], result);\n\n    setTemplate(result);\n  }\n  function insertTemplateIntoTemplateAtKey(\n    templateToInsert: Template,\n    toKey: string\n  ) {\n    console.log(\n      \"insertTemplateIntoTemplateAtKey\",\n      templateToInsert,\n      toKey,\n      template\n    );\n    const oldKeys = Object.keys(template);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], newTemplate);\n\n    const newKeys = Object.keys(newTemplate);\n    const newestKey = newKeys\n      .filter((k) => !oldKeys.includes(k))[0]\n      ?.split(\"/\")[0];\n    console.log(\"NEWEST KEY\", newestKey);\n    let appendedTemplate = appendKeyToKey(newTemplate, newestKey, toKey);\n    const result = sortTemplateByDeps(sortTemplateByDeps(appendedTemplate));\n    logStep(\"appendKeyToKey\", [newTemplate, newestKey, toKey], result);\n    setTemplate(result);\n  }\n\n  const handleGeneratorResult = (message: any) => {\n    console.log(\"WORD STEPS ON MESSAGE\", wordSteps);\n\n    console.log(\"MESSAGE DATA\", message.data);\n    const { generatorFilePath, resultFilePath, result, generatorString } =\n      message.data;\n    console.log(\"generator_result\", result);\n    const name = generatorString.substring(0, generatorString.indexOf(\"(\"));\n\n    const args = generatorString\n      .substring(generatorString.indexOf(\"(\") + 1, generatorString.indexOf(\")\"))\n      .split(\",\");\n\n    logStep(name, args, result, {\n      generatorFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  };\n\n  function handleGenericMessage(event: MessageEvent) {\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"file_insert\":\n        if (isMainTemplate) {\n          const { contents, filePath } = message.data;\n          const funcPart = argsAndTemplateToFunction([], contents);\n          const templ = { [filePath]: funcPart };\n          console.log(\"FILE INSERT\", contents, filePath, templ);\n          insertTemplateIntoTemplate(templ);\n        }\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleGenericMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleGenericMessage);\n    };\n  }, [isMainTemplate]);\n  function handleMessage(event: MessageEvent) {\n    if (event.data.data.msgId !== msgId) return;\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"generator_result\":\n        handleGeneratorResult(message);\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleMessage);\n    };\n  }, [wordSteps]);\n  function applyGeneratorString(generatorString: string) {\n    // form it and send it over\n    const generatorRunFile = formGeneratorFile(\n      generatorString,\n      template,\n      templateModule,\n      generatorModule\n    );\n    // send it over via postMessage\n    ${run(commandSend02, 'commandSend02')}\n  }\n  console.log(\"Word steps\", wordSteps);\n  return {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n  };\n}\n`,\n'panel.tsb779abdb70/commandSend03,commandSend04,commandSend05,commandSend06,commandSend07,commandSend08,commandSend09,commandSend010,commandSend011,commandSend012,commandSend013,commandSend014,commandSend015,commandSend016,commandSend017': ({commandSend03, commandSend04, commandSend05, commandSend06, commandSend07, commandSend08, commandSend09, commandSend010, commandSend011, commandSend012, commandSend013, commandSend014, commandSend015, commandSend016, commandSend017})=>`\nimport * as vscode from \"vscode\";\nimport { getNonce } from \"./getNonce\";\nimport * as fs from \"fs\";\nimport { readFile, runIndexFile, runTs, saveFile, saveWord } from \"./compiler\";\nimport {\n  argsAndTemplateToFunction,\n  genTemplateWithVars,\n  insertIntoTemplate,\n  tts,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport {\n  getAllWordPathsByLastModified,\n  getWordContents,\n  getWordNamesFromWordPaths,\n  sortFilesByLastModified,\n  readFromConfig,\n  getWordPath,\n  storeFileHash,\n  getFilePathHashes,\n  getFilePathFromHashes,\n  overwriteFile,\n  getAllFileTemplates,\n  saveRunnableWord,\n  getAllRunnableWords,\n  createRunnableGeneratorFileContents,\n} from \"./commandService\";\nimport { sha1 } from \"js-sha1\";\nimport { formWordRunFile } from \"./wordRunService\";\n\nfunction formFilePathHash(filePath: string) {\n  const fileName = filePath.split(\"/\").pop();\n  const fileHash = sha1(filePath);\n  return ェ§{fileHash.substring(0, 10)}_§{fileName}ェ;\n}\n\nfunction readFromFile(file) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(file, \"utf8\", function (err, data) {\n      if (err) {\n        console.log(err);\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nexport default class PanelClass {\n  public static currentPanel: PanelClass | undefined;\n\n  private static readonly viewType = \"PanelName\";\n\n  private readonly _panel: vscode.WebviewPanel;\n  private readonly _extensionUri: vscode.Uri;\n  private readonly _extContext: vscode.ExtensionContext;\n  private _disposables: vscode.Disposable[] = [];\n  private pathToConfig: string;\n\n  public static createOrShow(extContext: vscode.ExtensionContext) {\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    // If we already have a panel, show it.\n    // Otherwise, create a new panel.\n    if (PanelClass.currentPanel) {\n      PanelClass.currentPanel._panel.reveal(column);\n    } else {\n      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);\n      PanelClass.currentPanel = new PanelClass(\n        extContext,\n        vscode.ViewColumn.Two\n      );\n    }\n  }\n\n  public static async insertFileIntoTemplate(\n    extContext: vscode.ExtensionContext\n  ) {\n    const activeTextEditor = vscode.window.activeTextEditor;\n    if (activeTextEditor == null) {\n      return;\n    }\n    const activeEditorText = activeTextEditor.document.getText();\n    const activeEditorFilePath = activeTextEditor.document.fileName;\n    // we want to deterministically hash the filepath\n\n    const filePathHash = formFilePathHash(activeEditorFilePath);\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    // If we already have a panel, show it.\n    // Otherwise, create a new panel.\n    if (PanelClass.currentPanel) {\n      PanelClass.currentPanel._panel.reveal(column);\n    } else {\n      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);\n      PanelClass.currentPanel = new PanelClass(\n        extContext,\n        vscode.ViewColumn.Two\n      );\n    }\n\n    // we also need to store this hash somewhere!\n    console.log(\"DO WE HAVE PATH \", PanelClass.currentPanel.pathToConfig);\n    storeFileHash(\n      PanelClass.currentPanel.pathToConfig,\n      filePathHash,\n      activeEditorFilePath\n    );\n\n    /*PanelClass.currentPanel._panel.webview.${run(commandSend03, 'commandSend03')}*/\n    const fileTemplates = await getAllFileTemplates(\n      PanelClass.currentPanel.pathToConfig\n    );\n    PanelClass.currentPanel._panel.webview.${run(commandSend04, 'commandSend04')}\n  }\n  //temporarily setting extcontext to any type\n  private constructor(\n    _extContext: vscode.ExtensionContext,\n    column: vscode.ViewColumn\n  ) {\n    this._extContext = _extContext;\n    this._extensionUri = _extContext.extensionUri;\n\n    // Create and show a new webview panel\n    this._panel = vscode.window.createWebviewPanel(\n      PanelClass.viewType,\n      \"Blueprints\",\n      column,\n      {\n        // Enable javascript in the webview\n        enableScripts: true,\n        localResourceRoots: [this._extensionUri],\n      }\n    );\n\n    // Set the webview's initial html content\n    this._panel.webview.html = this._getHtmlForWebview(this._panel.webview);\n\n    // Listen for when the panel is disposed\n    // This happens when the user closes the panel or when the panel is closed programatically\n    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n\n    //Listen to messages\n    this._panel.webview.onDidReceiveMessage(\n      async (msg: any) => {\n        console.log(\"DID RECEIVE MSG\", msg);\n        switch (msg.command) {\n          case \"set_config_path\": {\n            const { pathToConfig } = msg;\n            console.log(\"SET CONFIG PATH\", pathToConfig);\n            this.pathToConfig = pathToConfig;\n          }\n          case \"save_all_files\": {\n            const { template, pathToConfig } = msg;\n\n            const templ = new Function(\"return \" + template)();\n            // we expect a compiled template here, so no denoms for anything, or an error if so\n            const templFileKeys = Object.keys(templ).filter(\n              (k) => k.indexOf(\".\") > -1\n            );\n            //console.log(\"TEMPL FILE KEYS\", templFileKeys);\n            const filePathHashes = await getFilePathHashes(pathToConfig);\n            //console.log(\"FILE PATH HASHES\", filePathHashes);\n            for (const filePathHash of templFileKeys) {\n              //console.log(\"filepathhash\", filePathHash);\n              // we expect a compiled template here, so no denoms for anything, or an error if so\n              const filePath = filePathHashes[filePathHash];\n              //console.log(\"FILE PATH\", filePath);\n              const fileContents = templ[filePathHash]();\n              //console.log(\"writing file\", filePath, \"Øn<>CONTENTS<>Øn\",fileContents);\n              await overwriteFile(filePath, fileContents);\n            }\n\n            break;\n          }\n          case \"startup\":\n            console.log(\"message received\");\n            // ensure bun is set up for the thing\n\n            break;\n          case \"testing\":\n            console.log(\"reachedBrain\");\n            this._panel!.webview.${run(commandSend05, 'commandSend05')}\n            break;\n          case \"build_project\":\n            break;\n          case \"save_word\": {\n            const { word, pathToConfig } = msg;\n            const wordsFile = await readFromConfig(\"WORDS_FILE\", pathToConfig);\n            // save to word file\n            const result = await saveWord(word, wordsFile);\n            break;\n          }\n          case \"store_runnable_word\": {\n            const { word, pathToConfig } = msg;\n            console.log(\"STORING RUNNABLE WORD\", word, pathToConfig);\n            try {\n              await saveRunnableWord(pathToConfig, word);\n              const runnableWords = await getAllRunnableWords(pathToConfig);\n              this._panel!.webview.${run(commandSend06, 'commandSend06')}\n            } catch (e) {\n              console.error(e);\n            }\n            break;\n          }\n          case \"get_word\": {\n            const { wordName, pathToConfig } = msg;\n            const wordPath = await getWordPath(pathToConfig, wordName);\n            const wordContents = await getWordContents(wordPath);\n            this._panel!.webview.${run(commandSend07, 'commandSend07')}\n            break;\n          }\n          case \"create_word\": {\n            const { wordName, pathToConfig, template } = msg;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const wordFile = projectDir + \"/word_\" + wordName + \".json\";\n            // eventually, result might be something more, like a file insertion\n            let wordTemplate = \"{}\";\n            if (template != null) {\n              wordTemplate = template;\n            }\n            let wordContents = JSON.stringify([{ result: wordTemplate }]);\n            await saveFile(wordFile, wordContents);\n            this._panel!.webview.${run(commandSend08, 'commandSend08')}\n            break;\n          }\n          case \"add_full_template\": {\n            // a full template doesn't need to be generated\n            // it's the actual object that is a template\n            // we just need to add it to the template pool\n            const {template, name, pathToConfig} = msg;\n            const templatesFilePath = await readFromConfig(\n              \"TEMPLATE_FILE\",\n              pathToConfig\n            );\n            const templatesFile = await readFromFile(templatesFilePath);\n            console.log(\"CURR TEMPLATES FILE\", templatesFile);\n            // write template to templates file\n            const newTemplatesFile =\n              templatesFile + \"Øn\" + ェexport const §{name} = §{template}ェ;\n            console.log(\"NEW TEMPLATES FILE\", newTemplatesFile);\n            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {\n              if (err) {\n                console.error(err);\n              }\n              console.log(\"success\");\n            });\n\n            // bun run the file and send the result to the frontend\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const templateModule = await runTs(\n              projectDir + \"/template-getter.ts\"\n            );\n            console.log(\"ALL OF TEMPLATE MODULE\", templateModule)\n            this._panel!.webview.${run(commandSend09, 'commandSend09')}\n            break;\n          }\n          case \"add_template\": {\n            const { key, args, value, pathToConfig } = msg;\n            const funcPart = argsAndTemplateToFunction([], value);\n            const templ = { [key]: funcPart };\n            const templateString = ェgenTemplateWithVars(§{tts(\n              templ,\n              false\n            )}, §{args});ェ;\n            const templatesFilePath = await readFromConfig(\n              \"TEMPLATE_FILE\",\n              pathToConfig\n            );\n            const templatesFile = await readFromFile(templatesFilePath);\n            console.log(\"CURR TEMPLATES FILE\", templatesFile);\n            // write template to templates file\n            const newTemplatesFile =\n              templatesFile + \"Øn\" + ェexport const §{key} = §{templateString}ェ;\n            console.log(\"NEW TEMPLATES FILE\", newTemplatesFile);\n            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {\n              if (err) {\n                console.error(err);\n              }\n              console.log(\"success\");\n            });\n\n            // bun run the file and send the result to the frontend\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const templateModule = await runTs(\n              projectDir + \"/template-getter.ts\"\n            );\n            this._panel!.webview.${run(commandSend010, 'commandSend010')}\n\n            break;\n          }\n          case \"run_generator\": {\n            const { generatorString, template, pathToConfig, msgId } = msg;\n            console.log(\n              \"RUNNING\",\n              \"msgId\",\n              msgId,\n              \"AND\",\n\n              generatorString,\n              pathToConfig\n            );\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filePrefix = Date.now();\n            const generatorRunFile = await createRunnableGeneratorFileContents(\n              pathToConfig,\n              generatorString,\n              template\n            );\n            const generatorFile = filePrefix + \"_generator.ts\";\n            const resultFile = filePrefix + \"_result\";\n            const genFilePath = projectDir + \"/\" + generatorFile;\n            const resultFilePath = projectDir + \"/\" + resultFile;\n            await saveFile(genFilePath, generatorRunFile);\n            const result = await runTs(genFilePath);\n            console.log(\"RESULTv,\", result);\n            await saveFile(resultFilePath, result);\n\n            this._panel!.webview.${run(commandSend011, 'commandSend011')}\n            break;\n          }\n          case \"run_word\": {\n            const { wordName, template, pathToConfig, msgId } = msg;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filePrefix = Date.now();\n            const wordRunFile = formWordRunFile(wordName, template);\n            const wordRunFileName = filePrefix + \"_wordRun.ts\";\n            const resultFile = filePrefix + \"_result\";\n            const wordRunFilePath = projectDir + \"/\" + wordRunFileName;\n            const resultFilePath = projectDir + \"/\" + resultFile;\n            await saveFile(wordRunFilePath, wordRunFile);\n            const result = await runTs(wordRunFilePath);\n            console.log(\"word run RESULTv,\", result);\n            await saveFile(resultFilePath, result);\n\n            this._panel!.webview.${run(commandSend012, 'commandSend012')}\n            break;\n          }\n          case \"add_filled_generator\": {\n            const { msgId, filledGenerator, pathToConfig } = msg;\n\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filledGeneratorsPath = projectDir + \"/filledGenerators.json\";\n\n            let currentFilledGenerators;\n            try {\n              currentFilledGenerators = await readFile(filledGeneratorsPath);\n            } catch {\n              currentFilledGenerators = \"{}\";\n            }\n            const cfgTemplate: Template = new Function(\n              \"return \" + currentFilledGenerators\n            )();\n            const filledGeneratorTemplate: Template = new Function(\n              \"return \" + filledGenerator\n            )();\n            const newFilledGenerators = insertIntoTemplate(\n              cfgTemplate,\n              filledGeneratorTemplate\n            );\n            await saveFile(\n              filledGeneratorsPath,\n              tts(newFilledGenerators, false)\n            );\n            this._panel!.webview.${run(commandSend013, 'commandSend013')}\n            break;\n          }\n          case \"save_word_steps\": {\n            const { wordSteps, wordName, pathToConfig, msgId } = msg;\n            if (\n              wordSteps.length === 0 ||\n              wordSteps === \"\" ||\n              wordSteps == null\n            ) {\n              throw new Error(\"No steps to save\");\n              break;\n            }\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const wordFile = projectDir + \"/word_\" + wordName + \".json\";\n            await saveFile(wordFile, wordSteps);\n            this._panel!.webview.${run(commandSend014, 'commandSend014')}\n            break;\n          }\n          case \"fetch_from_config\":\n            try {\n              const { pathToConfig } = msg;\n\n              // data will equal:\n              // GENERATOR_FILE=src/generators/wordBuilder.ts\n              // TEMPLATE_FILE=src/templates/wordBuilder.ts\n              // WORDS_FILE=src/words/wordBuilder.ts\n              // we want to parse each file path and send it back to the webview\n\n              const generatorPath = await readFromConfig(\n                \"GENERATOR_FILE\",\n                pathToConfig\n              );\n\n              const templatePath = await readFromConfig(\n                \"TEMPLATE_FILE\",\n                pathToConfig\n              );\n              const runnableWords = await getAllRunnableWords(pathToConfig);\n              const projectDir = await readFromConfig(\n                \"PROJECT_DIR\",\n                pathToConfig\n              );\n              const filledGeneratorsPath =\n                projectDir + \"/filledGenerators.json\";\n              const allWordPaths = await getAllWordPathsByLastModified(\n                pathToConfig\n              );\n              const sortedWordPaths = await sortFilesByLastModified(\n                allWordPaths\n              );\n\n              const templateModule = await runTs(\n                projectDir + \"/template-getter.ts\"\n              );\n\n              const promises = [\n                readFromFile(generatorPath),\n                readFromFile(templatePath),\n                readFromFile(filledGeneratorsPath),\n                getWordContents(sortedWordPaths[0]),\n              ];\n              const fileTemplates = await getAllFileTemplates(\n                PanelClass.currentPanel.pathToConfig\n              );\nconsole.log(\"FROM STARTUP TEMPLATE MODEUL\", templateModule)\n              const wordNames = getWordNamesFromWordPaths(allWordPaths);\n              const currentWordName = sortedWordPaths[0]\n                .split(\"_\")[1]\n                .replace(\".json\", \"\");\n              Promise.all(promises).then((data) => {\n                const [generators, templates, filledGenerators, currentWord] =\n                  data;\n                this._panel!.webview.${run(commandSend015, 'commandSend015')}\n              });\n\n              //this._panel!.webview.${run(commandSend016, 'commandSend016')}\n            } catch (e) {\n              console.error(e);\n            }\n            break;\n        }\n      },\n      null,\n      this._disposables\n    );\n  }\n\n  public dispose() {\n    PanelClass.currentPanel = undefined;\n    this._panel.dispose();\n    while (this._disposables.length) {\n      const x = this._disposables.pop();\n      if (x) {\n        x.dispose();\n      }\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"out\", \"main.wv.js\")\n    );\n\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"media\", \"styles.css\")\n    );\n\n    const nonce = getNonce();\n\n    return ェ<!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Symmetric Blueprints</title>\n        <link rel=\"stylesheet\" href=\"§{styleUri}\">\n      </head>\n      <body>\n        <div id=\"root\"></div>\n        <script>\n          global = window\n          \n          const vscode = acquireVsCodeApi();\n          window.onload = function() {\n            vscode.${run(commandSend017, 'commandSend017')}\n            console.log('HTML started up.');\n          };\n        </script>\n        <script nonce=\"§{nonce}\" src=\"§{scriptUri}\"></script>\n      </body>\n      </html>\n    ェ;\n  }\n}\n`,\n'commandBody01': ()=>`\n      command: \"save_word_steps\",\n      wordSteps: JSON.stringify(stringifiedSteps),\n      wordName,\n      pathToConfig: CONFIG_PATH,\n      msgId,\n    `,\n'commandBody02': ()=>`\n      command: \"run_generator\",\n      generatorRunFile,\n      generatorString,\n      pathToConfig: CONFIG_PATH,\n      msgId,\n    `,\n'commandBody03': ()=>`\n      command: \"file_insert\",\n      data: {\n        contents: activeEditorText,\n        filePath: filePathHash,\n      },\n    `,\n'commandBody04': ()=>`\n      command: \"all_file_templates\",\n      data: {\n        fileTemplates: tts(fileTemplates, false),\n      },\n    `,\n'commandBody05': ()=>` command: \"refactor\" `,\n'commandBody06': ()=>`\n                command: \"all_runnable_words\",\n                data: {\n                  runnableWords: JSON.stringify(runnableWords),\n                },\n              `,\n'commandBody07': ()=>`\n              command: \"word_contents\",\n              data: {\n                wordName,\n                wordContents,\n              },\n            `,\n'commandBody08': ()=>`\n              command: \"word_contents\",\n              data: {\n                wordName,\n                wordContents,\n              },\n            `,\n'commandBody09': ()=>`\n              command: \"all_templates\",\n              data: {\n                templateModule,\n              },\n            `,\n'commandBody010': ()=>`\n              command: \"all_templates\",\n              data: {\n                templateModule,\n              },\n            `,\n'commandBody011': ()=>`\n              command: \"generator_result\",\n              data: {\n                msgId,\n                generatorFilePath: genFilePath,\n                resultFilePath: resultFilePath,\n                result,\n                generatorString,\n              },\n            `,\n'commandBody012': ()=>`\n              command: \"word_run_result\",\n              data: {\n                msgId,\n                wordRunFilePath: wordRunFilePath,\n                resultFilePath: resultFilePath,\n                result,\n                wordString: ェ§{wordName}(template)ェ,\n              },\n            `,\n'commandBody013': ()=>`\n              command: \"all_filled_generators\",\n              data: {\n                msgId,\n                allFilledGenerators: tts(newFilledGenerators, false),\n              },\n            `,\n'commandBody014': ()=>`\n              command: \"word_saved\",\n              data: {\n                msgId,\n              },\n            `,\n'commandBody015': ()=>`\n                  command: \"config_data\",\n                  data: {\n                    generators,\n                    templates,\n                    filledGenerators,\n                    currentWord,\n                    currentWordName,\n                    wordNames: JSON.stringify(wordNames),\n                    templateModule,\n                    fileTemplates: tts(fileTemplates, false),\n                    runnableWords: JSON.stringify(runnableWords),\n                  },\n                `,\n'commandBody016': ()=>` command: 'config_data', data `,\n'commandBody017': ()=>` command: 'startup' `\n}\n","files":{"generatorFilePath":"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/src/pools/1734972673395_generator.ts","resultFilePath":"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/src/pools/1734972673395_result"}},{"name":"orderedParse","args":["template"," [panelCommand]"],"full":"orderedParse(template, [panelCommand])","result":"{\n'fifth.tsxa4023e8966/commandSend01,commandSend02': ({commandSend01, commandSend02})=>`\nimport { cloneDeep, difference, last, uniqueId } from \"lodash\";\nimport { useEffect, useState } from \"react\";\nimport {\n  appendKeyToKey,\n  dumbCombine,\n  insertIntoTemplate,\n  sortTemplateByDeps,\n  tts,\n  argsAndTemplateToFunction,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport { formGeneratorFile } from \"./hgcgUtil\";\nimport { CONFIG_PATH } from \"../components/App\";\nimport { customAlphabet } from \"nanoid\";\nimport { WordDefinition } from \"../components/TemplateTree\";\n\nexport type WordStep = {\n  name?: string;\n  args?: any[];\n  result: Template;\n  files?: { generatorFilePath?: string; resultFilePath?: string };\n};\n\nexport function useTemplate(\n  definition: WordDefinition,\n  templateModule: any,\n  generatorModule: any,\n  wordModule: any,\n  postMessage: any,\n  isMainTemplate: boolean\n) {\n  const alphabet =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const nanoid = customAlphabet(alphabet, 4);\n\n  const [msgId, setMsgId] = useState(nanoid());\n  let [template, setTemplate] = useState<Template>(\n    last(definition.wordSteps).result\n  );\n\n  const [wordSteps, setWordSteps] = useState<WordStep[]>(definition.wordSteps);\n  function logStep(name, args, result, files = {}) {\n    console.log(\"PREV STEPS\", wordSteps);\n    const wordStep = {\n      name: name,\n      args: args,\n      result: cloneDeep(result),\n      files,\n    };\n\n    const newWordSteps = [...wordSteps, wordStep];\n    setWordSteps(newWordSteps);\n    const stringifiedSteps = newWordSteps.map((ws) => {\n      return {\n        name: ws.name,\n        args: ws.args,\n        result:\n          typeof ws.result === \"string\" ? ws.result : tts(ws.result, false),\n        files: ws.files,\n      };\n    });\n    console.log(\"STRINGIFIED STEPS\", stringifiedSteps);\n    const wordName = definition.name;\n\n    ${run(commandSend01, 'commandSend01')}\n  }\n\n  function removeKey(key: string) {\n    const newTemplate = cloneDeep(template);\n    delete newTemplate[key];\n    logStep(\"deleteKey\", [key], newTemplate);\n    setTemplate(newTemplate);\n  }\n  function addKey(key: string) {\n    const templateHasNumerator = Object.keys(template).some((k) => {\n      return k.split(\"/\")[0] === key;\n    });\n    if (templateHasNumerator) return;\n    let combineWith = { [key]: () => ェェ };\n    let newTemplate = dumbCombine(template, combineWith);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"dumbCombine\", [template, combineWith], result);\n    setTemplate(result);\n  }\n\n  function addKeyToNumerator(appendKey: string, toKey: string) {\n    const fullToKey = Object.keys(template).find(\n      (k) => k.split(\"/\")[0] === toKey\n    );\n    if (fullToKey != null) {\n      // check that the appendKey isn't already in there\n      const denoms = fullToKey.split(\"/\")[1]?.split(\",\");\n      if (denoms?.includes(appendKey)) {\n        return;\n      }\n    }\n    let newTemplate = appendKeyToKey(template, appendKey, toKey);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"appendKeyToKey\", [template, appendKey, toKey], result);\n\n    setTemplate(result);\n  }\n\n  function insertTemplateIntoTemplate(templateToInsert: Template) {\n    console.log(\"inserting template into template\", templateToInsert);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    let result = sortTemplateByDeps(sortTemplateByDeps(newTemplate));\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], result);\n\n    setTemplate(result);\n  }\n  function insertTemplateIntoTemplateAtKey(\n    templateToInsert: Template,\n    toKey: string\n  ) {\n    console.log(\n      \"insertTemplateIntoTemplateAtKey\",\n      templateToInsert,\n      toKey,\n      template\n    );\n    const oldKeys = Object.keys(template);\n    let newTemplate = insertIntoTemplate(template, templateToInsert);\n    logStep(\"insertIntoTemplate\", [template, templateToInsert], newTemplate);\n\n    const newKeys = Object.keys(newTemplate);\n    const newestKey = newKeys\n      .filter((k) => !oldKeys.includes(k))[0]\n      ?.split(\"/\")[0];\n    console.log(\"NEWEST KEY\", newestKey);\n    let appendedTemplate = appendKeyToKey(newTemplate, newestKey, toKey);\n    const result = sortTemplateByDeps(sortTemplateByDeps(appendedTemplate));\n    logStep(\"appendKeyToKey\", [newTemplate, newestKey, toKey], result);\n    setTemplate(result);\n  }\n\n  const handleGeneratorResult = (message: any) => {\n    console.log(\"WORD STEPS ON MESSAGE\", wordSteps);\n\n    console.log(\"MESSAGE DATA\", message.data);\n    const { generatorFilePath, resultFilePath, result, generatorString } =\n      message.data;\n    console.log(\"generator_result\", result);\n    const name = generatorString.substring(0, generatorString.indexOf(\"(\"));\n\n    const args = generatorString\n      .substring(generatorString.indexOf(\"(\") + 1, generatorString.indexOf(\")\"))\n      .split(\",\");\n\n    logStep(name, args, result, {\n      generatorFilePath,\n      resultFilePath,\n    });\n    setTemplate(new Function(\"return \" + result)());\n  };\n\n  function handleGenericMessage(event: MessageEvent) {\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"file_insert\":\n        if (isMainTemplate) {\n          const { contents, filePath } = message.data;\n          const funcPart = argsAndTemplateToFunction([], contents);\n          const templ = { [filePath]: funcPart };\n          console.log(\"FILE INSERT\", contents, filePath, templ);\n          insertTemplateIntoTemplate(templ);\n        }\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleGenericMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleGenericMessage);\n    };\n  }, [isMainTemplate]);\n  function handleMessage(event: MessageEvent) {\n    if (event.data.data.msgId !== msgId) return;\n    const message = event.data; // The json data that the extension sent\n    switch (message.command) {\n      case \"generator_result\":\n        handleGeneratorResult(message);\n        break;\n    }\n  }\n  useEffect(() => {\n    window.addEventListener(\"message\", handleMessage);\n    return () => {\n      window.removeEventListener(\"message\", handleMessage);\n    };\n  }, [wordSteps]);\n  function applyGeneratorString(generatorString: string) {\n    // form it and send it over\n    const generatorRunFile = formGeneratorFile(\n      generatorString,\n      template,\n      templateModule,\n      generatorModule\n    );\n    // send it over via postMessage\n    ${run(commandSend02, 'commandSend02')}\n  }\n  console.log(\"Word steps\", wordSteps);\n  return {\n    template,\n    addKey,\n    addKeyToNumerator,\n    insertTemplateIntoTemplate,\n    insertTemplateIntoTemplateAtKey,\n    wordSteps,\n    applyGeneratorString,\n    removeKey,\n  };\n}\n`,\n'commandSend02/commandBody02': ({commandBody02})=>`postMessage({${run(commandBody02, 'commandBody02')}});`,\n'commandSend01/commandBody01': ({commandBody01})=>`postMessage({${run(commandBody01, 'commandBody01')}});`,\n'panelCommandBody04/commandSend06': ({commandSend06})=>`{\n            const { word, pathToConfig } = msg;\n            console.log(\"STORING RUNNABLE WORD\", word, pathToConfig);\n            try {\n              await saveRunnableWord(pathToConfig, word);\n              const runnableWords = await getAllRunnableWords(pathToConfig);\n              this._panel!.webview.${run(commandSend06, 'commandSend06')}\n            } catch (e) {\n              console.error(e);\n            }\n            `,\n'commandSend06/commandBody06': ({commandBody06})=>`postMessage({${run(commandBody06, 'commandBody06')}});`,\n'panelCommandBody05/commandSend07': ({commandSend07})=>`{\n            const { wordName, pathToConfig } = msg;\n            const wordPath = await getWordPath(pathToConfig, wordName);\n            const wordContents = await getWordContents(wordPath);\n            this._panel!.webview.${run(commandSend07, 'commandSend07')}\n            `,\n'commandSend07/commandBody07': ({commandBody07})=>`postMessage({${run(commandBody07, 'commandBody07')}});`,\n'panelCommandBody06/commandSend08': ({commandSend08})=>`{\n            const { wordName, pathToConfig, template } = msg;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const wordFile = projectDir + \"/word_\" + wordName + \".json\";\n            // eventually, result might be something more, like a file insertion\n            let wordTemplate = \"{}\";\n            if (template != null) {\n              wordTemplate = template;\n            }\n            let wordContents = JSON.stringify([{ result: wordTemplate }]);\n            await saveFile(wordFile, wordContents);\n            this._panel!.webview.${run(commandSend08, 'commandSend08')}\n            `,\n'commandSend08/commandBody08': ({commandBody08})=>`postMessage({${run(commandBody08, 'commandBody08')}});`,\n'panelCommandBody07/commandSend09': ({commandSend09})=>`{\n            // a full template doesn't need to be generated\n            // it's the actual object that is a template\n            // we just need to add it to the template pool\n            const {template, name, pathToConfig} = msg;\n            const templatesFilePath = await readFromConfig(\n              \"TEMPLATE_FILE\",\n              pathToConfig\n            );\n            const templatesFile = await readFromFile(templatesFilePath);\n            console.log(\"CURR TEMPLATES FILE\", templatesFile);\n            // write template to templates file\n            const newTemplatesFile =\n              templatesFile + \"Øn\" + ェexport const §{name} = §{template}ェ;\n            console.log(\"NEW TEMPLATES FILE\", newTemplatesFile);\n            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {\n              if (err) {\n                console.error(err);\n              }\n              console.log(\"success\");\n            });\n\n            // bun run the file and send the result to the frontend\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const templateModule = await runTs(\n              projectDir + \"/template-getter.ts\"\n            );\n            console.log(\"ALL OF TEMPLATE MODULE\", templateModule)\n            this._panel!.webview.${run(commandSend09, 'commandSend09')}\n            `,\n'commandSend09/commandBody09': ({commandBody09})=>`postMessage({${run(commandBody09, 'commandBody09')}});`,\n'panelCommandBody08/commandSend010': ({commandSend010})=>`{\n            const { key, args, value, pathToConfig } = msg;\n            const funcPart = argsAndTemplateToFunction([], value);\n            const templ = { [key]: funcPart };\n            const templateString = ェgenTemplateWithVars(§{tts(\n              templ,\n              false\n            )}, §{args});ェ;\n            const templatesFilePath = await readFromConfig(\n              \"TEMPLATE_FILE\",\n              pathToConfig\n            );\n            const templatesFile = await readFromFile(templatesFilePath);\n            console.log(\"CURR TEMPLATES FILE\", templatesFile);\n            // write template to templates file\n            const newTemplatesFile =\n              templatesFile + \"Øn\" + ェexport const §{key} = §{templateString}ェ;\n            console.log(\"NEW TEMPLATES FILE\", newTemplatesFile);\n            fs.writeFile(templatesFilePath, newTemplatesFile, (err) => {\n              if (err) {\n                console.error(err);\n              }\n              console.log(\"success\");\n            });\n\n            // bun run the file and send the result to the frontend\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const templateModule = await runTs(\n              projectDir + \"/template-getter.ts\"\n            );\n            this._panel!.webview.${run(commandSend010, 'commandSend010')}\n\n            `,\n'commandSend010/commandBody010': ({commandBody010})=>`postMessage({${run(commandBody010, 'commandBody010')}});`,\n'panelCommandBody09/commandSend011': ({commandSend011})=>`{\n            const { generatorString, template, pathToConfig, msgId } = msg;\n            console.log(\n              \"RUNNING\",\n              \"msgId\",\n              msgId,\n              \"AND\",\n\n              generatorString,\n              pathToConfig\n            );\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filePrefix = Date.now();\n            const generatorRunFile = await createRunnableGeneratorFileContents(\n              pathToConfig,\n              generatorString,\n              template\n            );\n            const generatorFile = filePrefix + \"_generator.ts\";\n            const resultFile = filePrefix + \"_result\";\n            const genFilePath = projectDir + \"/\" + generatorFile;\n            const resultFilePath = projectDir + \"/\" + resultFile;\n            await saveFile(genFilePath, generatorRunFile);\n            const result = await runTs(genFilePath);\n            console.log(\"RESULTv,\", result);\n            await saveFile(resultFilePath, result);\n\n            this._panel!.webview.${run(commandSend011, 'commandSend011')}\n            `,\n'commandSend011/commandBody011': ({commandBody011})=>`postMessage({${run(commandBody011, 'commandBody011')}});`,\n'panelCommandBody010/commandSend012': ({commandSend012})=>`{\n            const { wordName, template, pathToConfig, msgId } = msg;\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filePrefix = Date.now();\n            const wordRunFile = formWordRunFile(wordName, template);\n            const wordRunFileName = filePrefix + \"_wordRun.ts\";\n            const resultFile = filePrefix + \"_result\";\n            const wordRunFilePath = projectDir + \"/\" + wordRunFileName;\n            const resultFilePath = projectDir + \"/\" + resultFile;\n            await saveFile(wordRunFilePath, wordRunFile);\n            const result = await runTs(wordRunFilePath);\n            console.log(\"word run RESULTv,\", result);\n            await saveFile(resultFilePath, result);\n\n            this._panel!.webview.${run(commandSend012, 'commandSend012')}\n            `,\n'commandSend012/commandBody012': ({commandBody012})=>`postMessage({${run(commandBody012, 'commandBody012')}});`,\n'panelCommandBody011/commandSend013': ({commandSend013})=>`{\n            const { msgId, filledGenerator, pathToConfig } = msg;\n\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const filledGeneratorsPath = projectDir + \"/filledGenerators.json\";\n\n            let currentFilledGenerators;\n            try {\n              currentFilledGenerators = await readFile(filledGeneratorsPath);\n            } catch {\n              currentFilledGenerators = \"{}\";\n            }\n            const cfgTemplate: Template = new Function(\n              \"return \" + currentFilledGenerators\n            )();\n            const filledGeneratorTemplate: Template = new Function(\n              \"return \" + filledGenerator\n            )();\n            const newFilledGenerators = insertIntoTemplate(\n              cfgTemplate,\n              filledGeneratorTemplate\n            );\n            await saveFile(\n              filledGeneratorsPath,\n              tts(newFilledGenerators, false)\n            );\n            this._panel!.webview.${run(commandSend013, 'commandSend013')}\n            `,\n'commandSend013/commandBody013': ({commandBody013})=>`postMessage({${run(commandBody013, 'commandBody013')}});`,\n'panel.tsb779abdb70/commandSend03,commandSend04,panelCommand01,panelCommand03,panelCommand04,panelCommand05,panelCommand06,panelCommand07,panelCommand08,panelCommand09,panelCommand010,panelCommand011,panelCommand012,commandSend014,commandSend015,commandSend016,commandSend017': ({commandSend03, commandSend04, panelCommand01, panelCommand03, panelCommand04, panelCommand05, panelCommand06, panelCommand07, panelCommand08, panelCommand09, panelCommand010, panelCommand011, panelCommand012, commandSend014, commandSend015, commandSend016, commandSend017})=>`\nimport * as vscode from \"vscode\";\nimport { getNonce } from \"./getNonce\";\nimport * as fs from \"fs\";\nimport { readFile, runIndexFile, runTs, saveFile, saveWord } from \"./compiler\";\nimport {\n  argsAndTemplateToFunction,\n  genTemplateWithVars,\n  insertIntoTemplate,\n  tts,\n} from \"symmetric-parser\";\nimport { Template } from \"symmetric-parser/dist/src/templator/template-group\";\nimport {\n  getAllWordPathsByLastModified,\n  getWordContents,\n  getWordNamesFromWordPaths,\n  sortFilesByLastModified,\n  readFromConfig,\n  getWordPath,\n  storeFileHash,\n  getFilePathHashes,\n  getFilePathFromHashes,\n  overwriteFile,\n  getAllFileTemplates,\n  saveRunnableWord,\n  getAllRunnableWords,\n  createRunnableGeneratorFileContents,\n} from \"./commandService\";\nimport { sha1 } from \"js-sha1\";\nimport { formWordRunFile } from \"./wordRunService\";\n\nfunction formFilePathHash(filePath: string) {\n  const fileName = filePath.split(\"/\").pop();\n  const fileHash = sha1(filePath);\n  return ェ§{fileHash.substring(0, 10)}_§{fileName}ェ;\n}\n\nfunction readFromFile(file) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(file, \"utf8\", function (err, data) {\n      if (err) {\n        console.log(err);\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nexport default class PanelClass {\n  public static currentPanel: PanelClass | undefined;\n\n  private static readonly viewType = \"PanelName\";\n\n  private readonly _panel: vscode.WebviewPanel;\n  private readonly _extensionUri: vscode.Uri;\n  private readonly _extContext: vscode.ExtensionContext;\n  private _disposables: vscode.Disposable[] = [];\n  private pathToConfig: string;\n\n  public static createOrShow(extContext: vscode.ExtensionContext) {\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    // If we already have a panel, show it.\n    // Otherwise, create a new panel.\n    if (PanelClass.currentPanel) {\n      PanelClass.currentPanel._panel.reveal(column);\n    } else {\n      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);\n      PanelClass.currentPanel = new PanelClass(\n        extContext,\n        vscode.ViewColumn.Two\n      );\n    }\n  }\n\n  public static async insertFileIntoTemplate(\n    extContext: vscode.ExtensionContext\n  ) {\n    const activeTextEditor = vscode.window.activeTextEditor;\n    if (activeTextEditor == null) {\n      return;\n    }\n    const activeEditorText = activeTextEditor.document.getText();\n    const activeEditorFilePath = activeTextEditor.document.fileName;\n    // we want to deterministically hash the filepath\n\n    const filePathHash = formFilePathHash(activeEditorFilePath);\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    // If we already have a panel, show it.\n    // Otherwise, create a new panel.\n    if (PanelClass.currentPanel) {\n      PanelClass.currentPanel._panel.reveal(column);\n    } else {\n      // ReactPanel.currentPanel = new ReactPanel(extensionPath, column || vscode.ViewColumn.One);\n      PanelClass.currentPanel = new PanelClass(\n        extContext,\n        vscode.ViewColumn.Two\n      );\n    }\n\n    // we also need to store this hash somewhere!\n    console.log(\"DO WE HAVE PATH \", PanelClass.currentPanel.pathToConfig);\n    storeFileHash(\n      PanelClass.currentPanel.pathToConfig,\n      filePathHash,\n      activeEditorFilePath\n    );\n\n    /*PanelClass.currentPanel._panel.webview.${run(commandSend03, 'commandSend03')}*/\n    const fileTemplates = await getAllFileTemplates(\n      PanelClass.currentPanel.pathToConfig\n    );\n    PanelClass.currentPanel._panel.webview.${run(commandSend04, 'commandSend04')}\n  }\n  //temporarily setting extcontext to any type\n  private constructor(\n    _extContext: vscode.ExtensionContext,\n    column: vscode.ViewColumn\n  ) {\n    this._extContext = _extContext;\n    this._extensionUri = _extContext.extensionUri;\n\n    // Create and show a new webview panel\n    this._panel = vscode.window.createWebviewPanel(\n      PanelClass.viewType,\n      \"Blueprints\",\n      column,\n      {\n        // Enable javascript in the webview\n        enableScripts: true,\n        localResourceRoots: [this._extensionUri],\n      }\n    );\n\n    // Set the webview's initial html content\n    this._panel.webview.html = this._getHtmlForWebview(this._panel.webview);\n\n    // Listen for when the panel is disposed\n    // This happens when the user closes the panel or when the panel is closed programatically\n    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n\n    //Listen to messages\n    this._panel.webview.onDidReceiveMessage(\n      async (msg: any) => {\n        console.log(\"DID RECEIVE MSG\", msg);\n        switch (msg.command) {\n          ${run(panelCommand01, 'panelCommand01')}\n          }\n          ${run(panelCommand03, 'panelCommand03')}\n          }\n          ${run(panelCommand04, 'panelCommand04')}\n          }\n          ${run(panelCommand05, 'panelCommand05')}\n          }\n          ${run(panelCommand06, 'panelCommand06')}\n          }\n          ${run(panelCommand07, 'panelCommand07')}\n          }\n          ${run(panelCommand08, 'panelCommand08')}\n          }\n          ${run(panelCommand09, 'panelCommand09')}\n          }\n          ${run(panelCommand010, 'panelCommand010')}\n          }\n          ${run(panelCommand011, 'panelCommand011')}\n          }\n          ${run(panelCommand012, 'panelCommand012')}\n            }\n            const projectDir = await readFromConfig(\n              \"PROJECT_DIR\",\n              pathToConfig\n            );\n            const wordFile = projectDir + \"/word_\" + wordName + \".json\";\n            await saveFile(wordFile, wordSteps);\n            this._panel!.webview.${run(commandSend014, 'commandSend014')}\n            break;\n          }\n          case \"fetch_from_config\":\n            try {\n              const { pathToConfig } = msg;\n\n              // data will equal:\n              // GENERATOR_FILE=src/generators/wordBuilder.ts\n              // TEMPLATE_FILE=src/templates/wordBuilder.ts\n              // WORDS_FILE=src/words/wordBuilder.ts\n              // we want to parse each file path and send it back to the webview\n\n              const generatorPath = await readFromConfig(\n                \"GENERATOR_FILE\",\n                pathToConfig\n              );\n\n              const templatePath = await readFromConfig(\n                \"TEMPLATE_FILE\",\n                pathToConfig\n              );\n              const runnableWords = await getAllRunnableWords(pathToConfig);\n              const projectDir = await readFromConfig(\n                \"PROJECT_DIR\",\n                pathToConfig\n              );\n              const filledGeneratorsPath =\n                projectDir + \"/filledGenerators.json\";\n              const allWordPaths = await getAllWordPathsByLastModified(\n                pathToConfig\n              );\n              const sortedWordPaths = await sortFilesByLastModified(\n                allWordPaths\n              );\n\n              const templateModule = await runTs(\n                projectDir + \"/template-getter.ts\"\n              );\n\n              const promises = [\n                readFromFile(generatorPath),\n                readFromFile(templatePath),\n                readFromFile(filledGeneratorsPath),\n                getWordContents(sortedWordPaths[0]),\n              ];\n              const fileTemplates = await getAllFileTemplates(\n                PanelClass.currentPanel.pathToConfig\n              );\nconsole.log(\"FROM STARTUP TEMPLATE MODEUL\", templateModule)\n              const wordNames = getWordNamesFromWordPaths(allWordPaths);\n              const currentWordName = sortedWordPaths[0]\n                .split(\"_\")[1]\n                .replace(\".json\", \"\");\n              Promise.all(promises).then((data) => {\n                const [generators, templates, filledGenerators, currentWord] =\n                  data;\n                this._panel!.webview.${run(commandSend015, 'commandSend015')}\n              });\n\n              //this._panel!.webview.${run(commandSend016, 'commandSend016')}\n            } catch (e) {\n              console.error(e);\n            }\n            break;\n        }\n      },\n      null,\n      this._disposables\n    );\n  }\n\n  public dispose() {\n    PanelClass.currentPanel = undefined;\n    this._panel.dispose();\n    while (this._disposables.length) {\n      const x = this._disposables.pop();\n      if (x) {\n        x.dispose();\n      }\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"out\", \"main.wv.js\")\n    );\n\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"media\", \"styles.css\")\n    );\n\n    const nonce = getNonce();\n\n    return ェ<!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Symmetric Blueprints</title>\n        <link rel=\"stylesheet\" href=\"§{styleUri}\">\n      </head>\n      <body>\n        <div id=\"root\"></div>\n        <script>\n          global = window\n          \n          const vscode = acquireVsCodeApi();\n          window.onload = function() {\n            vscode.${run(commandSend017, 'commandSend017')}\n            console.log('HTML started up.');\n          };\n        </script>\n        <script nonce=\"§{nonce}\" src=\"§{scriptUri}\"></script>\n      </body>\n      </html>\n    ェ;\n  }\n}\n`,\n'panelCommand012/panelCommandName012,panelCommandBody012': ({panelCommandName012, panelCommandBody012})=>`case \"${run(panelCommandName012,'panelCommandName012')}\": ${run(panelCommandBody012,'panelCommandBody012')}break;`,\n'panelCommand011/panelCommandName011,panelCommandBody011': ({panelCommandName011, panelCommandBody011})=>`case \"${run(panelCommandName011,'panelCommandName011')}\": ${run(panelCommandBody011,'panelCommandBody011')}break;`,\n'panelCommand010/panelCommandName010,panelCommandBody010': ({panelCommandName010, panelCommandBody010})=>`case \"${run(panelCommandName010,'panelCommandName010')}\": ${run(panelCommandBody010,'panelCommandBody010')}break;`,\n'panelCommand09/panelCommandName09,panelCommandBody09': ({panelCommandName09, panelCommandBody09})=>`case \"${run(panelCommandName09,'panelCommandName09')}\": ${run(panelCommandBody09,'panelCommandBody09')}break;`,\n'panelCommand08/panelCommandName08,panelCommandBody08': ({panelCommandName08, panelCommandBody08})=>`case \"${run(panelCommandName08,'panelCommandName08')}\": ${run(panelCommandBody08,'panelCommandBody08')}break;`,\n'panelCommand07/panelCommandName07,panelCommandBody07': ({panelCommandName07, panelCommandBody07})=>`case \"${run(panelCommandName07,'panelCommandName07')}\": ${run(panelCommandBody07,'panelCommandBody07')}break;`,\n'panelCommand06/panelCommandName06,panelCommandBody06': ({panelCommandName06, panelCommandBody06})=>`case \"${run(panelCommandName06,'panelCommandName06')}\": ${run(panelCommandBody06,'panelCommandBody06')}break;`,\n'panelCommand05/panelCommandName05,panelCommandBody05': ({panelCommandName05, panelCommandBody05})=>`case \"${run(panelCommandName05,'panelCommandName05')}\": ${run(panelCommandBody05,'panelCommandBody05')}break;`,\n'panelCommand04/panelCommandName04,panelCommandBody04': ({panelCommandName04, panelCommandBody04})=>`case \"${run(panelCommandName04,'panelCommandName04')}\": ${run(panelCommandBody04,'panelCommandBody04')}break;`,\n'panelCommand03/panelCommandName03,panelCommandBody03': ({panelCommandName03, panelCommandBody03})=>`case \"${run(panelCommandName03,'panelCommandName03')}\": ${run(panelCommandBody03,'panelCommandBody03')}break;`,\n'panelCommandName03/commandSend05': ({commandSend05})=>`startup\":\n            console.log(\"message received\");\n            // ensure bun is set up for the thing\n\n            break;\n          case \"testing\":\n            console.log(\"reachedBrain\");\n            this._panel!.webview.${run(commandSend05, 'commandSend05')}\n            break;\n          case \"build_project\":\n            break;\n          case \"save_word`,\n'commandSend05/commandBody05': ({commandBody05})=>`postMessage({${run(commandBody05, 'commandBody05')}});`,\n'panelCommand01/panelCommandName01,panelCommandBody01': ({panelCommandName01, panelCommandBody01})=>`case \"${run(panelCommandName01,'panelCommandName01')}\": ${run(panelCommandBody01,'panelCommandBody01')}break;`,\n'panelCommandBody01/panelCommand02': ({panelCommand02})=>`{\n            const { pathToConfig } = msg;\n            console.log(\"SET CONFIG PATH\", pathToConfig);\n            this.pathToConfig = pathToConfig;\n          }\n          ${run(panelCommand02, 'panelCommand02')}{\n            const { template, pathToConfig } = msg;\n\n            const templ = new Function(\"return \" + template)();\n            // we expect a compiled template here, so no denoms for anything, or an error if so\n            const templFileKeys = Object.keys(templ).filter(\n              (k) => k.indexOf(\".\") > -1\n            );\n            //console.log(\"TEMPL FILE KEYS\", templFileKeys);\n            const filePathHashes = await getFilePathHashes(pathToConfig);\n            //console.log(\"FILE PATH HASHES\", filePathHashes);\n            for (const filePathHash of templFileKeys) {\n              //console.log(\"filepathhash\", filePathHash);\n              // we expect a compiled template here, so no denoms for anything, or an error if so\n              const filePath = filePathHashes[filePathHash];\n              //console.log(\"FILE PATH\", filePath);\n              const fileContents = templ[filePathHash]();\n              //console.log(\"writing file\", filePath, \"Øn<>CONTENTS<>Øn\",fileContents);\n              await overwriteFile(filePath, fileContents);\n            }\n\n            `,\n'panelCommand02/panelCommandName02,panelCommandBody02': ({panelCommandName02, panelCommandBody02})=>`case \"${run(panelCommandName02,'panelCommandName02')}\": ${run(panelCommandBody02,'panelCommandBody02')}break;`,\n'commandSend017/commandBody017': ({commandBody017})=>`postMessage({${run(commandBody017, 'commandBody017')}});`,\n'commandSend016/commandBody016': ({commandBody016})=>`postMessage({${run(commandBody016, 'commandBody016')}});`,\n'commandSend015/commandBody015': ({commandBody015})=>`postMessage({${run(commandBody015, 'commandBody015')}});`,\n'commandSend014/commandBody014': ({commandBody014})=>`postMessage({${run(commandBody014, 'commandBody014')}});`,\n'commandSend04/commandBody04': ({commandBody04})=>`postMessage({${run(commandBody04, 'commandBody04')}});`,\n'commandSend03/commandBody03': ({commandBody03})=>`postMessage({${run(commandBody03, 'commandBody03')}});`,\n'commandBody01': ()=>`\n      command: \"save_word_steps\",\n      wordSteps: JSON.stringify(stringifiedSteps),\n      wordName,\n      pathToConfig: CONFIG_PATH,\n      msgId,\n    `,\n'commandBody02': ()=>`\n      command: \"run_generator\",\n      generatorRunFile,\n      generatorString,\n      pathToConfig: CONFIG_PATH,\n      msgId,\n    `,\n'commandBody03': ()=>`\n      command: \"file_insert\",\n      data: {\n        contents: activeEditorText,\n        filePath: filePathHash,\n      },\n    `,\n'commandBody04': ()=>`\n      command: \"all_file_templates\",\n      data: {\n        fileTemplates: tts(fileTemplates, false),\n      },\n    `,\n'commandBody05': ()=>` command: \"refactor\" `,\n'commandBody06': ()=>`\n                command: \"all_runnable_words\",\n                data: {\n                  runnableWords: JSON.stringify(runnableWords),\n                },\n              `,\n'commandBody07': ()=>`\n              command: \"word_contents\",\n              data: {\n                wordName,\n                wordContents,\n              },\n            `,\n'commandBody08': ()=>`\n              command: \"word_contents\",\n              data: {\n                wordName,\n                wordContents,\n              },\n            `,\n'commandBody09': ()=>`\n              command: \"all_templates\",\n              data: {\n                templateModule,\n              },\n            `,\n'commandBody010': ()=>`\n              command: \"all_templates\",\n              data: {\n                templateModule,\n              },\n            `,\n'commandBody011': ()=>`\n              command: \"generator_result\",\n              data: {\n                msgId,\n                generatorFilePath: genFilePath,\n                resultFilePath: resultFilePath,\n                result,\n                generatorString,\n              },\n            `,\n'commandBody012': ()=>`\n              command: \"word_run_result\",\n              data: {\n                msgId,\n                wordRunFilePath: wordRunFilePath,\n                resultFilePath: resultFilePath,\n                result,\n                wordString: ェ§{wordName}(template)ェ,\n              },\n            `,\n'commandBody013': ()=>`\n              command: \"all_filled_generators\",\n              data: {\n                msgId,\n                allFilledGenerators: tts(newFilledGenerators, false),\n              },\n            `,\n'commandBody014': ()=>`\n              command: \"word_saved\",\n              data: {\n                msgId,\n              },\n            `,\n'commandBody015': ()=>`\n                  command: \"config_data\",\n                  data: {\n                    generators,\n                    templates,\n                    filledGenerators,\n                    currentWord,\n                    currentWordName,\n                    wordNames: JSON.stringify(wordNames),\n                    templateModule,\n                    fileTemplates: tts(fileTemplates, false),\n                    runnableWords: JSON.stringify(runnableWords),\n                  },\n                `,\n'commandBody016': ()=>` command: 'config_data', data `,\n'commandBody017': ()=>` command: 'startup' `,\n'panelCommandBody03': ()=>`{\n            const { word, pathToConfig } = msg;\n            const wordsFile = await readFromConfig(\"WORDS_FILE\", pathToConfig);\n            // save to word file\n            const result = await saveWord(word, wordsFile);\n            `,\n'panelCommandBody012': ()=>`{\n            const { wordSteps, wordName, pathToConfig, msgId } = msg;\n            if (\n              wordSteps.length === 0 ||\n              wordSteps === \"\" ||\n              wordSteps == null\n            ) {\n              throw new Error(\"No steps to save\");\n              `,\n'panelCommandName01': ()=>`set_config_path`,\n'panelCommandName02': ()=>`save_all_files`,\n'panelCommandName04': ()=>`store_runnable_word`,\n'panelCommandName05': ()=>`get_word`,\n'panelCommandName06': ()=>`create_word`,\n'panelCommandName07': ()=>`add_full_template`,\n'panelCommandName08': ()=>`add_template`,\n'panelCommandName09': ()=>`run_generator`,\n'panelCommandName010': ()=>`run_word`,\n'panelCommandName011': ()=>`add_filled_generator`,\n'panelCommandName012': ()=>`save_word_steps`\n}\n","files":{"generatorFilePath":"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/src/pools/1734972675931_generator.ts","resultFilePath":"/Users/jaykoontz/Documents/GitHub/symmetric-blueprints/src/pools/1734972675931_result"}}]